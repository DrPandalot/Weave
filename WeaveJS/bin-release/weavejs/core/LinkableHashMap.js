/**
 * Generated by Apache Flex Cross-Compiler from weavejs\core\LinkableHashMap.as
 * weavejs.core.LinkableHashMap
 *
 * @fileoverview
 *
 * @suppress {checkTypes}
 */

goog.provide('weavejs.core.LinkableHashMap');

goog.require('weavejs.Weave');
goog.require('weavejs.WeaveAPI');
goog.require('weavejs.api.core.DynamicState');
goog.require('weavejs.core.CallbackCollection');
goog.require('weavejs.core.ChildListCallbackInterface');
goog.require('weavejs.utils.Utils');
goog.require('weavejs.api.core.ICallbackCollection');
goog.require('weavejs.api.core.IChildListCallbackInterface');
goog.require('weavejs.api.core.ILinkableHashMap');
goog.require('weavejs.api.core.ILinkableObject');



/**
 * Constructor.
 * @asparam typeRestriction If specified, this will limit the type of objects that can be added to this LinkableHashMap.
 * @constructor
 * @extends {weavejs.core.CallbackCollection}
 * @implements {weavejs.api.core.ILinkableHashMap}
 * @param {Object=} typeRestriction
 */
weavejs.core.LinkableHashMap = function(typeRestriction) {
  weavejs.core.LinkableHashMap.base(this, 'constructor', typeRestriction);
  typeRestriction = typeof typeRestriction !== 'undefined' ? typeRestriction : null;
  this._typeRestriction = typeRestriction;
  this._childListCallbacks = weavejs.WeaveAPI.SessionManager.newLinkableChild(this, weavejs.core.ChildListCallbackInterface);
  this._orderedNames = [];
  this._nameToObjectMap = {};
  this._map_objectToNameMap = new weavejs.utils.Utils.WeakMap();
  this._nameIsLocked = {};
  this._previousNameMap = {};
};
goog.inherits(weavejs.core.LinkableHashMap, weavejs.core.CallbackCollection);


/**
 * @private
 * @type {weavejs.core.ChildListCallbackInterface}
 */
weavejs.core.LinkableHashMap.prototype._childListCallbacks;


/**
 * @private
 * @type {Array}
 */
weavejs.core.LinkableHashMap.prototype._orderedNames;


/**
 * @private
 * @type {Object}
 */
weavejs.core.LinkableHashMap.prototype._nameToObjectMap;


/**
 * @private
 * @type {Object}
 */
weavejs.core.LinkableHashMap.prototype._map_objectToNameMap;


/**
 * @private
 * @type {Object}
 */
weavejs.core.LinkableHashMap.prototype._nameIsLocked;


/**
 * @private
 * @type {Object}
 */
weavejs.core.LinkableHashMap.prototype._previousNameMap;


/**
 * @private
 * @type {Object}
 */
weavejs.core.LinkableHashMap.prototype._typeRestriction;


/**
 * @inheritDoc
 * @export
 * @param {Object=} filter
 * @return {Array}
 */
weavejs.core.LinkableHashMap.prototype.getNames = function(filter) {
  filter = typeof filter !== 'undefined' ? filter : null;
  var /** @type {Array} */ result = [];
  for (var /** @type {number} */ i = 0; i < this._orderedNames.length; i++) {
    var /** @type {string} */ name = this._orderedNames[i];
    if (filter == null || org.apache.flex.utils.Language.is(this._nameToObjectMap[name], filter))
      result.push(name);
  }
  return result;
};


/**
 * @inheritDoc
 * @export
 * @param {Object=} filter
 * @return {Array}
 */
weavejs.core.LinkableHashMap.prototype.getObjects = function(filter) {
  filter = typeof filter !== 'undefined' ? filter : null;
  var /** @type {Array} */ result = [];
  for (var /** @type {number} */ i = 0; i < this._orderedNames.length; i++) {
    var /** @type {string} */ name = this._orderedNames[i];
    var /** @type {weavejs.api.core.ILinkableObject} */ object = this._nameToObjectMap[name];
    if (filter == null || org.apache.flex.utils.Language.is(object, filter))
      result.push(object);
  }
  return result;
};


/**
 * @inheritDoc
 * @export
 * @param {string} name
 * @return {weavejs.api.core.ILinkableObject}
 */
weavejs.core.LinkableHashMap.prototype.getObject = function(name) {
  return this._nameToObjectMap[name];
};


/**
 * @inheritDoc
 * @export
 * @param {weavejs.api.core.ILinkableObject} object
 * @return {string}
 */
weavejs.core.LinkableHashMap.prototype.getName = function(object) {
  return this._map_objectToNameMap.get(object);
};


/**
 * @inheritDoc
 * @export
 * @param {Array} newOrder
 */
weavejs.core.LinkableHashMap.prototype.setNameOrder = function(newOrder) {
  var /** @type {boolean} */ changeDetected = false;
  var /** @type {string} */ name;
  var /** @type {number} */ i;
  var /** @type {number} */ originalNameCount = this._orderedNames.length;
  var /** @type {Object} */ haveSeen = {};
  for (i = 0; i < newOrder.length; i++) {
    name = newOrder[i];
    if (this._nameToObjectMap[name] == undefined || haveSeen[name] != undefined)
      continue;
    haveSeen[name] = true;
    this._orderedNames.push(name);
  }
  var /** @type {number} */ appendedCount = this._orderedNames.length - originalNameCount;
  for (i = 0; i < appendedCount; i++) {
    var /** @type {number} */ newIndex = originalNameCount + i;
    var /** @type {number} */ oldIndex = this._orderedNames.indexOf(this._orderedNames[newIndex]);
    if (newIndex - oldIndex != appendedCount)
      changeDetected = true;
    this._orderedNames[oldIndex] = null;
  }
  var /** @type {number} */ out = 0;
  for (i = 0; i < this._orderedNames.length; i++)
    if (this._orderedNames[i] != null)
      this._orderedNames[out++] = this._orderedNames[i];
  this._orderedNames.length = out;
  if (changeDetected)
    this._childListCallbacks.runCallbacks(null, null, null);
};


/**
 * @inheritDoc
 * @export
 * @param {string} name
 * @param {Object} classDef
 * @param {boolean} lockObject
 * @return {*}
 */
weavejs.core.LinkableHashMap.prototype.requestObject = function(name, classDef, lockObject) {
  var /** @type {string} */ className = classDef ? weavejs.Weave.className(classDef) : null;
  var /** @type {*} */ result = this.initObjectByClassName(name, className, lockObject);
  return classDef ? org.apache.flex.utils.Language.as(result, classDef) : null;
};


/**
 * @inheritDoc
 * @export
 * @param {string} name
 * @param {weavejs.api.core.ILinkableObject} objectToCopy
 * @return {weavejs.api.core.ILinkableObject}
 */
weavejs.core.LinkableHashMap.prototype.requestObjectCopy = function(name, objectToCopy) {
  if (objectToCopy == null) {
    this.removeObject(name);
    return null;
  }
  this.delayCallbacks();
  var /** @type {Object} */ classDef = Object(objectToCopy).constructor;
  var /** @type {Object} */ sessionState = weavejs.WeaveAPI.SessionManager.getSessionState(objectToCopy);
  if (name == this.getName(objectToCopy))
    this.removeObject(name);
  var /** @type {weavejs.api.core.ILinkableObject} */ object = this.requestObject(name, classDef, false);
  if (object != null)
    weavejs.WeaveAPI.SessionManager.setSessionState(object, sessionState);
  this.resumeCallbacks();
  return object;
};


/**
 * @inheritDoc
 * @export
 * @param {string} oldName
 * @param {string} newName
 * @return {weavejs.api.core.ILinkableObject}
 */
weavejs.core.LinkableHashMap.prototype.renameObject = function(oldName, newName) {
  if (oldName != newName) {
    this.delayCallbacks();
    var /** @type {Array} */ newNameOrder = this._orderedNames.concat();
    var /** @type {number} */ index = newNameOrder.indexOf(oldName);
    if (index >= 0)
      newNameOrder.splice(index, 1, newName);
    this.requestObjectCopy(newName, this.getObject(oldName));
    this.removeObject(oldName);
    this.setNameOrder(newNameOrder);
    this.resumeCallbacks();
  }
  return this.getObject(newName);
};


/**
 * If there is an existing object associated with the specified name, it will be kept if it
 * is the specified type, or replaced with a new instance of the specified type if it is not.
 * @asparam name The identifying name of a new or existing object.  If this is null, a new one will be generated.
 * @asparam className The qualified class name of the desired object type.
 * @asparam lockObject If this is set to true, lockObject() will be called on the given name.
 * @asreturn The object associated with the given name, or null if an error occurred.
 * @private
 * @param {string} name
 * @param {string} className
 * @param {boolean=} lockObject
 * @return {weavejs.api.core.ILinkableObject}
 */
weavejs.core.LinkableHashMap.prototype.initObjectByClassName = function(name, className, lockObject) {
  lockObject = typeof lockObject !== 'undefined' ? lockObject : false;
  if (className) {
    if (!name)
      name = this.generateUniqueName(className.split("::").pop());
    var /** @type {Object} */ classDef = weavejs.Weave.getDefinition(className);
    var /** @type {Object} */ typeRestriction = this._typeRestriction;
    if (weavejs.Weave.isLinkable(classDef.prototype) && (typeRestriction == null || org.apache.flex.utils.Language.is(classDef.prototype, typeRestriction))) {
      var /** @type {Object} */ object = this._nameToObjectMap[name];
      if (!object || object.constructor != classDef)
        this.createAndSaveNewObject(name, classDef, lockObject);
      else if (lockObject)
        this.lockObject(name);
    } else {
      this.removeObject(name);
    }
  } else {
    this.removeObject(name);
  }
  return this._nameToObjectMap[name];
};


/**
 * (private)
 * @asparam name The identifying name to associate with a new object.
 * @asparam classDef The Class definition used to instantiate a new object.
 * @private
 * @param {string} name
 * @param {Object} classDef
 * @param {boolean} lockObject
 */
weavejs.core.LinkableHashMap.prototype.createAndSaveNewObject = function(name, classDef, lockObject) {
  if (this._nameIsLocked[name])
    return;
  this.removeObject(name);
  var /** @type {weavejs.api.core.ILinkableObject} */ object = new classDef();
  weavejs.WeaveAPI.SessionManager.registerLinkableChild(this, object);
  this._nameToObjectMap[name] = object;
  this._map_objectToNameMap.set(object, name);
  this._orderedNames.push(name);
  this._previousNameMap[name] = true;
  if (lockObject)
    this.lockObject(name);
  this._childListCallbacks.runCallbacks(name, object, null);
};


/**
 * This function will lock an object in place for a given identifying name.
 * If there is no object using the specified name, this function will have no effect.
 * @asparam name The identifying name of an object to lock in place.
 * @private
 * @param {string} name
 */
weavejs.core.LinkableHashMap.prototype.lockObject = function(name) {
  if (name != null && this._nameToObjectMap[name] != null)
    this._nameIsLocked[name] = true;
};


/**
 * @inheritDoc
 * @export
 * @param {string} name
 * @return {boolean}
 */
weavejs.core.LinkableHashMap.prototype.objectIsLocked = function(name) {
  return this._nameIsLocked[name] ? true : false;
};


/**
 * @inheritDoc
 * @export
 * @param {string} name
 */
weavejs.core.LinkableHashMap.prototype.removeObject = function(name) {
  if (!name || this._nameIsLocked[name])
    return;
  var /** @type {weavejs.api.core.ILinkableObject} */ object = this._nameToObjectMap[name];
  if (object == null)
    return;
  delete this._nameToObjectMap[name];
  this._map_objectToNameMap['delete'](object);
  var /** @type {number} */ index = this._orderedNames.indexOf(name);
  this._orderedNames.splice(index, 1);
  this._childListCallbacks.runCallbacks(name, null, object);
  weavejs.WeaveAPI.SessionManager.disposeObject(object);
};


/**
 * @inheritDoc
 * @export
 */
weavejs.core.LinkableHashMap.prototype.removeAllObjects = function() {
  this.delayCallbacks();
  for (var foreachiter0 in this._orderedNames.concat()) 
  {
  var name = this._orderedNames.concat()[foreachiter0];
  
    this.removeObject(name);}
  
  this.resumeCallbacks();
};


/**
 * This function removes all objects from this LinkableHashMap.
 * @inheritDoc
 * @export
 * @override
 */
weavejs.core.LinkableHashMap.prototype.dispose = function() {
  weavejs.core.LinkableHashMap.base(this, 'dispose');
  this.removeAllObjects();
  for (var foreachiter1 in this._orderedNames.concat()) 
  {
  var name = this._orderedNames.concat()[foreachiter1];
  {
    this._nameIsLocked[name] = undefined;
    this.removeObject(name);
  }}
  
};


/**
 * @inheritDoc
 * @export
 * @param {string} baseName
 * @return {string}
 */
weavejs.core.LinkableHashMap.prototype.generateUniqueName = function(baseName) {
  var /** @type {number} */ count = 1;
  var /** @type {string} */ name = baseName;
  while (this._previousNameMap[name] != undefined)
    name = baseName + (++count);
  return name;
};


/**
 * @inheritDoc
 * @export
 * @return {Array}
 */
weavejs.core.LinkableHashMap.prototype.getSessionState = function() {
  var /** @type {Array} */ result = new Array(this._orderedNames.length);
  for (var /** @type {number} */ i = 0; i < this._orderedNames.length; i++) {
    var /** @type {string} */ name = this._orderedNames[i];
    var /** @type {weavejs.api.core.ILinkableObject} */ object = this._nameToObjectMap[name];
    result[i] = weavejs.api.core.DynamicState.create(name, weavejs.Weave.className(object), weavejs.WeaveAPI.SessionManager.getSessionState(object));
  }
  return result;
};


/**
 * @inheritDoc
 * @export
 * @param {Array} newStateArray
 * @param {boolean} removeMissingDynamicObjects
 */
weavejs.core.LinkableHashMap.prototype.setSessionState = function(newStateArray, removeMissingDynamicObjects) {
  if (newStateArray == null)
    return;
  this.delayCallbacks();
  var /** @type {number} */ i;
  var /** @type {Array} */ delayed = [];
  var /** @type {weavejs.api.core.ICallbackCollection} */ callbacks;
  var /** @type {string} */ objectName;
  var /** @type {string} */ className;
  var /** @type {Object} */ typedState;
  var /** @type {Object} */ remainingObjects = removeMissingDynamicObjects ? {} : null;
  var /** @type {Object} */ newObjects = {};
  var /** @type {Array} */ newNameOrder = [];
  if (newStateArray != null) {
    for (var foreachiter2 in this._orderedNames) 
    {
    objectName = this._orderedNames[foreachiter2];
    {
      callbacks = weavejs.WeaveAPI.SessionManager.getCallbackCollection(this._nameToObjectMap[objectName]);
      delayed.push(callbacks);
      callbacks.delayCallbacks();
    }}
    
    for (i = 0; i < newStateArray.length; i++) {
      typedState = newStateArray[i];
      if (!weavejs.api.core.DynamicState.isDynamicState(typedState, true))
        continue;
      objectName = typedState[weavejs.api.core.DynamicState.OBJECT_NAME];
      className = typedState[weavejs.api.core.DynamicState.CLASS_NAME];
      if (objectName == null)
        continue;
      if (className == null)
        continue;
      if (this._nameToObjectMap[objectName] != this.initObjectByClassName(objectName, className))
        newObjects[objectName] = true;
    }
    for (var foreachiter3 in this._orderedNames) 
    {
    objectName = this._orderedNames[foreachiter3];
    {
      callbacks = weavejs.WeaveAPI.SessionManager.getCallbackCollection(this._nameToObjectMap[objectName]);
      delayed.push(callbacks);
      callbacks.delayCallbacks();
    }}
    
    for (i = 0; i < newStateArray.length; i++) {
      typedState = newStateArray[i];
      if (typeof(typedState) === 'string') {
        objectName = String(typedState);
        if (removeMissingDynamicObjects)
          remainingObjects[objectName] = true;
        newNameOrder.push(objectName);
        continue;
      }
      if (!weavejs.api.core.DynamicState.isDynamicState(typedState, true))
        continue;
      objectName = typedState[weavejs.api.core.DynamicState.OBJECT_NAME];
      if (objectName == null)
        continue;
      var /** @type {weavejs.api.core.ILinkableObject} */ object = this._nameToObjectMap[objectName];
      if (object == null)
        continue;
      weavejs.WeaveAPI.SessionManager.setSessionState(object, typedState[weavejs.api.core.DynamicState.SESSION_STATE], newObjects[objectName] || removeMissingDynamicObjects);
      if (removeMissingDynamicObjects)
        remainingObjects[objectName] = true;
      newNameOrder.push(objectName);
    }
  }
  if (removeMissingDynamicObjects) {
    for (var foreachiter4 in this._orderedNames.concat()) 
    {
    objectName = this._orderedNames.concat()[foreachiter4];
    {
      if (remainingObjects[objectName] !== true) {
        this.removeObject(objectName);
      }
    }}
    
  }
  this.setNameOrder(newNameOrder);
  for (var foreachiter5 in delayed) 
  {
  callbacks = delayed[foreachiter5];
  
    if (!weavejs.WeaveAPI.SessionManager.objectWasDisposed(callbacks))
      callbacks.resumeCallbacks();}
  
  this.resumeCallbacks();
};


Object.defineProperties(weavejs.core.LinkableHashMap.prototype, /** @lends {weavejs.core.LinkableHashMap.prototype} */ {
/** @export */
typeRestriction: {
get: /** @this {weavejs.core.LinkableHashMap} */ function() {
  return this._typeRestriction;
}},
/** @export */
childListCallbacks: {
get: /** @this {weavejs.core.LinkableHashMap} */ function() {
  return this._childListCallbacks;
}}}
);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
weavejs.core.LinkableHashMap.prototype.FLEXJS_CLASS_INFO = { names: [{ name: 'LinkableHashMap', qName: 'weavejs.core.LinkableHashMap'}], interfaces: [weavejs.api.core.ILinkableHashMap] };
