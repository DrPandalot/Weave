/**
 * Generated by Apache Flex Cross-Compiler from weavejs\core\SessionStateLog.as
 * weavejs.core.SessionStateLog
 *
 * @fileoverview
 *
 * @suppress {checkTypes}
 */

goog.provide('weavejs.core.SessionStateLog');

goog.require('weavejs.Weave');
goog.require('weavejs.WeaveAPI');
goog.require('weavejs.compiler.StandardLib');
goog.require('weavejs.core.LinkableBoolean');
goog.require('weavejs.core.LogEntry');
goog.require('weavejs.api.core.ICallbackCollection');
goog.require('weavejs.api.core.IDisposableObject');
goog.require('weavejs.api.core.ILinkableObject');
goog.require('weavejs.api.core.ILinkableVariable');



/**
 * @constructor
 * @implements {weavejs.api.core.ILinkableVariable}
 * @implements {weavejs.api.core.IDisposableObject}
 * @param {weavejs.api.core.ILinkableObject} subject
 * @param {number=} syncDelay
 */
weavejs.core.SessionStateLog = function(subject, syncDelay) {
  syncDelay = typeof syncDelay !== 'undefined' ? syncDelay : 0;
  weavejs.Weave.bindAll(this);
  this.enableLogging = weavejs.WeaveAPI.SessionManager.registerLinkableChild(this, new weavejs.core.LinkableBoolean(true), org.apache.flex.utils.Language.closure(this.synchronizeNow, this, 'synchronizeNow'));
  this._syncTime = weavejs.Weave.getTimer();
  this._undoHistory = [];
  this._redoHistory = [];
  this._subject = subject;
  this._syncDelay = syncDelay;
  this._prevState = weavejs.WeaveAPI.SessionManager.getSessionState(this._subject);
  weavejs.WeaveAPI.SessionManager.registerDisposableChild(this._subject, this);
  var /** @type {weavejs.api.core.ICallbackCollection} */ cc = weavejs.WeaveAPI.SessionManager.getCallbackCollection(this._subject);
  cc.addImmediateCallback(this, org.apache.flex.utils.Language.closure(this.immediateCallback, this, 'immediateCallback'));
  cc.addGroupedCallback(this, org.apache.flex.utils.Language.closure(this.groupedCallback, this, 'groupedCallback'));
};


/**
 * @export
 * @type {boolean}
 */
weavejs.core.SessionStateLog.debug = false;


/**
 * @export
 * @type {boolean}
 */
weavejs.core.SessionStateLog.enableHistoryRewrite = true;


/**
 * @inheritDoc
 * @export
 */
weavejs.core.SessionStateLog.prototype.dispose = function() {
  if (this._undoHistory == null)
    throw new Error("SessionStateLog.dispose() called more than once");
  this._subject = null;
  this._undoHistory = null;
  this._redoHistory = null;
};


/**
 * @private
 * @type {weavejs.api.core.ILinkableObject}
 */
weavejs.core.SessionStateLog.prototype._subject;


/**
 * @private
 * @type {number}
 */
weavejs.core.SessionStateLog.prototype._syncDelay;


/**
 * @private
 * @type {Object}
 */
weavejs.core.SessionStateLog.prototype._prevState = null;


/**
 * @private
 * @type {Array}
 */
weavejs.core.SessionStateLog.prototype._undoHistory;


/**
 * @private
 * @type {Array}
 */
weavejs.core.SessionStateLog.prototype._redoHistory;


/**
 * @private
 * @type {number}
 */
weavejs.core.SessionStateLog.prototype._nextId = 0;


/**
 * @private
 * @type {boolean}
 */
weavejs.core.SessionStateLog.prototype._undoActive = false;


/**
 * @private
 * @type {boolean}
 */
weavejs.core.SessionStateLog.prototype._redoActive = false;


/**
 * @private
 * @type {number}
 */
weavejs.core.SessionStateLog.prototype._syncTime;


/**
 * @private
 * @type {number}
 */
weavejs.core.SessionStateLog.prototype._triggerDelay = -1;


/**
 * @private
 * @type {number}
 */
weavejs.core.SessionStateLog.prototype._saveTime = 0;


/**
 * @private
 * @type {boolean}
 */
weavejs.core.SessionStateLog.prototype._savePending = false;


/**
 * @export
 * @type {weavejs.core.LinkableBoolean}
 */
weavejs.core.SessionStateLog.prototype.enableLogging;


/**
 * This will squash a sequence of undos or redos into a single undo or redo.
 * @asparam directionalSquashCount Number of undos (negative) or redos (positive) to squash.
 * @export
 * @param {number} directionalSquashCount
 */
weavejs.core.SessionStateLog.prototype.squashHistory = function(directionalSquashCount) {
  var /** @type {weavejs.api.core.ICallbackCollection} */ cc = weavejs.WeaveAPI.SessionManager.getCallbackCollection(this);
  cc.delayCallbacks();
  this.synchronizeNow();
  var /** @type {number} */ count = weavejs.compiler.StandardLib.constrain(directionalSquashCount, -this._undoHistory.length, this._redoHistory.length);
  if (count < -1 || count > 1) {
    cc.triggerCallbacks();
    var /** @type {Array} */ entries;
    if (count < 0)
      entries = this._undoHistory.splice(this._undoHistory.length + count, -count);
    else
      entries = this._redoHistory.splice(0, count);
    var /** @type {weavejs.core.LogEntry} */ entry;
    var /** @type {Object} */ squashBackward = null;
    var /** @type {Object} */ squashForward = null;
    var /** @type {number} */ totalDuration = 0;
    var /** @type {number} */ totalDelay = 0;
    var /** @type {number} */ last = entries.length - 1;
    for (var /** @type {number} */ i = 0; i <= last; i++) {
      entry = org.apache.flex.utils.Language.as(entries[last - i], weavejs.core.LogEntry);
      squashBackward = weavejs.WeaveAPI.SessionManager.combineDiff(squashBackward, entry.backward);
      entry = org.apache.flex.utils.Language.as(entries[i], weavejs.core.LogEntry);
      squashForward = weavejs.WeaveAPI.SessionManager.combineDiff(squashForward, entry.forward);
      totalDuration += entry.diffDuration;
      totalDelay += entry.triggerDelay;
    }
    entry = new weavejs.core.LogEntry(this._nextId++, squashForward, squashBackward, totalDelay, totalDuration);
    if (count < 0)
      this._undoHistory.push(entry);
    else
      this._redoHistory.unshift(entry);
  }
  cc.resumeCallbacks();
};


/**
 * This will clear all undo and redo history.
 * @asparam directional Zero will clear everything. Set this to -1 to clear all undos or 1 to clear all redos.
 * @export
 * @param {number=} directional
 */
weavejs.core.SessionStateLog.prototype.clearHistory = function(directional) {
  directional = typeof directional !== 'undefined' ? directional : 0;
  var /** @type {weavejs.api.core.ICallbackCollection} */ cc = weavejs.WeaveAPI.SessionManager.getCallbackCollection(this);
  cc.delayCallbacks();
  this.synchronizeNow();
  if (directional <= 0) {
    if (this._undoHistory.length > 0)
      cc.triggerCallbacks();
    this._undoHistory.length = 0;
  }
  if (directional >= 0) {
    if (this._redoHistory.length > 0)
      cc.triggerCallbacks();
    this._redoHistory.length = 0;
  }
  cc.resumeCallbacks();
};


/**
 * This gets called as an immediate callback of the subject.
 * @private
 */
weavejs.core.SessionStateLog.prototype.immediateCallback = function() {
  if (!this.enableLogging.value)
    return;
  this._saveTime = Number.MAX_VALUE;
  if (!this._savePending) {
    this._savePending = true;
    this.saveDiff();
  }
  if (weavejs.core.SessionStateLog.debug && (this._undoActive || this._redoActive)) {
    var /** @type {Object} */ state = weavejs.WeaveAPI.SessionManager.getSessionState(this._subject);
    var /** @type {*} */ forwardDiff = weavejs.WeaveAPI.SessionManager.computeDiff(this._prevState, state);
    weavejs.Weave.log('immediate diff:', forwardDiff);
  }
};


/**
 * This gets called as a grouped callback of the subject.
 * @private
 */
weavejs.core.SessionStateLog.prototype.groupedCallback = function() {
  if (!this.enableLogging.value)
    return;
  this.immediateCallback();
  this._saveTime = weavejs.Weave.getTimer() + this._syncDelay;
  if (weavejs.core.SessionStateLog.debug && (this._undoActive || this._redoActive)) {
    var /** @type {Object} */ state = weavejs.WeaveAPI.SessionManager.getSessionState(this._subject);
    var /** @type {*} */ forwardDiff = weavejs.WeaveAPI.SessionManager.computeDiff(this._prevState, state);
    weavejs.Weave.log('grouped diff:', forwardDiff);
  }
};


/**
 * This will save a diff in the history, if there is any.
 * @asparam immediately Set to true if it should be saved immediately, or false if it can wait.
 * @private
 * @param {boolean=} immediately
 */
weavejs.core.SessionStateLog.prototype.saveDiff = function(immediately) {
  immediately = typeof immediately !== 'undefined' ? immediately : false;
  if (!this.enableLogging.value) {
    this._savePending = false;
    return;
  }
  var /** @type {number} */ currentTime = weavejs.Weave.getTimer();
  if (this._triggerDelay < 0)
    this._triggerDelay = currentTime - this._syncTime;
  if (!immediately && weavejs.Weave.getTimer() < this._saveTime) {
    weavejs.Weave.callLater(this, org.apache.flex.utils.Language.closure(this.saveDiff, this, 'saveDiff'));
    return;
  }
  var /** @type {weavejs.api.core.ICallbackCollection} */ cc = weavejs.WeaveAPI.SessionManager.getCallbackCollection(this);
  cc.delayCallbacks();
  var /** @type {Object} */ state = weavejs.WeaveAPI.SessionManager.getSessionState(this._subject);
  var /** @type {*} */ forwardDiff = weavejs.WeaveAPI.SessionManager.computeDiff(this._prevState, state);
  if (forwardDiff !== undefined) {
    var /** @type {number} */ diffDuration = currentTime - (this._syncTime + this._triggerDelay);
    var /** @type {*} */ backwardDiff = weavejs.WeaveAPI.SessionManager.computeDiff(state, this._prevState);
    var /** @type {weavejs.core.LogEntry} */ oldEntry;
    var /** @type {weavejs.core.LogEntry} */ newEntry;
    if (this._undoActive) {
      oldEntry = org.apache.flex.utils.Language.as(this._redoHistory[0], weavejs.core.LogEntry);
      newEntry = new weavejs.core.LogEntry(this._nextId++, backwardDiff, forwardDiff, oldEntry.triggerDelay, oldEntry.diffDuration);
      if (weavejs.core.SessionStateLog.enableHistoryRewrite) {
        this._redoHistory[0] = newEntry;
      } else if (weavejs.compiler.StandardLib.compare(oldEntry.forward, newEntry.forward) != 0) {
        this._redoHistory.unshift(newEntry);
      }
    } else {
      newEntry = new weavejs.core.LogEntry(this._nextId++, forwardDiff, backwardDiff, this._triggerDelay, diffDuration);
      if (this._redoActive) {
        oldEntry = org.apache.flex.utils.Language.as(this._undoHistory.pop(), weavejs.core.LogEntry);
        newEntry.triggerDelay = oldEntry.triggerDelay;
        newEntry.diffDuration = oldEntry.diffDuration;
        if (!weavejs.core.SessionStateLog.enableHistoryRewrite && weavejs.compiler.StandardLib.compare(oldEntry.forward, newEntry.forward) == 0)
          newEntry = oldEntry;
      }
      this._undoHistory.push(newEntry);
    }
    if (weavejs.core.SessionStateLog.debug)
      this.debugHistory(newEntry);
    this._syncTime = currentTime;
    cc.triggerCallbacks();
  }
  if (this._undoActive || this._redoActive)
    this._syncTime = currentTime;
  this._prevState = state;
  this._undoActive = false;
  this._redoActive = false;
  this._savePending = false;
  this._triggerDelay = -1;
  cc.resumeCallbacks();
};


/**
 * This function will save any pending diff in session state.
 * Use this function only when necessary (for example, when writing a collaboration service that must synchronize).
 * @export
 */
weavejs.core.SessionStateLog.prototype.synchronizeNow = function() {
  this.saveDiff(true);
};


/**
 * This will undo a number of steps from the saved history.
 * @asparam numberOfSteps The number of steps to undo.
 * @export
 * @param {number=} numberOfSteps
 */
weavejs.core.SessionStateLog.prototype.undo = function(numberOfSteps) {
  numberOfSteps = typeof numberOfSteps !== 'undefined' ? numberOfSteps : 1;
  this.applyDiffs(-numberOfSteps);
};


/**
 * This will redo a number of steps that have been previously undone.
 * @asparam numberOfSteps The number of steps to redo.
 * @export
 * @param {number=} numberOfSteps
 */
weavejs.core.SessionStateLog.prototype.redo = function(numberOfSteps) {
  numberOfSteps = typeof numberOfSteps !== 'undefined' ? numberOfSteps : 1;
  this.applyDiffs(numberOfSteps);
};


/**
 * This will apply a number of undo or redo steps.
 * @asparam delta The number of steps to undo (negative) or redo (positive).
 * @private
 * @param {number} delta
 */
weavejs.core.SessionStateLog.prototype.applyDiffs = function(delta) {
  var /** @type {number} */ stepsRemaining = Math.min(Math.abs(delta), delta < 0 ? this._undoHistory.length : this._redoHistory.length);
  if (stepsRemaining > 0) {
    var /** @type {weavejs.core.LogEntry} */ logEntry;
    var /** @type {Object} */ diff;
    var /** @type {boolean} */ debug = debug && stepsRemaining == 1;
    if (this._savePending && !this._undoActive && !this._redoActive)
      this.synchronizeNow();
    var /** @type {boolean} */ combine = stepsRemaining > 2;
    var /** @type {Object} */ baseDiff = null;
    weavejs.WeaveAPI.SessionManager.getCallbackCollection(this._subject).delayCallbacks();
    if (!this.enableLogging.value) {
      var /** @type {Object} */ state = weavejs.WeaveAPI.SessionManager.getSessionState(this._subject);
      baseDiff = weavejs.WeaveAPI.SessionManager.computeDiff(state, this._prevState);
      if (baseDiff != null)
        combine = true;
    }
    while (stepsRemaining-- > 0) {
      if (delta < 0) {
        logEntry = this._undoHistory.pop();
        this._redoHistory.unshift(logEntry);
        diff = logEntry.backward;
      } else {
        logEntry = this._redoHistory.shift();
        this._undoHistory.push(logEntry);
        diff = logEntry.forward;
      }
      if (debug)
        weavejs.Weave.log('apply ' + delta < 0 ? 'undo' : 'redo', logEntry.id + ':', diff);
      if (stepsRemaining == 0 && this.enableLogging.value) {
        this._prevState = weavejs.WeaveAPI.SessionManager.getSessionState(this._subject);
      }
      if (combine) {
        baseDiff = weavejs.WeaveAPI.SessionManager.combineDiff(baseDiff, diff);
        if (stepsRemaining <= 1) {
          weavejs.WeaveAPI.SessionManager.setSessionState(this._subject, baseDiff, false);
          combine = false;
        }
      } else {
        weavejs.WeaveAPI.SessionManager.setSessionState(this._subject, diff, false);
      }
      if (debug) {
        var /** @type {Object} */ newState = weavejs.WeaveAPI.SessionManager.getSessionState(this._subject);
        var /** @type {Object} */ resultDiff = weavejs.WeaveAPI.SessionManager.computeDiff(this._prevState, newState);
        weavejs.Weave.log('resulting diff:', resultDiff);
      }
    }
    weavejs.WeaveAPI.SessionManager.getCallbackCollection(this._subject).resumeCallbacks();
    this._undoActive = delta < 0 && this._savePending;
    this._redoActive = delta > 0 && this._savePending;
    if (!this._savePending)
      this._prevState = weavejs.WeaveAPI.SessionManager.getSessionState(this._subject);
    weavejs.WeaveAPI.SessionManager.getCallbackCollection(this).triggerCallbacks();
  }
};


/**
 * @private
 * @param {weavejs.core.LogEntry} logEntry
 */
weavejs.core.SessionStateLog.prototype.debugHistory = function(logEntry) {
  var /** @type {Array} */ h = this._undoHistory.concat();
  for (var /** @type {number} */ i = 0; i < h.length; i++)
    h[i] = h[i].id;
  var /** @type {Array} */ f = this._redoHistory.concat();
  for (i = 0; i < f.length; i++)
    f[i] = f[i].id;
  if (logEntry) {
    weavejs.Weave.log("<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<");
    weavejs.Weave.log('NEW HISTORY (backward) ' + logEntry.id + ':', logEntry.backward);
    weavejs.Weave.log("===============================================================");
    weavejs.Weave.log('NEW HISTORY (forward) ' + logEntry.id + ':', logEntry.forward);
    weavejs.Weave.log(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
  }
  org.apache.flex.utils.Language.trace('undo [' + h + ']', 'redo [' + f + ']');
};


/**
 * This will generate an untyped session state object that contains the session history log.
 * @asreturn An object containing the session history log.
 * @export
 * @return {Object}
 */
weavejs.core.SessionStateLog.prototype.getSessionState = function() {
  var /** @type {weavejs.api.core.ICallbackCollection} */ cc = weavejs.WeaveAPI.SessionManager.getCallbackCollection(this);
  cc.delayCallbacks();
  this.synchronizeNow();
  var /** @type {Object} */ state = {"version":0, "currentState":this._prevState, "undoHistory":this._undoHistory.concat(), "redoHistory":this._redoHistory.concat(), "nextId":this._nextId};
  cc.resumeCallbacks();
  return state;
};


/**
 * This will load a session state log from an untyped session state object.
 * @asparam input The ByteArray containing the output from seralize().
 * @export
 * @param {Object} state
 */
weavejs.core.SessionStateLog.prototype.setSessionState = function(state) {
  var /** @type {weavejs.api.core.ICallbackCollection} */ cc = weavejs.WeaveAPI.SessionManager.getCallbackCollection(this);
  cc.delayCallbacks();
  this.enableLogging.delayCallbacks();
  try {
    var /** @type {number} */ version = state.version;
    switch (version) {
      case 0:
        this._prevState = state.currentState;
        this._undoHistory = weavejs.core.LogEntry.convertGenericObjectsToLogEntries(state.undoHistory, this._syncDelay);
        this._redoHistory = weavejs.core.LogEntry.convertGenericObjectsToLogEntries(state.redoHistory, this._syncDelay);
        this._nextId = state.nextId;
        break;
      default:
        throw new Error("Weave history format version " + version + " is unsupported.");
    }
    this._undoActive = false;
    this._redoActive = false;
    this._savePending = false;
    this._saveTime = 0;
    this._triggerDelay = -1;
    this._syncTime = weavejs.Weave.getTimer();
    weavejs.WeaveAPI.SessionManager.setSessionState(this._subject, this._prevState);
  } finally {
    this.enableLogging.resumeCallbacks();
    cc.triggerCallbacks();
    cc.resumeCallbacks();
  }
};


Object.defineProperties(weavejs.core.SessionStateLog.prototype, /** @lends {weavejs.core.SessionStateLog.prototype} */ {
/** @export */
undoHistory: {
get: /** @this {weavejs.core.SessionStateLog} */ function() {
  return this._undoHistory;
}},
/** @export */
redoHistory: {
get: /** @this {weavejs.core.SessionStateLog} */ function() {
  return this._redoHistory;
}}}
);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
weavejs.core.SessionStateLog.prototype.FLEXJS_CLASS_INFO = { names: [{ name: 'SessionStateLog', qName: 'weavejs.core.SessionStateLog'}], interfaces: [weavejs.api.core.ILinkableVariable, weavejs.api.core.IDisposableObject] };
