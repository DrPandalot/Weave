/**
 * Generated by Apache Flex Cross-Compiler from weavejs\compiler\StandardLib.as
 * weavejs.compiler.StandardLib
 *
 * @fileoverview
 *
 * @suppress {checkTypes}
 */

goog.provide('weavejs.compiler.StandardLib');

goog.require('weavejs.Weave');



/**
 * @constructor
 */
weavejs.compiler.StandardLib = function() {
};


/**
 * This function will cast a value of any type to a Number,
 * interpreting the empty string ("") and null as NaN.
 * @asparam value A value to cast to a Number.
 * @asreturn The value cast to a Number, or NaN if the casting failed.
 * @export
 * @param {*} value
 * @return {number}
 */
weavejs.compiler.StandardLib.asNumber = function(value) {
  if (value == null)
    return NaN;
  if (org.apache.flex.utils.Language.is(value, Number) || org.apache.flex.utils.Language.is(value, Date))
    return value;
  try {
    value = String(value);
    if (value == '')
      return NaN;
    return Number(value);
  } catch (e) {
  }
  return NaN;
};


/**
 * Converts a value to a non-null String
 * @asparam value A value to cast to a String.
 * @asreturn The value cast to a String.
 * @export
 * @param {*} value
 * @return {string}
 */
weavejs.compiler.StandardLib.asString = function(value) {
  if (value == null)
    return '';
  return String(value);
};


/**
 * This function attempts to derive a boolean value from different types of objects.
 * @asparam value An object to parse as a Boolean.
 * @export
 * @param {*} value
 * @return {boolean}
 */
weavejs.compiler.StandardLib.asBoolean = function(value) {
  if (org.apache.flex.utils.Language.is(value, Boolean))
    return value;
  if (org.apache.flex.utils.Language.is(value, String))
    return weavejs.compiler.StandardLib.stringCompare(value, "true", true) == 0;
  if (isNaN(value))
    return false;
  if (org.apache.flex.utils.Language.is(value, Number))
    return value != 0;
  return value;
};


/**
 * Tests if a value is anything other than undefined, null, or NaN.
 * @export
 * @param {*} value
 * @return {boolean}
 */
weavejs.compiler.StandardLib.isDefined = function(value) {
  return value !== undefined && value !== null && !(org.apache.flex.utils.Language.is(value, Number) && isNaN(value));
};


/**
 * Tests if a value is undefined, null, or NaN.
 * @export
 * @param {*} value
 * @return {boolean}
 */
weavejs.compiler.StandardLib.isUndefined = function(value) {
  return value === undefined || value === null || (org.apache.flex.utils.Language.is(value, Number) && isNaN(value));
};


/**
 * Pads a string on the left.
 * @export
 * @param {string} str
 * @param {number} length
 * @param {string=} padString
 * @return {string}
 */
weavejs.compiler.StandardLib.lpad = function(str, length, padString) {
  padString = typeof padString !== 'undefined' ? padString : ' ';
  if (str.length >= length)
    return str;
  while (str.length + padString.length < length)
    padString += padString;
  return padString.substr(0, length - str.length) + str;
};


/**
 * Pads a string on the right.
 * @export
 * @param {string} str
 * @param {number} length
 * @param {string=} padString
 * @return {string}
 */
weavejs.compiler.StandardLib.rpad = function(str, length, padString) {
  padString = typeof padString !== 'undefined' ? padString : ' ';
  if (str.length >= length)
    return str;
  while (str.length + padString.length < length)
    padString += padString;
  return str + padString.substr(0, length - str.length);
};


/**
 * This function performs find and replace operations on a String.
 * @asparam string A String to perform replacements on.
 * @asparam findStr A String to find.
 * @asparam replaceStr A String to replace occurrances of the 'findStr' String with.
 * @asparam moreFindAndReplace A list of additional find,replace parameters to use.
 * @asreturn The String with all the specified replacements performed.
 * @export
 * @param {string} string
 * @param {string} findStr
 * @param {string} replaceStr
 * @param {...} moreFindAndReplace
 * @return {string}
 */
weavejs.compiler.StandardLib.replace = function(string, findStr, replaceStr, moreFindAndReplace) {
  moreFindAndReplace = Array.prototype.slice.call(arguments, 3);
  string = string.split(findStr).join(replaceStr);
  while (moreFindAndReplace.length > 1) {
    findStr = moreFindAndReplace.shift();
    replaceStr = moreFindAndReplace.shift();
    string = string.split(findStr).join(replaceStr);
  }
  return string;
};


/**
 * @private
 * @const
 * @type {RegExp}
 */
weavejs.compiler.StandardLib.argRef = new RegExp("^(0|[1-9][0-9]*)}");


/**
 * Substitutes "{n}" tokens within the specified string with the respective arguments passed in.
 * Same syntax as StringUtil.substitute() without the side-effects of using String.replace() with a regex.
 * @see String#replace()
 * @see mx.utils.StringUtil#substitute()
 * @export
 * @param {string} format
 * @param {...} args
 * @return {string}
 */
weavejs.compiler.StandardLib.substitute = function(format, args) {
  args = Array.prototype.slice.call(arguments, 1);
  if (args.length == 1 && org.apache.flex.utils.Language.is(args[0], Array))
    args = weavejs.Weave.toArray(args[0]);
  var /** @type {Array} */ split = format.split('{');
  var /** @type {string} */ output = split[0];
  for (var /** @type {number} */ i = 1; i < split.length; i++) {
    var /** @type {string} */ str = org.apache.flex.utils.Language.as(split[i], String);
    if (weavejs.compiler.StandardLib.argRef.test(str)) {
      var /** @type {number} */ j = str.indexOf("}");
      output += args[str.substring(0, j)];
      output += str.substring(j + 1);
    }
    else
      output += "{" + str;
  }
  return output;
};


/**
 * Takes a script where all lines have been indented with tabs,
 * removes the common indentation from all lines and optionally
 * replaces extra leading tabs with a number of spaces.
 * @asparam script A script.
 * @asparam spacesPerTab If zero or greater, this is the number of spaces to be used in place of each tab character used as indentation.
 * @asreturn The modified script.
 * @export
 * @param {string} script
 * @param {number=} spacesPerTab
 * @return {string}
 */
weavejs.compiler.StandardLib.unIndent = function(script, spacesPerTab) {
  spacesPerTab = typeof spacesPerTab !== 'undefined' ? spacesPerTab : -1;
  if (script == null)
    return null;
  script = weavejs.compiler.StandardLib.replace(script, '\r\n', '\n', '\r', '\n');
  script = weavejs.compiler.StandardLib.trim('.' + script).substr(1);
  var /** @type {Array} */ lines = script.split('\n');
  while (lines.length && !weavejs.compiler.StandardLib.trim(lines[0]))
    lines.shift();
  if (!lines.length) {
    return '';
  }
  var /** @type {number} */ commonIndent = Number.MAX_VALUE;
  var /** @type {string} */ line;
  for (var foreachiter0 in lines) 
  {
  line = lines[foreachiter0];
  {
    if (!weavejs.compiler.StandardLib.trim(line))
      continue;
    var /** @type {number} */ lineIndent = 0;
    while (line.charAt(lineIndent) == '\t')
      lineIndent++;
    commonIndent = Math.min(commonIndent, lineIndent);
  }}
  
  for (var /** @type {number} */ i = 0; i < lines.length; i++) {
    line = lines[i];
    var /** @type {number} */ t = 0;
    while (t < commonIndent && line.charAt(t) == '\t')
      t++;
    var /** @type {string} */ spaces = '';
    if (spacesPerTab >= 0) {
      while (line.charAt(t) == '\t') {
        spaces += weavejs.compiler.StandardLib.lpad('', spacesPerTab, '        ');
        t++;
      }
    }
    lines[i] = spaces + line.substr(t);
  }
  return lines.join('\n');
};


/**
 * @see mx.utils.StringUtil#trim()
 * @export
 * @param {string} str
 * @return {string}
 */
weavejs.compiler.StandardLib.trim = function(str) {
  if (str == null)
    return '';
  var /** @type {number} */ startIndex = 0;
  while (weavejs.compiler.StandardLib.isWhitespace(str.charAt(startIndex)))
    ++startIndex;
  var /** @type {number} */ endIndex = str.length - 1;
  while (weavejs.compiler.StandardLib.isWhitespace(str.charAt(endIndex)))
    --endIndex;
  if (endIndex >= startIndex)
    return str.slice(startIndex, endIndex + 1);
  else
    return "";
};


/**
 * @see mx.utils.StringUtil#isWhitespace()
 * @export
 * @param {string} character
 * @return {boolean}
 */
weavejs.compiler.StandardLib.isWhitespace = function(character) {
  switch (character) {
    case " ":
    
    case "\t":
    
    case "\r":
    
    case "\n":
    
    case "\f":
    
    case " ":
    
    case "?":
    
    case "?":
    
    case "?":
      return true;
    default:
      return false;
  }
};


/**
 * Converts a number to a String using a specific numeric base and optionally pads with leading zeros.
 * @asparam number The Number to convert to a String.
 * @asparam base Specifies the numeric base (from 2 to 36) to use.
 * @asparam zeroPad This is the minimum number of digits to return.  The number will be padded with zeros if necessary.
 * @asreturn The String representation of the number using the specified numeric base.
 * @export
 * @param {number} number
 * @param {number=} base
 * @param {number=} zeroPad
 * @return {string}
 */
weavejs.compiler.StandardLib.numberToBase = function(number, base, zeroPad) {
  base = typeof base !== 'undefined' ? base : 10;
  zeroPad = typeof zeroPad !== 'undefined' ? zeroPad : 1;
  var /** @type {Array} */ parts = Math.abs(number).toString(base).split('.');
  if (parts[0].length < zeroPad)
    parts[0] = weavejs.compiler.StandardLib.lpad(parts[0], zeroPad, '0');
  if (number < 0)
    parts[0] = '-' + parts[0];
  return parts.join('.');
};


/**
 * This function returns -1 if the given value is negative, and 1 otherwise.
 * @asparam value A value to test.
 * @asreturn -1 if value &lt; 0, 1 otherwise
 * @export
 * @param {number} value
 * @return {number}
 */
weavejs.compiler.StandardLib.sign = function(value) {
  if (value < 0)
    return -1;
  return 1;
};


/**
 * This function constrains a number between min and max values.
 * @asparam value A value to constrain between a min and max.
 * @asparam min The minimum value.
 * @asparam max The maximum value.
 * @asreturn If value &lt; min, returns min.  If value &gt; max, returns max.  Otherwise, returns value.
 * @export
 * @param {number} value
 * @param {number} min
 * @param {number} max
 * @return {number}
 */
weavejs.compiler.StandardLib.constrain = function(value, min, max) {
  if (value < min)
    return min;
  if (value > max)
    return max;
  return value;
};


/**
 * Scales a number between 0 and 1 using specified min and max values.
 * @asparam value The value between min and max.
 * @asparam min The minimum value that corresponds to a result of 0.
 * @asparam max The maximum value that corresponds to a result of 1.
 * @asreturn The normalized value between 0 and 1, or NaN if value is out of range.
 * @export
 * @param {number} value
 * @param {number} min
 * @param {number} max
 * @return {number}
 */
weavejs.compiler.StandardLib.normalize = function(value, min, max) {
  if (value < min || value > max)
    return NaN;
  if (min == max)
    return value - min;
  return (value - min) / (max - min);
};


/**
 * This function performs a linear scaling of a value from an input min,max range to an output min,max range.
 * @asparam inputValue A value to scale.
 * @asparam inputMin The minimum value in the input range.
 * @asparam inputMax The maximum value in the input range.
 * @asparam outputMin The minimum value in the output range.
 * @asparam outputMax The maximum value in the output range.
 * @asreturn The input value rescaled such that a value equal to inputMin is scaled to outputMin and a value equal to inputMax is scaled to outputMax.
 * @export
 * @param {number} inputValue
 * @param {number} inputMin
 * @param {number} inputMax
 * @param {number} outputMin
 * @param {number} outputMax
 * @return {number}
 */
weavejs.compiler.StandardLib.scale = function(inputValue, inputMin, inputMax, outputMin, outputMax) {
  if (inputMin == inputMax) {
    if (isNaN(inputValue))
      return NaN;
    if (inputValue > inputMax)
      return outputMax;
    return outputMin;
  }
  return outputMin + (outputMax - outputMin) * (inputValue - inputMin) / (inputMax - inputMin);
};


/**
 * This rounds a Number to a given number of significant digits.
 * @asparam value A value to round.
 * @asparam significantDigits The desired number of significant digits in the result.
 * @asreturn The number, rounded to the specified number of significant digits.
 * @export
 * @param {number} value
 * @param {number=} significantDigits
 * @return {number}
 */
weavejs.compiler.StandardLib.roundSignificant = function(value, significantDigits) {
  significantDigits = typeof significantDigits !== 'undefined' ? significantDigits : 14;
  if (!isFinite(value))
    return value;
  var /** @type {number} */ sign = (value < 0) ? -1 : 1;
  var /** @type {number} */ absValue = Math.abs(value);
  var /** @type {number} */ pow10;
  if (absValue < 1) {
    pow10 = Math.pow(10, significantDigits);
    return sign * Math.round(absValue * pow10) / pow10;
  }
  var /** @type {number} */ log10 = Math.ceil(Math.log(absValue) / Math.LN10);
  if (log10 < significantDigits) {
    pow10 = Math.pow(10, significantDigits - log10);
    return sign * Math.round(absValue * pow10) / pow10;
  } else {
    pow10 = Math.pow(10, log10 - significantDigits);
    return sign * Math.round(absValue / pow10) * pow10;
  }
};


/**
 * @private
 */
weavejs.compiler.StandardLib.testRoundSignificant = function() {
  for (var /** @type {number} */ pow = -5; pow <= 5; pow++) {
    var /** @type {number} */ n = 1234.5678 * Math.pow(10, pow);
    for (var /** @type {number} */ d = 0; d <= 9; d++)
      org.apache.flex.utils.Language.trace('roundSignificant(', n, ',', d, ') =', weavejs.compiler.StandardLib.roundSignificant(n, d));
  }
};


/**
 * Rounds a number to the nearest multiple of a precision value.
 * @asparam number A number to round.
 * @asparam precision A precision to use.
 * @asreturn The number rounded to the nearest multiple of the precision value.
 * @export
 * @param {number} number
 * @param {number} precision
 * @return {number}
 */
weavejs.compiler.StandardLib.roundPrecision = function(number, precision) {
  return Math.round(number / precision) * precision;
};


/**
 * @asparam n The number to round.
 * @asparam d The total number of non-zero digits we care about for small numbers.
 * @export
 * @param {number} n
 * @param {number} d
 * @return {number}
 */
weavejs.compiler.StandardLib.suggestPrecision = function(n, d) {
  return Math.pow(10, Math.min(0, Math.ceil(Math.log(n) / Math.LN10) - d));
};


/**
 * Calculates an interpolated color for a normalized value.
 * @asparam normValue A Number between 0 and 1.
 * @asparam colors An Array or list of colors to interpolate between.  Normalized values of 0 and 1 will be mapped to the first and last colors.
 * @asreturn An interpolated color associated with the given normValue based on the list of color values.
 * @export
 * @param {number} normValue
 * @param {...} colors
 * @return {number}
 */
weavejs.compiler.StandardLib.interpolateColor = function(normValue, colors) {
  colors = Array.prototype.slice.call(arguments, 1);
  if (colors.length == 1 && org.apache.flex.utils.Language.is(colors[0], Array))
    colors = colors[0];
  if (normValue < 0 || normValue > 1 || colors.length == 0)
    return NaN;
  var /** @type {number} */ maxIndex = colors.length - 1;
  var /** @type {number} */ leftIndex = maxIndex * normValue;
  var /** @type {number} */ rightIndex = leftIndex + 1;
  if (rightIndex == colors.length)
    return colors[leftIndex];
  var /** @type {number} */ minColor = colors[leftIndex];
  var /** @type {number} */ maxColor = colors[rightIndex];
  normValue = normValue * maxIndex - leftIndex;
  var /** @type {number} */ percentLeft = 1 - normValue;
  var /** @type {number} */ percentRight = normValue;
  var /** @type {number} */ R = 0xFF0000;
  var /** @type {number} */ G = 0x00FF00;
  var /** @type {number} */ B = 0x0000FF;
  return (((percentLeft * (minColor & R) + percentRight * (maxColor & R)) & R) | ((percentLeft * (minColor & G) + percentRight * (maxColor & G)) & G) | ((percentLeft * (minColor & B) + percentRight * (maxColor & B)) & B));
};


/**
 * ITU-R 601
 * @export
 * @param {number} color
 * @return {number}
 */
weavejs.compiler.StandardLib.getColorLuma = function(color) {
  return 0.3 * ((color & 0xFF0000) >> 16) + 0.59 * ((color & 0x00FF00) >> 8) + 0.11 * (color & 0x0000FF);
};


/**
 * Code from Graphics Gems Volume 1
 * @export
 * @param {number} x
 * @param {boolean} round
 * @return {number}
 */
weavejs.compiler.StandardLib.getNiceNumber = function(x, round) {
  var /** @type {number} */ exponent;
  var /** @type {number} */ fractionalPart;
  var /** @type {number} */ niceFractionalPart;
  if (x == 0)
    return 0;
  exponent = Math.floor(Math.log(x) / Math.LN10);
  fractionalPart = x / Math.pow(10.0, exponent);
  if (round) {
    if (fractionalPart < 1.5) {
      niceFractionalPart = 1.0;
    } else if (fractionalPart < 3.0) {
      niceFractionalPart = 2.0;
    } else if (fractionalPart < 7.0) {
      niceFractionalPart = 5.0;
    } else {
      niceFractionalPart = 10.0;
    }
  } else {
    if (fractionalPart <= 1.0) {
      niceFractionalPart = 1.0;
    } else if (fractionalPart <= 2.0) {
      niceFractionalPart = 2.0;
    } else if (fractionalPart < 5.0) {
      niceFractionalPart = 5.0;
    } else {
      niceFractionalPart = 10.0;
    }
  }
  return niceFractionalPart * Math.pow(10.0, exponent);
};


/**
 * Code from Graphics Gems Volume 1
 * Note: This may return less than the requested number of values
 * @export
 * @param {number} min
 * @param {number} max
 * @param {number} numberOfValuesInRange
 * @return {Array}
 */
weavejs.compiler.StandardLib.getNiceNumbersInRange = function(min, max, numberOfValuesInRange) {
  if (min == max)
    return [min];
  var /** @type {number} */ nfrac;
  var /** @type {number} */ d;
  var /** @type {number} */ graphmin;
  var /** @type {number} */ graphmax;
  var /** @type {number} */ range;
  var /** @type {number} */ x;
  var /** @type {number} */ i = 0;
  var /** @type {Array} */ values = [];
  range = max - min;
  d = weavejs.compiler.StandardLib.getNiceNumber(range / (numberOfValuesInRange - 1), true);
  graphmin = Math.floor(min / d) * d;
  graphmax = Math.ceil(max / d) * d;
  nfrac = Math.max(-Math.floor(Math.log(d) / Math.LN10), 0);
  for (x = graphmin; x < graphmax + 0.5 * d; x += d) {
    values[i++] = weavejs.compiler.StandardLib.roundSignificant(x);
  }
  return values;
};


/**
 * Calculates the mean value from a list of Numbers.
 * @export
 * @param {...} args
 * @return {number}
 */
weavejs.compiler.StandardLib.mean = function(args) {
  args = Array.prototype.slice.call(arguments, 0);
  if (args.length == 1 && org.apache.flex.utils.Language.is(args[0], Array))
    args = args[0];
  var /** @type {number} */ sum = 0;
  for (var foreachiter1 in args) 
  {
  var value = args[foreachiter1];
  
    sum += value;}
  
  return sum / args.length;
};


/**
 * Calculates the sum of a list of Numbers.
 * @export
 * @param {...} args
 * @return {number}
 */
weavejs.compiler.StandardLib.sum = function(args) {
  args = Array.prototype.slice.call(arguments, 0);
  if (args.length == 1 && org.apache.flex.utils.Language.is(args[0], Array))
    args = args[0];
  var /** @type {number} */ sum = 0;
  for (var foreachiter2 in args) 
  {
  var value = args[foreachiter2];
  
    sum += value;}
  
  return sum;
};


/**
 * This will return the type of item found in the Array if each item has the same type.
 * @asparam a An Array to check.
 * @asreturn The type of all items in the Array, or null if the types differ. 
 * @export
 * @param {Array} a
 * @return {Object}
 */
weavejs.compiler.StandardLib.getArrayType = function(a) {
  if (a == null || a.length == 0 || a[0] == null)
    return null;
  var /** @type {Object} */ type = Object(a[0]).constructor;
  for (var foreachiter3 in a) 
  {
  var item = a[foreachiter3];
  
    if (item == null || item.constructor != type)
      return null;}
  
  return type;
};


/**
 * Checks if all items in an Array are instances of a given type.
 * @asparam a An Array of items to test
 * @asparam type A type to check for
 * @asreturn true if each item in the Array is an object of the given type.
 * @export
 * @param {Array} a
 * @param {Object} type
 * @return {boolean}
 */
weavejs.compiler.StandardLib.arrayIsType = function(a, type) {
  for (var foreachiter4 in a) 
  {
  var item = a[foreachiter4];
  
    if (!org.apache.flex.utils.Language.is(item, type))
      return false;}
  
  return true;
};


/**
 * This will perform a log transformation on a normalized value to produce another normalized value.
 * @asparam normValue A number between 0 and 1.
 * @asparam factor The log factor to use.
 * @asreturn A number between 0 and 1.
 * @export
 * @param {number} normValue
 * @param {number=} factor
 * @return {number}
 */
weavejs.compiler.StandardLib.logTransform = function(normValue, factor) {
  factor = typeof factor !== 'undefined' ? factor : 1024;
  return Math.log(1 + normValue * factor) / Math.log(1 + factor);
};


/**
 * @private
 * @const
 * @type {number}
 */
weavejs.compiler.StandardLib._timezoneMultiplier = 60000;


/**
 * This compares two dynamic objects or primitive values and is much faster than ObjectUtil.compare().
 * Does not check for circular refrences.
 * @asparam a First dynamic object or primitive value.
 * @asparam b Second dynamic object or primitive value.
 * @asparam objectCompare An optional compare function to replace the default compare behavior for non-primitive Objects.
 *                      The function should return -1, 0, or 1 to override the comparison result, or NaN to use the default recursive comparison result.
 * @asreturn A value of zero if the two objects are equal, nonzero if not equal.
 * @export
 * @param {Object} a
 * @param {Object} b
 * @param {Function=} objectCompare
 * @return {number}
 */
weavejs.compiler.StandardLib.compare = function(a, b, objectCompare) {
  objectCompare = typeof objectCompare !== 'undefined' ? objectCompare : null;
  var /** @type {number} */ c;
  if (a === b)
    return 0;
  if (a == null)
    return 1;
  if (b == null)
    return -1;
  var /** @type {string} */ typeA = typeof(a);
  var /** @type {string} */ typeB = typeof(b);
  if (typeA != typeB)
    return weavejs.compiler.StandardLib.stringCompare(typeA, typeB);
  if (typeA == 'boolean')
    return weavejs.compiler.StandardLib.numericCompare(Number(a), Number(b));
  if (typeA == 'number')
    return weavejs.compiler.StandardLib.numericCompare(org.apache.flex.utils.Language.as(a, Number), org.apache.flex.utils.Language.as(b, Number));
  if (typeA == 'string')
    return weavejs.compiler.StandardLib.stringCompare(org.apache.flex.utils.Language.as(a, String), org.apache.flex.utils.Language.as(b, String));
  if (typeA != 'object')
    return 1;
  if (org.apache.flex.utils.Language.is(a, Date) && org.apache.flex.utils.Language.is(b, Date))
    return weavejs.compiler.StandardLib.dateCompare(org.apache.flex.utils.Language.as(a, Date), org.apache.flex.utils.Language.as(b, Date));
  if (org.apache.flex.utils.Language.is(a, Array) && org.apache.flex.utils.Language.is(b, Array)) {
    var /** @type {number} */ an = a.length;
    var /** @type {number} */ bn = b.length;
    if (an < bn)
      return -1;
    if (an > bn)
      return 1;
    for (var /** @type {number} */ i = 0; i < an; i++) {
      c = weavejs.compiler.StandardLib.compare(a[i], b[i]);
      if (c != 0)
        return c;
    }
    return 0;
  }
  if (objectCompare != null) {
    var /** @type {number} */ result = objectCompare(a, b);
    if (isFinite(result))
      return result;
  }
  var /** @type {string} */ qna = String(a);
  var /** @type {string} */ qnb = String(b);
  if (qna != qnb)
    return weavejs.compiler.StandardLib.stringCompare(qna, qnb);
  var /** @type {string} */ p;
  for (p in a) {
    if (!b.hasOwnProperty(p))
      return -1;
  }
  for (p in b) {
    if (!a.hasOwnProperty(p))
      return 1;
    c = weavejs.compiler.StandardLib.compare(a[p], b[p]);
    if (c != 0)
      return c;
  }
  return 0;
};


/**
 * @see mx.utils.ObjectUtil#numericCompare()
 * @export
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
weavejs.compiler.StandardLib.numericCompare = function(a, b) {
  if (isNaN(a) && isNaN(b))
    return 0;
  if (isNaN(a))
    return 1;
  if (isNaN(b))
    return -1;
  if (a < b)
    return -1;
  if (a > b)
    return 1;
  return 0;
};


/**
 * @see mx.utils.ObjectUtil#stringCompare()
 * @export
 * @param {string} a
 * @param {string} b
 * @param {boolean=} caseInsensitive
 * @return {number}
 */
weavejs.compiler.StandardLib.stringCompare = function(a, b, caseInsensitive) {
  caseInsensitive = typeof caseInsensitive !== 'undefined' ? caseInsensitive : false;
  if (a == null && b == null)
    return 0;
  if (a == null)
    return 1;
  if (b == null)
    return -1;
  if (caseInsensitive) {
    a = a.toLocaleLowerCase();
    b = b.toLocaleLowerCase();
  }
  var /** @type {number} */ result = a.localeCompare(b);
  if (result < -1)
    result = -1;
  else if (result > 1)
    result = 1;
  return result;
};


/**
 * @see mx.utils.ObjectUtil#dateCompare()
 * @export
 * @param {Date} a
 * @param {Date} b
 * @return {number}
 */
weavejs.compiler.StandardLib.dateCompare = function(a, b) {
  if (a == null && b == null)
    return 0;
  if (a == null)
    return 1;
  if (b == null)
    return -1;
  var /** @type {number} */ na = a.getTime();
  var /** @type {number} */ nb = b.getTime();
  if (na < nb)
    return -1;
  if (na > nb)
    return 1;
  if (isNaN(na) && isNaN(nb))
    return 0;
  if (isNaN(na))
    return 1;
  if (isNaN(nb))
    return -1;
  return 0;
};


/**
 * @see https://github.com/bestiejs/punycode.js
 * @param {number} value
 * @return {string}
 */
weavejs.compiler.StandardLib.ucs2encode = function(value) {
  var /** @type {string} */ output = '';
  if (value > 0xFFFF) {
    value -= 0x10000;
    output += String.fromCharCode(value >>> 10 & 0x3FF | 0xD800);
    value = 0xDC00 | value & 0x3FF;
  }
  return output + String.fromCharCode(value);
};


/**
 * @export
 * @param {Object} a
 * @param {Object} b
 * @return {number}
 */
weavejs.compiler.StandardLib.arrayCompare = function(a, b) {
  return weavejs.compiler.StandardLib.compare(a, b);
};


/**
 * @export
 * @param {Object} a
 * @param {Object} b
 * @return {number}
 */
weavejs.compiler.StandardLib.compareDynamicObjects = function(a, b) {
  return weavejs.compiler.StandardLib.compare(a, b);
};


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
weavejs.compiler.StandardLib.prototype.FLEXJS_CLASS_INFO = { names: [{ name: 'StandardLib', qName: 'weavejs.compiler.StandardLib'}] };
