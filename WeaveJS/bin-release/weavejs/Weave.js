/**
 * Generated by Apache Flex Cross-Compiler from weavejs\Weave.as
 * weavejs.Weave
 *
 * @fileoverview
 *
 * @suppress {checkTypes}
 */

goog.provide('weavejs.Weave');

goog.require('weavejs.WeaveAPI');
goog.require('weavejs.compiler.StandardLib');
goog.require('weavejs.core.ExternalSessionStateInterface');
goog.require('weavejs.core.LinkableHashMap');
goog.require('weavejs.core.LinkableString');
goog.require('weavejs.core.SessionManager');
goog.require('weavejs.core.SessionStateLog');
goog.require('weavejs.path.WeavePath');
goog.require('weavejs.path.WeavePathData');
goog.require('weavejs.utils.Dictionary2D');
goog.require('weavejs.api.core.ICallbackCollection');
goog.require('weavejs.api.core.ILinkableHashMap');
goog.require('weavejs.api.core.ILinkableObject');
goog.require('weavejs.api.core.ISessionManager');



/**
 * @constructor
 */
weavejs.Weave = function() {
  ;
  weavejs.WeaveAPI.ClassRegistry.registerSingletonImplementation(weavejs.api.core.ISessionManager, weavejs.core.SessionManager);
  this.root = new weavejs.core.LinkableHashMap();
  this.history = new weavejs.core.SessionStateLog(this.root, weavejs.Weave.HISTORY_SYNC_DELAY);
  this.directAPI = new weavejs.core.ExternalSessionStateInterface(this.root);
};


/**
 * @private
 * @const
 * @type {number}
 */
weavejs.Weave.HISTORY_SYNC_DELAY = 100;


/**
 * @export
 */
weavejs.Weave.prototype.test = function() {
  var self = this;
  var /** @type {weavejs.core.Linkablestring} */ lv = new weavejs.core.LinkableString('yo');
  lv.addImmediateCallback(this, function() {
    weavejs.Weave.log('lv', lv.state);
  }, true);
  lv.state = 'hello';
  lv.state = 'hello';
  lv.state = 'world';
  lv.state = '2';
  lv.state = 2;
  lv.state = '3';
};


/**
 * @export
 * @type {weavejs.api.core.ILinkableHashMap}
 */
weavejs.Weave.prototype.root;


/**
 * @export
 * @type {weavejs.core.SessionStateLog}
 */
weavejs.Weave.prototype.history;


/**
 * @export
 * @type {weavejs.core.ExternalSessionStateInterface}
 */
weavejs.Weave.prototype.directAPI;


/**
 * Creates a WeavePath object.  WeavePath objects are immutable after they are created.
 * This is a shortcut for "new WeavePath(weave, basePath)".
 * @asparam basePath An optional Array (or multiple parameters) specifying the path to an object in the session state.
 *                 A child index number may be used in place of a name in the path when its parent object is a LinkableHashMap.
 * @asreturn A WeavePath object.
 * @see WeavePath
 * @export
 * @param {...} basePath
 * @return {weavejs.path.WeavePath}
 */
weavejs.Weave.prototype.path = function(basePath) {
  basePath = Array.prototype.slice.call(arguments, 0);
  if (basePath.length == 1 && org.apache.flex.utils.Language.is(basePath[0], Array))
    basePath = basePath[0];
  return new weavejs.path.WeavePathData(this, basePath);
};


/**
 * A shortcut for WeaveAPI.SessionManager.getObject(WeaveAPI.globalHashMap, path).
 * @see weave.api.core.ISessionManager#getObject()
 * @export
 * @param {Array} path
 * @return {weavejs.api.core.ILinkableObject}
 */
weavejs.Weave.prototype.getObject = function(path) {
  return weavejs.WeaveAPI.SessionManager.getObject(this.root, path);
};


/**
 * A shortcut for WeaveAPI.SessionManager.getPath(WeaveAPI.globalHashMap, object).
 * @see weave.api.core.ISessionManager#getPath()
 * @export
 * @param {weavejs.api.core.ILinkableObject} object
 * @return {Array}
 */
weavejs.Weave.prototype.getPath = function(object) {
  return weavejs.WeaveAPI.SessionManager.getPath(this.root, object);
};


/**
 * This function is used to detect if callbacks of a linkable object were triggered since the last time this function
 * was called with the same parameters, likely by the observer.  Note that once this function returns true, subsequent calls will
 * return false until the callbacks are triggered again.  It's a good idea to specify a private object or function as the observer
 * so no other code can call detectLinkableObjectChange with the same observer and linkableObject parameters.
 * @asparam observer The object that is observing the change.
 * @asparam linkableObject The object that is being observed.
 * @asparam moreLinkableObjects More objects that are being observed.
 * @asreturn A value of true if the callbacks for any of the objects have triggered since the last time this function was called
 *         with the same observer for any of the specified linkable objects.
 * @export
 * @param {Object} observer
 * @param {weavejs.api.core.ILinkableObject} linkableObject
 * @param {...} moreLinkableObjects
 * @return {boolean}
 */
weavejs.Weave.detectLinkableObjectChange = function(observer, linkableObject, moreLinkableObjects) {
  moreLinkableObjects = Array.prototype.slice.call(arguments, 2);
  var /** @type {boolean} */ changeDetected = false;
  moreLinkableObjects.unshift(linkableObject);
  for (var foreachiter0 in moreLinkableObjects) 
  {
  linkableObject = moreLinkableObjects[foreachiter0];
  
    if (linkableObject && weavejs.Weave._internalDetectLinkableObjectChange(observer, linkableObject, true))
      changeDetected = true;}
  
  return changeDetected;
};


/**
 * This function is used to detect if callbacks of a linkable object were triggered since the last time detectLinkableObjectChange
 * was called with the same parameters, likely by the observer.  Note that once this function returns true, subsequent calls will
 * return false until the callbacks are triggered again, unless clearChangedNow is set to false.  It may be a good idea to specify
 * a private object as the observer so no other code can call detectLinkableObjectChange with the same observer and linkableObject
 * parameters.
 * @asparam observer The object that is observing the change.
 * @asparam linkableObject The object that is being observed.
 * @asparam clearChangedNow If this is true, the trigger counter will be reset to the current value now so that this function will
 *        return false if called again with the same parameters before the next time the linkable object triggers its callbacks.
 * @asreturn A value of true if the callbacks for the linkableObject have triggered since the last time this function was called
 *         with the same observer and linkableObject parameters.
 * @export
 * @param {Object} observer
 * @param {weavejs.api.core.ILinkableObject} linkableObject
 * @param {boolean=} clearChangedNow
 * @return {boolean}
 */
weavejs.Weave._internalDetectLinkableObjectChange = function(observer, linkableObject, clearChangedNow) {
  clearChangedNow = typeof clearChangedNow !== 'undefined' ? clearChangedNow : true;
  var /** @type {*} */ previousCount = weavejs.Weave.d2d_linkableObject_observer_triggerCounter.get(linkableObject, observer);
  var /** @type {number} */ newCount = weavejs.WeaveAPI.SessionManager.getCallbackCollection(linkableObject).triggerCounter;
  if (previousCount !== newCount) {
    if (clearChangedNow)
      weavejs.Weave.d2d_linkableObject_observer_triggerCounter.set(linkableObject, observer, newCount);
    return true;
  }
  return false;
};


/**
 * @private
 * @const
 * @type {weavejs.utils.Dictionary2D}
 */
weavejs.Weave.d2d_linkableObject_observer_triggerCounter = new weavejs.utils.Dictionary2D(true, true);


/**
 * Shortcut for WeaveAPI.SessionManager.getCallbackCollection()
 * @copy weave.api.core.ISessionManager#getCallbackCollection()
 * @export
 * @param {weavejs.api.core.ILinkableObject} linkableObject
 * @return {weavejs.api.core.ICallbackCollection}
 */
weavejs.Weave.getCallbackCollection = function(linkableObject) {
  return weavejs.WeaveAPI.SessionManager.getCallbackCollection(linkableObject);
};


/**
 * Finds the closest ancestor of a descendant given the ancestor type.
 * @asparam descendant An object with ancestors.
 * @asparam ancestorType The Class definition used to determine which ancestor to return.
 * @asreturn The closest ancestor of the given type.
 * @see weave.api.core.ISessionManager#getLinkableOwner()
 * @export
 * @param {weavejs.api.core.ILinkableObject} descendant
 * @param {Object} ancestorType
 * @return {weavejs.api.core.ILinkableObject}
 */
weavejs.Weave.getLinkableAncestor = function(descendant, ancestorType) {
  var /** @type {weavejs.api.core.ISessionManager} */ sm = weavejs.WeaveAPI.SessionManager;
  do {
    descendant = sm.getLinkableOwner(descendant);
  } while (descendant && !org.apache.flex.utils.Language.is(descendant, ancestorType));
  return descendant;
};


/**
 * Finds the root ILinkableHashMap for a given ILinkableObject.
 * @asparam object An ILinkableObject.
 * @asreturn The root ILinkableHashMap.
 * @export
 * @param {weavejs.api.core.ILinkableObject} object
 * @return {weavejs.api.core.ILinkableHashMap}
 */
weavejs.Weave.getRoot = function(object) {
  var /** @type {weavejs.api.core.ISessionManager} */ sm = weavejs.WeaveAPI.SessionManager;
  while (true) {
    var /** @type {weavejs.api.core.ILinkableObject} */ owner = sm.getLinkableOwner(object);
    if (!owner)
      break;
    object = owner;
  }
  return org.apache.flex.utils.Language.as(object, weavejs.api.core.ILinkableHashMap);
};


/**
 * Shortcut for WeaveAPI.SessionManager.getLinkableDescendants()
 * @copy weave.api.core.ISessionManager#getLinkableDescendants()
 * @export
 * @param {weavejs.api.core.ILinkableObject} object
 * @param {Object=} filter
 * @return {Array}
 */
weavejs.Weave.getLinkableDescendants = function(object, filter) {
  filter = typeof filter !== 'undefined' ? filter : null;
  return weavejs.WeaveAPI.SessionManager.getLinkableDescendants(object, filter);
};


/**
 * Shortcut for WeaveAPI.SessionManager.getLinkableOwner()
 * @copy weave.api.core.ISessionManager#getLinkableOwner()
 * @export
 * @param {weavejs.api.core.ILinkableObject} child
 * @return {weavejs.api.core.ILinkableObject}
 */
weavejs.Weave.getLinkableOwner = function(child) {
  return weavejs.WeaveAPI.SessionManager.getLinkableOwner(child);
};


/**
 * Shortcut for WeaveAPI.SessionManager.getSessionState()
 * @copy weave.api.core.ISessionManager#getSessionState()
 * @export
 * @param {weavejs.api.core.ILinkableObject} linkableObject
 * @return {Object}
 */
weavejs.Weave.getState = function(linkableObject) {
  return weavejs.WeaveAPI.SessionManager.getSessionState(linkableObject);
};


/**
 * Shortcut for WeaveAPI.SessionManager.setSessionState()
 * @copy weave.api.core.ISessionManager#setSessionState()
 * @export
 * @param {weavejs.api.core.ILinkableObject} linkableObject
 * @param {Object} newState
 * @param {boolean=} removeMissingDynamicObjects
 */
weavejs.Weave.setState = function(linkableObject, newState, removeMissingDynamicObjects) {
  removeMissingDynamicObjects = typeof removeMissingDynamicObjects !== 'undefined' ? removeMissingDynamicObjects : true;
  weavejs.WeaveAPI.SessionManager.setSessionState(linkableObject, newState, removeMissingDynamicObjects);
};


/**
 * Shortcut for WeaveAPI.SessionManager.copySessionState()
 * @copy weave.api.core.ISessionManager#copySessionState()
 * @export
 * @param {weavejs.api.core.ILinkableObject} source
 * @param {weavejs.api.core.ILinkableObject} destination
 */
weavejs.Weave.copyState = function(source, destination) {
  weavejs.WeaveAPI.SessionManager.copySessionState(source, destination);
};


/**
 * Shortcut for WeaveAPI.SessionManager.linkSessionState()
 * @copy weave.api.core.ISessionManager#linkSessionState()
 * @export
 * @param {weavejs.api.core.ILinkableObject} primary
 * @param {weavejs.api.core.ILinkableObject} secondary
 */
weavejs.Weave.linkState = function(primary, secondary) {
  weavejs.WeaveAPI.SessionManager.linkSessionState(primary, secondary);
};


/**
 * Shortcut for WeaveAPI.SessionManager.unlinkSessionState()
 * @copy weave.api.core.ISessionManager#unlinkSessionState()
 * @export
 * @param {weavejs.api.core.ILinkableObject} first
 * @param {weavejs.api.core.ILinkableObject} second
 */
weavejs.Weave.unlinkState = function(first, second) {
  weavejs.WeaveAPI.SessionManager.unlinkSessionState(first, second);
};


/**
 * Shortcut for WeaveAPI.SessionManager.newDisposableChild()
 * @copy weave.api.core.ISessionManager#newDisposableChild()
 * @export
 * @param {Object} disposableParent
 * @param {Object} disposableChildType
 * @return {*}
 */
weavejs.Weave.newDisposableChild = function(disposableParent, disposableChildType) {
  return weavejs.WeaveAPI.SessionManager.newDisposableChild(disposableParent, disposableChildType);
};


/**
 * Shortcut for WeaveAPI.SessionManager.newLinkableChild()
 * @copy weave.api.core.ISessionManager#newLinkableChild()
 * @export
 * @param {Object} linkableParent
 * @param {Object} linkableChildType
 * @param {Function=} callback
 * @param {boolean=} useGroupedCallback
 * @return {*}
 */
weavejs.Weave.newLinkableChild = function(linkableParent, linkableChildType, callback, useGroupedCallback) {
  callback = typeof callback !== 'undefined' ? callback : null;
  useGroupedCallback = typeof useGroupedCallback !== 'undefined' ? useGroupedCallback : false;
  return weavejs.WeaveAPI.SessionManager.newLinkableChild(linkableParent, linkableChildType, callback, useGroupedCallback);
};


/**
 * Shortcut for WeaveAPI.SessionManager.registerDisposableChild()
 * @copy weave.api.core.ISessionManager#registerDisposableChild()
 * @export
 * @param {Object} disposableParent
 * @param {Object} disposableChild
 * @return {*}
 */
weavejs.Weave.registerDisposableChild = function(disposableParent, disposableChild) {
  return weavejs.WeaveAPI.SessionManager.registerDisposableChild(disposableParent, disposableChild);
};


/**
 * Shortcut for WeaveAPI.SessionManager.registerLinkableChild()
 * @copy weave.api.core.ISessionManager#registerLinkableChild()
 * @export
 * @param {Object} linkableParent
 * @param {weavejs.api.core.ILinkableObject} linkableChild
 * @param {Function=} callback
 * @param {boolean=} useGroupedCallback
 * @return {*}
 */
weavejs.Weave.registerLinkableChild = function(linkableParent, linkableChild, callback, useGroupedCallback) {
  callback = typeof callback !== 'undefined' ? callback : null;
  useGroupedCallback = typeof useGroupedCallback !== 'undefined' ? useGroupedCallback : false;
  return weavejs.WeaveAPI.SessionManager.registerLinkableChild(linkableParent, linkableChild, callback, useGroupedCallback);
};


/**
 * Shortcut for WeaveAPI.SessionManager.disposeObject()
 * @copy weave.api.core.ISessionManager#disposeObject()
 * @export
 * @param {Object} object
 */
weavejs.Weave.disposeObject = function(object) {
  weavejs.WeaveAPI.SessionManager.disposeObject(object);
};


/**
 * Shortcut for WeaveAPI.SessionManager.objectWasDisposed()
 * @copy weave.api.core.ISessionManager#objectWasDisposed()
 * @export
 * @param {Object} object
 * @return {boolean}
 */
weavejs.Weave.objectWasDisposed = function(object) {
  return weavejs.WeaveAPI.SessionManager.objectWasDisposed(object);
};


/**
 * Shortcut for WeaveAPI.SessionManager.linkableObjectIsBusy()
 * @copy weave.api.core.ISessionManager#linkableObjectIsBusy()
 * @export
 * @param {weavejs.api.core.ILinkableObject} object
 * @return {boolean}
 */
weavejs.Weave.linkableObjectIsBusy = function(object) {
  return weavejs.WeaveAPI.SessionManager.linkableObjectIsBusy(object);
};


/**
 * @export
 * @param {Object} context
 * @param {Function} func
 * @param {Array=} args
 */
weavejs.Weave.callLater = function(context, func, args) {
  args = typeof args !== 'undefined' ? args : null;
  var /** @type {Function} */ setTimeout = weavejs.Weave.global.setTimeout;
  setTimeout(function() {
    if (!weavejs.Weave.objectWasDisposed(context))
      func.apply(context, args);
  }, 0);
};


/**
 * @export
 * @const
 * @type {Object}
 */
weavejs.Weave.global = function() {
  return this;
}.apply(null);


/**
 * Calls console.error()
 * @export
 * @param {...} args
 */
weavejs.Weave.error = function(args) {
  args = Array.prototype.slice.call(arguments, 0);
  weavejs.Weave.global.console.error.apply(weavejs.Weave.global.console, args);
};


/**
 * Calls console.log()
 * @export
 * @param {...} args
 */
weavejs.Weave.log = function(args) {
  args = Array.prototype.slice.call(arguments, 0);
  weavejs.Weave.global.console.log.apply(weavejs.Weave.global.console, args);
};


/**
 * AS->JS Language helper for binding class instance functions
 * @export
 * @param {Object} instance
 * @return {*}
 */
weavejs.Weave.bindAll = function(instance) {
  var /** @type {Object} */ proto = Object['getPrototypeOf'](instance);
  for (var /** @type {string} */ key in proto) {
    var /** @type {*} */ prop = proto[key];
    if (typeof(prop) === 'function' && key !== 'constructor')
      instance[key] = prop.bind(instance);
  }
  return instance;
};


/**
 * AS->JS Language helper for Object.keys()
 * @export
 * @param {Object} object
 * @return {Array}
 */
weavejs.Weave.objectKeys = function(object) {
  return Object['keys'](object);
};


/**
 * AS->JS Language helper for converting array-like objects to Arrays
 * Also works on Iterator objects to extract an Array of values
 * @export
 * @param {*} value
 * @return {Array}
 */
weavejs.Weave.toArray = function(value) {
  if (org.apache.flex.utils.Language.is(value, weavejs.Weave.global.Iterator)) {
    var /** @type {Array} */ values = [];
    while (true) {
      var /** @type {Object} */ next = value.next();
      if (next.done)
        break;
      values.push(next.value);
    }
    return values;
  }
  return org.apache.flex.utils.Language.as(value, Array);
};


/**
 * Makes a deep copy of an object.
 * @export
 * @param {Object} object
 * @return {Object}
 */
weavejs.Weave.copyObject = function(object) {
  if (object !== null && typeof(object) === 'object')
    return JSON.parse(JSON.stringify(object));
  return object;
};


/**
 * Gets the qualified class name from a class definition or an object instance.
 * @export
 * @param {Object} def
 * @return {string}
 */
weavejs.Weave.className = function(def) {
  if (!def)
    return null;
  if (!def.prototype)
    def = def.constructor;
  if (def.prototype && def.prototype.FLEXJS_CLASS_INFO)
    return def.prototype.FLEXJS_CLASS_INFO.names[0].qName;
  return def.name;
};


/**
 * @export
 * @const
 * @type {Array}
 */
weavejs.Weave.defaultPackages = ['weavejs.core'];


/**
 * @export
 * @param {string} name
 * @return {*}
 */
weavejs.Weave.getDefinition = function(name) {
  var /** @type {*} */ def = weavejs.Weave.global;
  for (var foreachiter1 in name.split('.')) 
  {
  var key = name.split('.')[foreachiter1];
  {
    if (def !== undefined)
      def = def[key];
    else
      break;
  }}
  
  if (!def) {
    for (var foreachiter2 in weavejs.Weave.defaultPackages) 
    {
    var pkg = weavejs.Weave.defaultPackages[foreachiter2];
    {
      def = weavejs.Weave.getDefinition(pkg + '.' + name);
      if (def)
        return def;
    }}
    
  }
  return def;
};


/**
 * Tests if something looks like a Class.
 * @export
 * @param {Object} classDef
 * @return {boolean}
 */
weavejs.Weave.isClass = function(classDef) {
  return typeof(classDef) === 'function' && classDef.prototype && classDef.prototype.constructor === classDef;
};


/**
 * Implementation of "classDef as Class"
 * @export
 * @param {Object} classDef
 * @return {*}
 */
weavejs.Weave.asClass = function(classDef) {
  return weavejs.Weave.isClass(classDef) ? classDef : null;
};


/**
 * Current time in milliseconds
 * @export
 * @return {number}
 */
weavejs.Weave.getTimer = function() {
  return Date['now']();
};


/**
 * Checks if an object implements ILinkableObject
 * @export
 * @param {Object} object
 * @return {boolean}
 */
weavejs.Weave.isLinkable = function(object) {
  return org.apache.flex.utils.Language.is(object, weavejs.api.core.ILinkableObject);
};


/**
 * Generates a deterministic JSON-like representation of an object, meaning object keys appear in sorted order.
 * @asparam value The object to stringify.
 * @asparam replacer A function like function(key:String, value:*):*
 * @asparam indent Either a Number or a String to specify indentation of nested values
 * @asparam json_values_only If this is set to true, only JSON-compatible values will be used (NaN/Infinity/undefined -> null)
 * @export
 * @param {*} value
 * @param {Function=} replacer
 * @param {*=} indent
 * @param {boolean=} json_values_only
 * @return {string}
 */
weavejs.Weave.stringify = function(value, replacer, indent, json_values_only) {
  replacer = typeof replacer !== 'undefined' ? replacer : null;
  indent = typeof indent !== 'undefined' ? indent : null;
  json_values_only = typeof json_values_only !== 'undefined' ? json_values_only : false;
  indent = typeof(indent) === 'number' ? weavejs.compiler.StandardLib.lpad('', indent, ' ') : org.apache.flex.utils.Language.as(indent, String) || '';
  return weavejs.Weave._stringify("", value, replacer, indent ? '\n' : '', indent, json_values_only);
};


/**
 * @private
 * @param {string} key
 * @param {*} value
 * @param {Function} replacer
 * @param {string} lineBreak
 * @param {string} indent
 * @param {boolean} json_values_only
 * @return {string}
 */
weavejs.Weave._stringify = function(key, value, replacer, lineBreak, indent, json_values_only) {
  if (replacer != null)
    value = replacer(key, value);
  var /** @type {Array} */ output;
  var /** @type {*} */ item;
  if (typeof(value) === 'string')
    return weavejs.Weave.encodeString(value);
  if (value == null || typeof(value) != 'object') {
    if (json_values_only && (value === undefined || !isFinite(org.apache.flex.utils.Language.as(value, Number))))
      value = null;
    return String(value) || String(null);
  }
  var /** @type {string} */ lineBreakIndent = lineBreak + indent;
  var /** @type {boolean} */ valueIsArray = org.apache.flex.utils.Language.is(value, Array);
  output = [];
  if (valueIsArray) {
    for (var /** @type {number} */ i = 0; i < value.length; i++)
      output.push(weavejs.Weave._stringify(String(i), value[i], replacer, lineBreakIndent, indent, json_values_only));
  } else if (typeof(value) == 'object') {
    for (key in value)
      output.push(weavejs.Weave.encodeString(key) + ": " + weavejs.Weave._stringify(key, value[key], replacer, lineBreakIndent, indent, json_values_only));
    output.sort();
  }
  if (output.length == 0)
    return valueIsArray ? "[]" : "{}";
  return valueIsArray ? "[" : "{" + lineBreakIndent + output.join(indent ? ',' + lineBreakIndent : ', ') + lineBreak + valueIsArray ? "]" : "}";
};


/**
 * This function surrounds a String with quotes and escapes special characters using ActionScript string literal format.
 * @asparam string A String that may contain special characters.
 * @asparam quote Set this to either a double-quote or a single-quote.
 * @asreturn The given String formatted for ActionScript.
 * @private
 * @param {string} string
 * @param {string=} quote
 * @return {string}
 */
weavejs.Weave.encodeString = function(string, quote) {
  quote = typeof quote !== 'undefined' ? quote : '"';
  if (string == null)
    return 'null';
  var /** @type {Array} */ result = new Array(string.length);
  for (var /** @type {number} */ i = 0; i < string.length; i++) {
    var /** @type {string} */ chr = string.charAt(i);
    var /** @type {string} */ esc = chr == quote ? quote : weavejs.Weave.ENCODE_LOOKUP[chr];
    result[i] = esc ? '\\' + esc : chr;
  }
  return quote + result.join('') + quote;
};


/**
 * @private
 * @const
 * @type {Object}
 */
weavejs.Weave.ENCODE_LOOKUP = {'\b':'b', '\f':'f', '\n':'n', '\r':'r', '\t':'t', '\\':'\\'};


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
weavejs.Weave.prototype.FLEXJS_CLASS_INFO = { names: [{ name: 'Weave', qName: 'weavejs.Weave'}] };
