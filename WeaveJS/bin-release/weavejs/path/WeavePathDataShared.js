/**
 * Generated by Apache Flex Cross-Compiler from weavejs\path\WeavePathDataShared.as
 * weavejs.path.WeavePathDataShared
 *
 * @fileoverview
 *
 * @suppress {checkTypes}
 */

goog.provide('weavejs.path.WeavePathDataShared');

goog.require('weavejs.Weave');
goog.require('weavejs.path.WeavePath');



/**
 * @constructor
 */
weavejs.path.WeavePathDataShared = function() {
  
  this._qkeys_to_numeric = {};
  this._numeric_to_qkeys = {};
  this._key_buffers = {};
  weavejs.Weave.bindAll(this);
};


/**
 * @export
 * @const
 * @type {string}
 */
weavejs.path.WeavePathDataShared.DEFAULT_PROBE_KEY_SET = 'defaultProbeKeySet';


/**
 * @export
 * @const
 * @type {string}
 */
weavejs.path.WeavePathDataShared.DEFAULT_SELECTION_KEY_SET = 'defaultSelectionKeySet';


/**
 * @export
 * @const
 * @type {string}
 */
weavejs.path.WeavePathDataShared.DEFAULT_SUBSET_KEY_FILTER = 'defaultSubsetKeyFilter';


/**
 * @export
 * @const
 * @type {string}
 */
weavejs.path.WeavePathDataShared.EDC = 'weave.data.AttributeColumns::ExtendedDynamicColumn';


/**
 * @export
 * @const
 * @type {string}
 */
weavejs.path.WeavePathDataShared.DC = 'weave.data.AttributeColumns::DynamicColumn';


/**
 * @export
 * @const
 * @type {string}
 */
weavejs.path.WeavePathDataShared.RC = 'weave.data.AttributeColumns::ReferencedColumn';


/**
 * @export
 * @param {weavejs.Weave} weave
 */
weavejs.path.WeavePathDataShared.prototype.init = function(weave) {
  this.weave = weave;
  this.probe_keyset = weave.path(weavejs.path.WeavePathDataShared.DEFAULT_PROBE_KEY_SET);
  this.selection_keyset = weave.path(weavejs.path.WeavePathDataShared.DEFAULT_SELECTION_KEY_SET);
  this.subset_filter = weave.path(weavejs.path.WeavePathDataShared.DEFAULT_SUBSET_KEY_FILTER);
};


/**
 * @export
 * @type {weavejs.Weave}
 */
weavejs.path.WeavePathDataShared.prototype.weave;


/**
 * @export
 * @type {weavejs.path.WeavePath}
 */
weavejs.path.WeavePathDataShared.prototype.probe_keyset;


/**
 * @export
 * @type {weavejs.path.WeavePath}
 */
weavejs.path.WeavePathDataShared.prototype.selection_keyset;


/**
 * @export
 * @type {weavejs.path.WeavePath}
 */
weavejs.path.WeavePathDataShared.prototype.subset_filter;


/**
 * @export
 * @type {Object}
 */
weavejs.path.WeavePathDataShared.prototype._qkeys_to_numeric;


/**
 * @export
 * @type {Object}
 */
weavejs.path.WeavePathDataShared.prototype._numeric_to_qkeys;


/**
 * @export
 * @type {number}
 */
weavejs.path.WeavePathDataShared.prototype._numeric_key_idx = 0;


/**
 * @export
 * @type {string}
 */
weavejs.path.WeavePathDataShared.prototype._keyIdPrefix = "WeaveQKey";


/**
 * @export
 * @type {Object}
 */
weavejs.path.WeavePathDataShared.prototype._key_buffers;


/** 
 * Retrieves or allocates the index for the given QualifiedKey object based on its localName and keyType properties
 * @public 
 * @asparam  {object} key A QualifiedKey object (containing keyType and localName properties) to be converted.
 * @asreturn {number}     The existing or newly-allocated index for the qualified key.
 * @export
 * @param {Object} key
 * @return {number}
 */
weavejs.path.WeavePathDataShared.prototype.qkeyToIndex = function(key) {
  var /** @type {Object} */ local_map = this._qkeys_to_numeric[key.keyType] || (this._qkeys_to_numeric[key.keyType] = {});
  if (local_map[key.localName] === undefined) {
    var /** @type {number} */ idx = this._numeric_key_idx++;
    local_map[key.localName] = idx;
    this._numeric_to_qkeys[idx] = key;
  }
  return local_map[key.localName];
};


/**
 * Retrieves the corresponding qualified key object from its numeric index.
 * @asprivate
 * @asparam  {number} index The numeric index, as received from qkeyToIndex
 * @asreturn {object}       The corresponding QualifiedKey object.
 * @export
 * @param {number} index
 * @return {Object}
 */
weavejs.path.WeavePathDataShared.prototype.indexToQKey = function(index) {
  return this._numeric_to_qkeys[index];
};


/**
 * Retrieves an alphanumeric string unique to a QualifiedKey
 * This is also available as an alias on the WeavePath object.
 * @asparam  {object} key The QualifiedKey object to convert.
 * @asreturn {string}     The corresponding alphanumeric key.
 * @export
 * @param {Object} key
 * @return {string}
 */
weavejs.path.WeavePathDataShared.prototype.qkeyToString = function(key) {
  return this._keyIdPrefix + this.qkeyToIndex(key);
};


/**
 * Retrieves the QualifiedKey object corresponding to a given alphanumeric string.
 * This is also available as an alias on the WeavePath object.
 * @asparam  {string} s The keystring to convert.
 * @asreturn {object}   The corresponding QualifiedKey
 * @export
 * @param {string} s
 * @return {Object}
 */
weavejs.path.WeavePathDataShared.prototype.stringToQKey = function(s) {
  var /** @type {number} */ idx = org.apache.flex.utils.Language._int(s.substr(this._keyIdPrefix.length));
  return this.indexToQKey(idx);
};


/**
 * Gets the key add/remove buffers for a specific session state path.
 * @asprivate
 * @asparam  {Array} pathArray A raw session state path.
 * @asreturn {object}           An object containing the key add/remove queues for the given path.
 * @export
 * @param {Array} pathArray
 * @return {Object}
 */
weavejs.path.WeavePathDataShared.prototype._getKeyBuffers = function(pathArray) {
  var /** @type {string} */ path_key = JSON.stringify(pathArray);
  var /** @type {Object} */ key_buffers_dict = this._key_buffers;
  var /** @type {Object} */ key_buffers = key_buffers_dict[path_key] || (key_buffers_dict[path_key] = {});
  if (key_buffers.add === undefined)
    key_buffers.add = {};
  if (key_buffers.remove === undefined)
    key_buffers.remove = {};
  if (key_buffers.timeout_id === undefined)
    key_buffers.timeout_id = null;
  return key_buffers;
};


/**
 * Flushes the key add/remove buffers for a specific session state path. 
 * @asprivate
 * @asparam  {Array} pathArray The session state path to flush.         
 * @export
 * @param {Array} pathArray
 */
weavejs.path.WeavePathDataShared.prototype._flushKeys = function(pathArray) {
  var /** @type {Object} */ key_buffers = this._getKeyBuffers(pathArray);
  var /** @type {Array} */ add_keys = weavejs.Weave.objectKeys(key_buffers.add);
  var /** @type {Array} */ remove_keys = weavejs.Weave.objectKeys(key_buffers.remove);
  add_keys = add_keys.map(org.apache.flex.utils.Language.closure(this.stringToQKey, this, 'stringToQKey'), this);
  remove_keys = remove_keys.map(org.apache.flex.utils.Language.closure(this.stringToQKey, this, 'stringToQKey'), this);
  key_buffers.add = {};
  key_buffers.remove = {};
  var /** @type {Object} */ obj = this.weave.path(pathArray).getObject();
  obj.addKeys(add_keys);
  obj.removeKeys(remove_keys);
  key_buffers.timeout_id = null;
};


/**
 * Set a timeout to flush the add/remove key buffers for a given session state path if one isn't already in progress.
 * @asprivate
 * @asparam  {Array} pathArray The session state path referencing a KeySet to flush.
 * @export
 * @param {Array} pathArray
 */
weavejs.path.WeavePathDataShared.prototype._flushKeysLater = function(pathArray) {
  var /** @type {Object} */ key_buffers = this._getKeyBuffers(pathArray);
  if (key_buffers.timeout_id === null)
    key_buffers.timeout_id = weavejs.Weave.global.setTimeout(org.apache.flex.utils.Language.closure(this._flushKeys, this, '_flushKeys'), 25, pathArray);
};


/**
 * Queue keys to be added to a specified path.
 * @asprivate
 * @asparam {Array} pathArray      The session state path referencing a KeySet
 * @asparam {Array} keyStringArray The set of keys to add.
 * @export
 * @param {Array} pathArray
 * @param {Array} keyStringArray
 */
weavejs.path.WeavePathDataShared.prototype._addKeys = function(pathArray, keyStringArray) {
  var self = this;
  var /** @type {Object} */ key_buffers = this._getKeyBuffers(pathArray);
  keyStringArray.forEach(function(str) {
    key_buffers.add[str] = true;
    delete key_buffers.remove[str];
  });
  this._flushKeysLater(pathArray);
};


/**
 * Queue keys to be removed from a specified path.
 * @asprivate
 * @asparam {Array} pathArray      The session state path referencing a KeySet
 * @asparam {Array} keyStringArray The set of keys to remove.
 * @export
 * @param {Array} pathArray
 * @param {Array} keyStringArray
 */
weavejs.path.WeavePathDataShared.prototype._removeKeys = function(pathArray, keyStringArray) {
  var self = this;
  var /** @type {Object} */ key_buffers = this._getKeyBuffers(pathArray);
  keyStringArray.forEach(function(str) {
    key_buffers.remove[str] = true;
    delete key_buffers.add[str];
  });
  this._flushKeysLater(pathArray);
};


/**
 * @export
 * @type {Function}
 */
weavejs.path.WeavePathDataShared.prototype.isColumn;


/**
 * @export
 * @type {Function}
 */
weavejs.path.WeavePathDataShared.prototype.joinColumns;


/**
 * @export
 * @type {Function}
 */
weavejs.path.WeavePathDataShared.prototype.getLabel;


/**
 * @export
 * @type {Function}
 */
weavejs.path.WeavePathDataShared.prototype.setLabel;


/**
 * @export
 * @type {Function}
 */
weavejs.path.WeavePathDataShared.prototype.getColumnType;


/**
 * @export
 * @type {Function}
 */
weavejs.path.WeavePathDataShared.prototype.getFirstDataSourceName;


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
weavejs.path.WeavePathDataShared.prototype.FLEXJS_CLASS_INFO = { names: [{ name: 'WeavePathDataShared', qName: 'weavejs.path.WeavePathDataShared'}] };
