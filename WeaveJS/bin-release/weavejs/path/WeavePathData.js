/**
 * Generated by Apache Flex Cross-Compiler from weavejs\path\WeavePathData.as
 * weavejs.path.WeavePathData
 *
 * @fileoverview
 *
 * @suppress {checkTypes}
 */

goog.provide('weavejs.path.WeavePathData');

goog.require('weavejs.Weave');
goog.require('weavejs.path.WeavePath');
goog.require('weavejs.path.WeavePathDataShared');
goog.require('weavejs.utils.Utils');



/**
 * @constructor
 * @extends {weavejs.path.WeavePath}
 * @param {weavejs.Weave} weave
 * @param {Array} basePath
 */
weavejs.path.WeavePathData = function(weave, basePath) {
  weavejs.path.WeavePathData.base(this, 'constructor', weave, basePath);
  var /** @type {weavejs.path.WeavePathDataShared} */ shared = weavejs.path.WeavePathData.map_weave.get(weave);
  if (!shared) {
    weavejs.path.WeavePathData.map_weave.set(weave, shared = new weavejs.path.WeavePathDataShared());
    shared.init(weave);
  }
  this.shared = shared;
  this.probe_keyset = shared.probe_keyset;
  this.selection_keyset = shared.selection_keyset;
  this.subset_filter = shared.subset_filter;
  this.qkeyToString = org.apache.flex.utils.Language.closure(shared.qkeyToString, shared, 'qkeyToString');
  this.stringToQKey = org.apache.flex.utils.Language.closure(shared.stringToQKey, shared, 'stringToQKey');
  this.indexToQKey = org.apache.flex.utils.Language.closure(shared.indexToQKey, shared, 'indexToQKey');
  this.qkeyToIndex = org.apache.flex.utils.Language.closure(shared.qkeyToIndex, shared, 'qkeyToIndex');
};
goog.inherits(weavejs.path.WeavePathData, weavejs.path.WeavePath);


/**
 * @private
 * @type {Object}
 */
weavejs.path.WeavePathData.map_weave = new weavejs.utils.Utils.WeakMap();


/**
 * @private
 * @type {weavejs.path.WeavePathDataShared}
 */
weavejs.path.WeavePathData.prototype.shared;


/**
 * @export
 * @type {weavejs.path.WeavePath}
 */
weavejs.path.WeavePathData.prototype.probe_keyset;


/**
 * @export
 * @type {weavejs.path.WeavePath}
 */
weavejs.path.WeavePathData.prototype.selection_keyset;


/**
 * @export
 * @type {weavejs.path.WeavePath}
 */
weavejs.path.WeavePathData.prototype.subset_filter;


/**
 * @export
 * @type {Function}
 */
weavejs.path.WeavePathData.prototype.qkeyToString;


/**
 * @export
 * @type {Function}
 */
weavejs.path.WeavePathData.prototype.stringToQKey;


/**
 * @export
 * @type {Function}
 */
weavejs.path.WeavePathData.prototype.indexToQKey;


/**
 * @export
 * @type {Function}
 */
weavejs.path.WeavePathData.prototype.qkeyToIndex;


/**
 * Creates a new property based on configuration stored in a property descriptor object. 
 * See initProperties for documentation of the property_descriptor object.
 * @asparam callback_pass If false, create object, verify type, and set default value; if true, add callback;
 * @asparam property_descriptor An object containing, minimally, a 'name' property defining the name of the session state element to be created.
 * @asprivate
 * @asreturn The current WeavePath object.
 * @private
 * @param {*} manifest
 * @param {*} callback_pass
 * @param {*} property_descriptor
 * @return {weavejs.path.WeavePath}
 */
weavejs.path.WeavePathData.prototype._initProperty = function(manifest, callback_pass, property_descriptor) {
  var /** @type {string} */ name = property_descriptor["name"] || weavejs.path.WeavePath._failMessage('initProperty', 'A "name" is required');
  var /** @type {string} */ label = property_descriptor["label"];
  var /** @type {Array} */ children = org.apache.flex.utils.Language.is(property_descriptor["children"], Array) ? weavejs.Weave.toArray(property_descriptor["children"]) : undefined;
  var /** @type {string} */ type = property_descriptor["type"] || children ? "LinkableHashMap" : "LinkableVariable";
  var /** @type {weavejs.path.WeavePathData} */ new_prop = org.apache.flex.utils.Language.as(this.push(name), weavejs.path.WeavePathData);
  if (callback_pass) {
    var /** @type {Function} */ callback = property_descriptor["callback"];
    var /** @type {*} */ triggerNow = property_descriptor["triggerNow"];
    var /** @type {*} */ immediate = property_descriptor["immediate"];
    if (callback)
      new_prop.addCallback(callback, triggerNow !== undefined ? triggerNow : true, immediate !== undefined ? immediate : false);
  } else {
    var /** @type {string} */ oldType = new_prop.getType();
    type = new_prop.request(type).getType();
    if (label) {
      new_prop.label(label);
    }
    if (oldType != type && property_descriptor.hasOwnProperty("default")) {
      new_prop.state(property_descriptor["default"]);
    }
    manifest[name] = new_prop;
  }
  if (children) {
    if (!callback_pass)
      manifest[name] = {};
    children.forEach(this._initProperty.bind(new_prop, manifest[name], callback_pass));
  }
  return this;
};


/**
 * Creates a set of properties for a tool from an array of property descriptor objects.
 * Each property descriptor can contain the follow properties:
 * 'name': Required, specifies the name for the session state item.
 * 'children': Optionally, another array of property descriptors to create as children of this property.
 * 'label': A human-readable display name for the session state item.
 * 'type': A Weave session variable type; defaults to "LinkableVariable," or "LinkableHashMap" if children is defined.
 * 'callback': A function to be called when this session state item (or a child of it) changes.
 * 'triggerNow': Specify whether to trigger the callback after it is added; defaults to 'true.'
 * 'immediate': Specify whether to execute the callback in immediate (once per change) or grouped (once per frame) mode.
 * @asparam {Array} property_descriptor_array An array of property descriptor objects, each minimally containing a 'name' property.
 * @asparam {object} manifest An object to populate with name->path relationships for convenience.
 * @asreturn {object} The manifest.
 * @private
 * @param {Array} property_descriptor_array
 * @param {Object=} manifest
 * @return {Object}
 */
weavejs.path.WeavePathData.prototype.initProperties = function(property_descriptor_array, manifest) {
  manifest = typeof manifest !== 'undefined' ? manifest : null;
  if (this.getType() == null)
    this.request("ExternalTool");
  if (!manifest)
    manifest = {};
  property_descriptor_array.forEach(this._initProperty.bind(this, manifest, false));
  property_descriptor_array.forEach(this._initProperty.bind(this, manifest, true));
  return manifest;
};


/**
 * Constructs and returns an object containing keys corresponding to the children of the session state object referenced by this path, the values of which are new WeavePath objects.
 * @asparam [relativePath] An optional Array (or multiple parameters) specifying descendant names relative to the current path.
 *                     A child index number may be used in place of a name in the path when its parent object is a LinkableHashMap.
 * @asreturn {object} An object containing keys corresponding to the children of the session state object.
 * @export
 * @param {...} relativePath
 * @return {Object}
 */
weavejs.path.WeavePathData.prototype.getProperties = function(relativePath) {
  var self = this;
  relativePath = Array.prototype.slice.call(arguments, 0);
  var /** @type {Object} */ result = {};
  this.getNames.apply(this, relativePath).forEach(function(name) {
    result[name] = this.push(name);
  }, this);
  return result;
};


/**
 * Returns an array of alphanumeric strings uniquely corresponding to the KeySet referenced by this path.
 * @asparam [relativePath] An optional Array (or multiple parameters) specifying descendant names relative to the current path.
 *                     A child index number may be used in place of a name in the path when its parent object is a LinkableHashMap.
 * @asreturn {Array} An array of alphanumeric strings corresponding to the keys contained by the KeySet.
 * @export
 * @param {...} relativePath
 * @return {Array}
 */
weavejs.path.WeavePathData.prototype.getKeys = function(relativePath) {
  relativePath = Array.prototype.slice.call(arguments, 0);
  var /** @type {Array} */ args = weavejs.path.WeavePath._A(relativePath, 1);
  var /** @type {Array} */ raw_keys = this.getObject(args)['keys'];
  return raw_keys.map(this.qkeyToString);
};


/**
 * Forces a flush of the add/remove key buffers for the KeySet specified by this path.
 * @asparam [relativePath] An optional Array (or multiple parameters) specifying descendant names relative to the current path
 *                     A child index number may be used in place of a name in the path when its parent object is a LinkableHashMap.
 * @asreturn {weave.WeavePath} The current WeavePath object.
 * @export
 * @param {...} relativePath
 * @return {weavejs.path.WeavePath}
 */
weavejs.path.WeavePathData.prototype.flushKeys = function(relativePath) {
  relativePath = Array.prototype.slice.call(arguments, 0);
  var /** @type {Array} */ args = weavejs.path.WeavePath._A(relativePath, 1);
  if (weavejs.path.WeavePath._assertParams('flushKeys', args)) {
    var /** @type {Array} */ path = this._path.concat(args);
    this.shared._flushKeys(path);
  }
  return this;
};


/**
 * Adds the specified keys to the KeySet at this path. These will not be added immediately, but are queued with flush timeout of approx. 25 ms.
 * @asparam [relativePath] An optional Array (or multiple parameters) specifying descendant names relative to the current path
 *                     A child index number may be used in place of a name in the path when its parent object is a LinkableHashMap.
 * @asparam {Array} [keyStringArray] An array of alphanumeric keystrings that correspond to QualifiedKeys.
 * @asreturn {weave.WeavePath} The current WeavePath object.
 * @export
 * @param {...} relativePath_keyStringArray
 * @return {weavejs.path.WeavePath}
 */
weavejs.path.WeavePathData.prototype.addKeys = function(relativePath_keyStringArray) {
  relativePath_keyStringArray = Array.prototype.slice.call(arguments, 0);
  var /** @type {Array} */ args = weavejs.path.WeavePath._A(relativePath_keyStringArray, 2);
  if (weavejs.path.WeavePath._assertParams('addKeys', args)) {
    var /** @type {Array} */ keyStringArray = args.pop();
    var /** @type {Array} */ path = this._path.concat(args);
    this.shared._addKeys(path, keyStringArray);
  }
  return this;
};


/**
 * Removes the specified keys to the KeySet at this path. These will not be removed immediately, but are queued with a flush timeout of approx. 25 ms.
 * @asparam [relativePath] An optional Array (or multiple parameters) specifying descendant names relative to the current path
 *                     A child index number may be used in place of a name in the path when its parent object is a LinkableHashMap.
 * @asparam {Array} [keyStringArray] An array of alphanumeric keystrings that correspond to QualifiedKeys.
 * @asreturn {weave.WeavePath} The current WeavePath object.
 * @export
 * @param {...} relativePath_keyStringArray
 * @return {weavejs.path.WeavePath}
 */
weavejs.path.WeavePathData.prototype.removeKeys = function(relativePath_keyStringArray) {
  relativePath_keyStringArray = Array.prototype.slice.call(arguments, 0);
  var /** @type {Array} */ args = weavejs.path.WeavePath._A(relativePath_keyStringArray, 2);
  if (weavejs.path.WeavePath._assertParams('removeKeys', args)) {
    var /** @type {Array} */ keyStringArray = args.pop();
    var /** @type {Array} */ path = this._path.concat(args);
    this.shared._removeKeys(path, keyStringArray);
  }
  return this;
};


/**
 * Adds a callback to the KeySet specified by this path which will return information about which keys were added or removed to/from the set.
 * @asparam {Function} callback           A callback function which will receive an object containing two fields,
 *                                       'added' and 'removed' which contain a list of the keys which changed in the referenced KeySet
 * @asparam {boolean}  [triggerCallbackNow] Whether to trigger the callback immediately after it is added.
 * @asreturn {weave.WeavePath} The current WeavePath object.
 * @export
 * @param {Function} callback
 * @param {boolean=} triggerCallbackNow
 * @return {weavejs.path.WeavePath}
 */
weavejs.path.WeavePathData.prototype.addKeySetCallback = function(callback, triggerCallbackNow) {
  var self = this;
  triggerCallbackNow = typeof triggerCallbackNow !== 'undefined' ? triggerCallbackNow : false;
  var /** @type {Function} */ wrapper = function() {
    var /** @type {Object} */ key_event = this.weave.directAPI.evaluateExpression(this._path, '{added: this.keysAdded, removed: this.keysRemoved}');
    key_event.added = key_event.added.map(this.qkeyToString);
    key_event.removed = key_event.removed.map(this.qkeyToString);
    callback.call(this, key_event);
  };
  this.push('keyCallbacks').addCallback(wrapper, false, true);
  if (triggerCallbackNow) {
    var /** @type {Object} */ key_event = {added:this.getKeys(), removed:[]};
    callback.call(this, key_event);
  }
  return this;
};


/**
 * Replaces the contents of the KeySet at this path with the specified keys.
 * @asparam [relativePath] An optional Array (or multiple parameters) specifying descendant names relative to the current path
 *                     A child index number may be used in place of a name in the path when its parent object is a LinkableHashMap.
 * @asparam {Array} keyStringArray An array of alphanumeric keystrings that correspond to QualifiedKeys.
 * @asreturn {weave.WeavePath} The current WeavePath object.
 * @export
 * @param {...} relativePath_keyStringArray
 * @return {weavejs.path.WeavePath}
 */
weavejs.path.WeavePathData.prototype.setKeys = function(relativePath_keyStringArray) {
  relativePath_keyStringArray = Array.prototype.slice.call(arguments, 0);
  var /** @type {Array} */ args = weavejs.path.WeavePath._A(relativePath_keyStringArray, 2);
  if (weavejs.path.WeavePath._assertParams('setKeys', args)) {
    var /** @type {Array} */ keyStringArray = args.pop();
    var /** @type {Array} */ keyObjectArray = keyStringArray.map(this.stringToQKey);
    this.getObject(args)['replaceKeys'](keyObjectArray);
    return this;
  }
  return this;
};


/**
 * Intersects the specified keys with the KeySet at this path.
 * @asparam [relativePath] An optional Array (or multiple parameters) specifying descendant names relative to the current path
 *                     A child index number may be used in place of a name in the path when its parent object is a LinkableHashMap.
 * @asparam {Array} keyStringArray An array of alphanumeric keystrings that correspond to QualifiedKeys.
 * @asreturn {Array} The keys which exist in both the keyStringArray and in the KeySet at this path.
 * @export
 * @param {...} relativePath_keyStringArray
 * @return {Array}
 */
weavejs.path.WeavePathData.prototype.filterKeys = function(relativePath_keyStringArray) {
  relativePath_keyStringArray = Array.prototype.slice.call(arguments, 0);
  return null;
};


/**
 * Retrieves a list of records defined by a mapping of property names to column paths or by an array of column names.
 * @asparam {object} pathMapping An object containing a mapping of desired property names to column paths or an array of child names.
 * pathMapping can be one of three different forms:
 * 
 * 1. An array of column names corresponding to children of the WeavePath this method is called from, e.g., path.retrieveRecords(["x", "y"]);
 * the column names will also be used as the corresponding property names in the resultant records.
 * 
 * 2. An object, for which each property=>value is the target record property => source column WeavePath. This can be defined to include recursive structures, e.g.,
 * path.retrieveRecords({point: {x: x_column, y: y_column}, color: color_column}), which would result in records with the same form.
 * 
 * 3. If it is null, all children of the WeavePath will be retrieved. This is equivalent to: path.retrieveRecords(path.getNames());
 * 
 * The alphanumeric QualifiedKey for each record will be stored in the 'id' field, which means it is to be considered a reserved name.
 * @asparam {weave.WeavePath} [options] An object containing optional parameters:
 *                                    "keySet": A WeavePath object pointing to an IKeySet (columns are also IKeySets.)
 *                                    "dataType": A String specifying dataType: string/number/date/geometry
 * @asreturn {Array} An array of record objects.
 * @export
 * @param {Object} pathMapping
 * @param {Object} options
 * @return {Array}
 */
weavejs.path.WeavePathData.prototype.retrieveRecords = function(pathMapping, options) {
  var self = this;
  var /** @type {string} */ dataType = options ? options['dataType'] : null;
  var /** @type {weavejs.path.WeavePath} */ keySet = options ? options['keySet'] : null;
  if (!keySet && org.apache.flex.utils.Language.is(options, weavejs.path.WeavePath))
    keySet = org.apache.flex.utils.Language.as(options, weavejs.path.WeavePath);
  if (arguments.length == 1 && org.apache.flex.utils.Language.is(pathMapping, weavejs.path.WeavePath)) {
    keySet = org.apache.flex.utils.Language.as(pathMapping, weavejs.path.WeavePath);
    pathMapping = null;
  }
  if (!pathMapping)
    pathMapping = this.getNames();
  if (org.apache.flex.utils.Language.is(pathMapping, Array)) {
    var /** @type {Array} */ names = weavejs.Weave.toArray(pathMapping);
    pathMapping = {};
    for (var foreachiter0 in names) 
    {
    var name = names[foreachiter0];
    
      pathMapping[name] = this.push(name);}
    
  }
  var /** @type {Object} */ obj = this.listChainsAndPaths(pathMapping);
  var /** @type {Array} */ results = this.shared.joinColumns(obj.paths, dataType, true, keySet);
  return results[0].map(this.qkeyToString).map(function(key, iRow, a) {
    var /** @type {Object} */ record = {id:key};
    obj.chains.forEach(function(chain, iChain, a) {
      weavejs.path.WeavePathData.setChain(record, chain, results[iChain + 1][iRow]);
    });
    return record;
  });
};


/**
 * @asprivate
 * Walk down a property chain of a given object and set the value of the final node.
 * @asparam root The object to navigate through.
 * @asparam property_chain An array of property names defining a path.
 * @asparam value The value to which to set the final node.
 * @asreturn The value that was set, or the current value if no value was given.
 * @protected
 * @param {Object} root
 * @param {Array} property_chain
 * @param {*=} value
 * @return {*}
 */
weavejs.path.WeavePathData.setChain = function(root, property_chain, value) {
  value = typeof value !== 'undefined' ? value : undefined;
  property_chain = [].concat(property_chain);
  var /** @type {string} */ last_property = property_chain.pop();
  property_chain.forEach(function(prop, i, a) {
    root = root[prop] || (root[prop] = {});
  });
  if (value === undefined)
    return root[last_property];
  return root[last_property] = value;
};


/**
 * @asprivate
 * Walk down a property chain of a given object and return the final node.
 * @asparam root The object to navigate through.
 * @asparam property_chain An array of property names defining a path.
 * @asreturn The value of the final property in the chain.
 * @protected
 * @param {Object} root
 * @param {Array} property_chain
 * @return {*}
 */
weavejs.path.WeavePathData.getChain = function(root, property_chain) {
  return weavejs.path.WeavePathData.setChain(root, property_chain);
};


/**
 * @asprivate
 * Recursively builds a mapping of property chains to WeavePath objects from a path specification as used in retrieveRecords
 * @asparam obj A path spec object
 * @asparam prefix A property chain prefix (optional)
 * @asparam output Output object with "chains" and "paths" properties (optional)
 * @asreturn An object like {"chains": [], "paths": []}, where "chains" contains property name chains and "paths" contains WeavePath objects
 * @protected
 * @param {Object} obj
 * @param {Array=} prefix
 * @param {Object=} output
 * @return {Object}
 */
weavejs.path.WeavePathData.prototype.listChainsAndPaths = function(obj, prefix, output) {
  prefix = typeof prefix !== 'undefined' ? prefix : null;
  output = typeof output !== 'undefined' ? output : null;
  if (!prefix)
    prefix = [];
  if (!output)
    output = {chains:[], paths:[]};
  for (var /** @type {string} */ key in obj) {
    var /** @type {Object} */ item = obj[key];
    if (org.apache.flex.utils.Language.is(item, weavejs.path.WeavePath)) {
      if (this.shared.isColumn(item)) {
        output.chains.push(prefix.concat(key));
        output.paths.push(item);
      }
    } else {
      this.listChainsAndPaths(item, prefix.concat(key), output);
    }
  }
  return output;
};


/**
 * Sets a human-readable label for an ILinkableObject to be used in editors.
 * @asparam [relativePath] An optional Array (or multiple parameters) specifying child names relative to the current path.
 *                     A child index number may be used in place of a name in the path when its parent object is a LinkableHashMap.
 * @asparam {string} label The human-readable label for an ILinkableObject.
 * @asreturn {weave.WeavePath} The current WeavePath object.
 * @export
 * @param {...} relativePath_label
 * @return {weavejs.path.WeavePath}
 */
weavejs.path.WeavePathData.prototype.label = function(relativePath_label) {
  relativePath_label = Array.prototype.slice.call(arguments, 0);
  var /** @type {Array} */ args = weavejs.path.WeavePath._A(relativePath_label, 2);
  if (weavejs.path.WeavePath._assertParams('setLabel', args)) {
    var /** @type {string} */ label = args.pop();
    this.shared.setLabel(this.push(args), label);
  }
  return this;
};


/**
 * Gets the previously-stored human-readable label for an ILinkableObject.
 * @asparam [relativePath] An optional Array (or multiple parameters) specifying child names relative to the current path.
 *                     A child index number may be used in place of a name in the path when its parent object is a LinkableHashMap.
 * @asreturn {string} The human-readable label for an ILinkableObject.
 * @export
 * @param {...} relativePath
 * @return {string}
 */
weavejs.path.WeavePathData.prototype.getLabel = function(relativePath) {
  relativePath = Array.prototype.slice.call(arguments, 0);
  var /** @type {Array} */ args = weavejs.path.WeavePath._A(relativePath, 1);
  return this.shared.getLabel(this.push(args));
};


/**
 * Sets the metadata for a column at the current path.
 * @asparam {object} metadata The metadata identifying the column. The format depends on the data source.
 * @asparam {string} [dataSourceName] (Optional) The name of the data source in the session state.
 *                       If ommitted, the first data source in the session state will be used.
 * @asreturn {weave.WeavePath} The current WeavePath object.
 * @export
 * @param {Object} metadata
 * @param {string} dataSourceName
 * @return {weavejs.path.WeavePath}
 */
weavejs.path.WeavePathData.prototype.setColumn = function(metadata, dataSourceName) {
  var /** @type {string} */ type = this.getType();
  if (!type)
    this.request(type = weavejs.path.WeavePathDataShared.RC);
  else
    type = this.shared.getColumnType(this);
  if (!type)
    weavejs.path.WeavePath._failMessage('setColumn', 'Not a compatible column object', this._path);
  var /** @type {weavejs.path.WeavePath} */ path = this;
  if (type == weavejs.path.WeavePathDataShared.EDC)
    path = path.push('internalDynamicColumn', null).request(weavejs.path.WeavePathDataShared.RC);
  else if (type == weavejs.path.WeavePathDataShared.DC)
    path = path.push(null).request(weavejs.path.WeavePathDataShared.RC);
  path.state({"metadata":metadata, "dataSourceName":arguments.length > 1 ? dataSourceName : this.shared.getFirstDataSourceName()});
  return this;
};


/**
 * Sets the metadata for multiple columns that are children of the current path.
 * @asparam metadataMapping An object mapping child names (or indices) to column metadata.
 *                        An Array of column metadata objects may be given for a LinkableHashMap.
 * @asparam {string} [dataSourceName] The name of the data source in the session state.
 *                       If ommitted, the first data source in the session state will be used.
 * @asreturn {weave.WeavePath} The current WeavePath object.
 * @export
 * @param {*} metadataMapping
 * @param {*} dataSourceName
 * @return {weavejs.path.WeavePathData}
 */
weavejs.path.WeavePathData.prototype.setColumns = function(metadataMapping, dataSourceName) {
  var self = this;
  var /** @type {boolean} */ useDataSource = arguments.length > 1;
  this.forEach(metadataMapping, function(value, key, a) {
    var /** @type {weavejs.path.WeavePathData} */ path = org.apache.flex.utils.Language.as(this.push(key), weavejs.path.WeavePathData);
    var /** @type {Function} */ func = org.apache.flex.utils.Language.is(value, Array) ? org.apache.flex.utils.Language.closure(path.setColumns, path, 'setColumns') : org.apache.flex.utils.Language.closure(path.setColumn, path, 'setColumn');
    var /** @type {Array} */ args = useDataSource ? [value, dataSourceName] : [value];
    func.apply(path, args);
  });
  if (org.apache.flex.utils.Language.is(metadataMapping, Array))
    while (this.getType(metadataMapping.length))
      this.remove(metadataMapping.length);
  return this;
};


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
weavejs.path.WeavePathData.prototype.FLEXJS_CLASS_INFO = { names: [{ name: 'WeavePathData', qName: 'weavejs.path.WeavePathData'}] };
