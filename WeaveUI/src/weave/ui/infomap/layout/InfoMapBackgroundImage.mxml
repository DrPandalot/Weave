<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas xmlns:mx="http://www.adobe.com/2006/mxml"
		   xmlns:ui="weave.ui.infomap.ui.*"
		   width="150" height="150" autoLayout="false" cacheAsBitmap="false" clipContent="false"
		   creationPolicy="all" horizontalScrollPolicy="off"
		   implements="weave.api.core.ILinkableObject" mouseDown="dragStartHandler(event)"
		   mouseUp="dragStopHandler(event)" resize="adjustImageResize(event)"
		   rollOut="rollOutHandler(event)" rollOver="rollOverHandler(event)"
		   verticalScrollPolicy="off">
	<mx:Script>
		<![CDATA[
			import mx.events.ResizeEvent;
			import mx.utils.Base64Decoder;
			
			import weave.api.linkBindableProperty;
			import weave.api.newLinkableChild;
			import weave.api.registerLinkableChild;
			import weave.api.reportError;
			import weave.compiler.StandardLib;
			import weave.core.LinkableBoolean;
			import weave.core.LinkableNumber;
			import weave.core.LinkableString;
			import weave.ui.DraggablePanel;
			import weave.utils.BitmapUtils;
			import weave.utils.CustomCursorManager;
			import weave.visualization.layers.InteractiveVisualization;
			
			//Sessioned variables for the component.
			public const imageName:LinkableString = newLinkableChild(this, LinkableString);
			public const imageString:LinkableString = newLinkableChild(this, LinkableString, handleImageString, true);
			public const isStringURL:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(false));
			public const xPos:LinkableNumber = newLinkableChild(this,LinkableNumber);
			public const yPos:LinkableNumber = newLinkableChild(this,LinkableNumber);
			public const imageWidth:LinkableNumber = registerLinkableChild(this,new LinkableNumber(150));
			public const imageHeight:LinkableNumber = registerLinkableChild(this,new LinkableNumber(150));
			
			//Variables for handling image data, not sessioned.
			private var theImage:Bitmap = new Bitmap();
			private var decoder:Base64Decoder = new Base64Decoder();
			private var bitmapLoader:Loader = null;
			private var handCursorID:int = -1;
			private var storedBitmapData:BitmapData = null;
			
			//Resize and dragging variables.
			private var _rightSideResize:Boolean = false;
			private var _leftSideResize:Boolean = false;
			private var _topSideResize:Boolean = false;
			private var _bottomResize:Boolean = false;
			private var _resizing:Boolean = false;
			private var _dragging:Boolean = false;
			private var _rightSideBeforeLeftResize:int = 0;
			private var _bottomSideBeforeTopResize:int = 0;
			private var _mouseRolledOver:Boolean = false;
			
			//This is a static constant for determining side buffers of the image.
			private static var _resizeSideBuffer:int = 5;
			
			//we override the x,y value because we are binding the values to LinkableNumber 
			//which could be NaN when component loads for the first time
			override public function set x(value:Number):void
			{
				if(parent)
					super.x = isNaN(value)?parent.width/2:value;
				else
					super.x=value;
			}
			
			override public function set y(value:Number):void
			{
				if(parent)
					super.y = isNaN(value)?parent.height/2:value;
				else
					super.y=value;
			}
			
			override protected function childrenCreated():void
			{
				super.childrenCreated();
				
				//Link all of the canvas properties that should be saved for proper image placing upon loading up a session state.
				linkBindableProperty(xPos,this,"x");
				linkBindableProperty(yPos,this,"y");
				linkBindableProperty(imageWidth,this,"width");
				linkBindableProperty(imageHeight,this,"height");
				//Mouse listener to handle the resizing.
				stage.addEventListener(MouseEvent.MOUSE_MOVE, handleStageMouseMove);
			}
			
			/** 
			 * This is a callback function for loading image data from a URL or base64 encoded string.
			 */
			private function handleImageString():void
			{
				if( imageString.value != null )
				{
					bitmapLoader = new Loader();
					if( !isStringURL.value )
					{
						//Decode the base64 encoded string to bitmap data.
						decoder.reset(); //Make sure the decoder buffer is cleared. The decoder method flush() does not reset the decoder like it does for the encoder.
						decoder.decode(imageString.value);
						bitmapLoader.loadBytes(decoder.flush());
						bitmapLoader.contentLoaderInfo.addEventListener(Event.COMPLETE, loaderComplete);
					}
					else
					{
						//Fetch the image.
						bitmapLoader.load(new URLRequest("infomap_images/"+imageName.value));
						bitmapLoader.contentLoaderInfo.addEventListener(Event.COMPLETE, loaderComplete);
					}
				}
			}
			
			/**
			 * A function for handling loaded BitmapData and drawing it onto the canvas.
			 */
			private function loaderComplete(event:Event):void
			{
				var loaderInfo:LoaderInfo = LoaderInfo(event.target);
				var imgBitMap:Bitmap = Bitmap(loaderInfo.content);
				
				//Save the data to a storedBitmapData variable for easy image resizing.
				storedBitmapData = imgBitMap.bitmapData;
				
				this.height = imgBitMap.bitmapData.height;
				this.width = imgBitMap.bitmapData.width;
				BitmapUtils.drawCenteredIcon(this.graphics,this.width/2,this.height/2,imgBitMap.bitmapData);
			}
			
			/**
			 * Handler function for when the mouse is released while on the component.
			 */
			protected function dragStopHandler(event:MouseEvent):void
			{
				//If mouse is released any type of dragging or resizing operation is finished.
				CustomCursorManager.removeCursor(handCursorID);
				this.stopDrag();
				_dragging = false;
				_resizing = false;
			}
			
			/**
			 * Handler function for when the mouse is pressed down while over the component.
			 */
			private function dragStartHandler(event:MouseEvent):void
			{	
				//Reset all resize status variables before computing status.
				_leftSideResize = false;
				_rightSideResize = false;
				_topSideResize = false;
				_bottomResize = false;				
				var status:Object = getResizeStatus(stage.mouseX, stage.mouseY);
				
				//assign boolean values based on which side is being resized.
				if (status.R)
					_rightSideResize = true;
				else if (status.L)
				{
					_rightSideBeforeLeftResize = this.x + this.width;
					_leftSideResize = true;
				}
				
				
				if (status.B)
					_bottomResize = true;
				else if (status.T)
				{
					_bottomSideBeforeTopResize = this.y + this.height;
					_topSideResize = true;
				}
				
				if (getResizeStatus(stage.mouseX, stage.mouseY).resizing)
				{
					//Resizing.
					_resizing = true;
					event.stopImmediatePropagation();
				}
				else
				{
					//Dragging.
					_resizing = false;
					_dragging = true;
					handCursorID = CustomCursorManager.showCursor(InteractiveVisualization.CURSOR_HAND_GRAB);
					this.startDrag();
				}
				event.stopImmediatePropagation();
			}
			
			/**
			 * getResizeStatus
			 * Returns a set of Boolean values corresponding to which sides (top,left,bottom,right) should be resized.
			 * @param stageX The current stage X mouse coordinate.
			 * @param stageY The current stage Y mouse coordinate.
			 * @return An object containing the following properties: T,L,B,R,TL,TR,BL,BR,resizing
			 */
			private function getResizeStatus(stageX:Number, stageY:Number):Object
			{
				var local:Point = globalToLocal(new Point(stageX, stageY));
				var o:Object = new Object();
				
				// get side status values
				o.L = local.x <= _resizeSideBuffer;
				o.R = local.x >= this.width - _resizeSideBuffer;
				o.T = local.y <= _resizeSideBuffer;
				o.B = local.y >= this.height - _resizeSideBuffer;
				
				// get side status values for 4x the border thickness (to mimic Windows' corner resize behavior)
				var L4:Boolean = local.x <= _resizeSideBuffer * 4;
				var R4:Boolean = local.x >= this.width - _resizeSideBuffer * 4;
				var T4:Boolean = local.y <= _resizeSideBuffer * 4;
				var B4:Boolean = local.y >= this.height - _resizeSideBuffer * 4;
				// corner status is true if mouse is within a square of 4x the border thickness and at least one corresponding side status is true
				o.TL = (T4 && L4) && (o.T || o.L);
				o.TR = (T4 && R4) && (o.T || o.R);
				o.BL = (B4 && L4) && (o.B || o.L);
				o.BR = (B4 && R4) && (o.B || o.R);
				// status for individual sides should be or'd with relevant corner status values
				o.T |= o.TL || o.TR;
				o.L |= o.TL || o.BL;
				o.B |= o.BL || o.BR;
				o.R |= o.TR || o.BR;
				
				// not resizing when coordinates are outside the window
				if (!_mouseRolledOver)
					o.T = o.TL = o.L = o.BL = o.B = o.BR = o.R = o.TR = false;
				
				// we are resizing if we are in the resize area for the top, left, bottom or right
				o.resizing = (o.T || o.L || o.B || o.R);
				
				return o;
			}
			
			/**
			 * Handler function for when the mouse rolls over the component.
			 */
			protected function rollOverHandler(event:MouseEvent):void
			{
				//Keep track of the fact that the mouse is hovering over the component.
				_mouseRolledOver = true;
				
				if (_resizing)
					event.stopImmediatePropagation();
			}
			
			/**
			 * Handler function for when the mouse rolls off of the component.
			 */
			protected function rollOutHandler(event:MouseEvent):void
			{				
				_mouseRolledOver = false;
				
				if (_resizing && event.buttonDown)
					event.stopImmediatePropagation();
				else
					CustomCursorManager.removeCursor(handCursorID);
			}
			
			/**
			 * Handler function that is added to the stage to track mouse movements for the purpose of resizing.
			 */
			private function handleStageMouseMove(event:MouseEvent):void
			{
				//If dragging is occurring this function doesn't need to do any work.
				if ( _dragging )
				{
					event.stopImmediatePropagation();
					return;
				}
				
				//If the mouse button isn't being held down, then resizing can't be occurring.
				if( !event.buttonDown )
					_resizing = false;
				
				// make sure cursors dont keep changing while resizing:  !_resizing
				if (parent && !_resizing && _mouseRolledOver)
				{
					var status:Object = getResizeStatus(stage.mouseX, stage.mouseY);
					var resizeCursorName:String = null;
					if (status.TL || status.BR)
						resizeCursorName = DraggablePanel.CURSOR_RESIZE_TOPLEFT_BOTTOMRIGHT;
						// check to see if the mouse is in the top right (TR) or bottom left (BL) corner
					else if (status.TR || status.BL)
						resizeCursorName = DraggablePanel.CURSOR_RESIZE_TOPRIGHT_BOTTOMLEFT;
						// check to see if the mouse is on the left or right side (LR)
					else if (status.L || status.R)
						resizeCursorName = DraggablePanel.CURSOR_RESIZE_LEFT_RIGHT;
						// check to see if the mouse is on the top or bottom side
					else if (status.T || status.B)
						resizeCursorName = DraggablePanel.CURSOR_RESIZE_TOP_BOTTOM;
					
					CustomCursorManager.removeCursor(handCursorID);
					//Apply cursor change.
					if ( resizeCursorName!= null && !event.buttonDown)
					{						
						try
						{
							handCursorID = CustomCursorManager.showCursor(resizeCursorName);
						}
						catch (e:Error)
						{
							handCursorID = -1;
							reportError(e);
						}
					}
				}
				else
					CustomCursorManager.removeCursor(handCursorID);
				
				if ( _resizing )
				{
					event.stopImmediatePropagation();
					handleThrottledMouseMove(event);
				}
			}
			
			/**
			 * A function that deals with handling the resizing of the component. Called by handleStageMouseMovement.
			 */
			private function handleThrottledMouseMove(event:MouseEvent):void
			{
				//Some initial cases to make sure the component is in a state that we want it to be.
				if( parent == null )
					return;
				
				if(!event.buttonDown)
					return;
				
				var parentMousePoint:Point = new Point(parent.mouseX, parent.mouseY);
				
				//Handle the resizing.
				if (_resizing)
				{
					if (_rightSideResize)
					{
						this.width = StandardLib.constrain( (parentMousePoint.x - this.x), minWidth, (parent.width - this.x) );
					}
					else if (_leftSideResize)
					{
						this.x = StandardLib.constrain( (parentMousePoint.x), 0, _rightSideBeforeLeftResize - minWidth );
						this.width = (_rightSideBeforeLeftResize - this.x);
					}
					if (_bottomResize)
					{
						this.height = StandardLib.constrain( (parentMousePoint.y - this.y), minHeight, (parent.height - this.y) );
					}
					else if (_topSideResize)
					{
						this.y = StandardLib.constrain( (parentMousePoint.y), 0, _bottomSideBeforeTopResize - minHeight );
						this.height = (_bottomSideBeforeTopResize - this.y);
					}
				}
			}
			
			//Re-usable variable for scaling the image as it is resized.
			private var scaledBitmapData:BitmapData = null;
			protected function adjustImageResize(event:ResizeEvent):void
			{
				//Ensure that the initial bitmap data has been loaded and that the canvas is fully initialized.
				if(storedBitmapData != null && this.width != 0 && this.height != 0)
				{
					this.graphics.clear();
					scaledBitmapData = BitmapUtils.resizeBitmapData(storedBitmapData,this.width, this.height);
					//Could use BitmapUtils.drawCenteredIcon() here if we always wanted image scale to be maintained.
					graphics.beginBitmapFill(scaledBitmapData, null, false, true);
					graphics.drawRect(0, 0, this.width, this.height);
					graphics.endFill();
				}
			}
			
		]]>
	</mx:Script>
</mx:Canvas>
