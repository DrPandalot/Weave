<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas xmlns:mx="http://www.adobe.com/2006/mxml" horizontalScrollPolicy="off" verticalScrollPolicy="off"
		   implements="weave.api.core.ILinkableObject"
		   cacheAsBitmap="false"
		   clipContent="false"
		   autoLayout="false"
		   >
	<mx:Glow id="selectedBorder" 
			 alphaFrom="1.0" alphaTo="1.0"   
			 blurXFrom="10.0" blurYFrom="10.0" 
			 blurXTo="10.0" blurYTo="10.0"
			 duration="0" target="{nodeBase}"/>
	<mx:Glow id="unselectedBorder" 
			 alphaFrom="0.0" alphaTo="1.0"   
			 blurXFrom="10.0" blurYFrom="10.0" 
			 blurXTo="10.0" blurYTo="10.0"
			 duration="0" target="{nodeBase}"/>	
	<mx:Script>
		<![CDATA[
			import flash.events.MouseEvent;
			import flash.geom.Point;
			import flash.net.URLRequest;
			import flash.net.navigateToURL;
			import flash.utils.Dictionary;
			
			import mx.collections.ArrayCollection;
			import mx.controls.Alert;
			import mx.controls.Image;
			import mx.controls.Label;
			import mx.controls.Text;
			import mx.controls.TextArea;
			import mx.events.CloseEvent;
			import mx.events.FlexEvent;
			import mx.managers.CursorManager;
			import mx.managers.PopUpManager;
			import mx.managers.PopUpManagerChildList;
			import mx.rpc.events.FaultEvent;
			import mx.rpc.events.ResultEvent;
			
			import weave.Weave;
			import weave.api.WeaveAPI;
			import weave.api.core.ILinkableHashMap;
			import weave.api.core.ILinkableObject;
			import weave.api.data.IAttributeColumn;
			import weave.api.data.IQualifiedKey;
			import weave.api.detectLinkableObjectChange;
			import weave.api.disposeObjects;
			import weave.api.getCallbackCollection;
			import weave.api.getLinkableOwner;
			import weave.api.linkBindableProperty;
			import weave.api.linkSessionState;
			import weave.api.newLinkableChild;
			import weave.api.registerLinkableChild;
			import weave.core.LinkableDynamicObject;
			import weave.core.LinkableHashMap;
			import weave.core.LinkableNumber;
			import weave.core.LinkableString;
			import weave.core.SessionStateLog;
			import weave.core.StageUtils;
			import weave.core.UIUtils;
			import weave.data.AttributeColumns.ReferencedColumn;
			import weave.data.CSVParser;
			import weave.data.ColumnReferences.HierarchyColumnReference;
			import weave.data.DataSources.InfoMapsDataSource;
			import weave.data.KeySets.KeyFilter;
			import weave.data.KeySets.KeySet;
			import weave.data.QKeyManager;
			import weave.primitives.DateRangeFilter;
			import weave.ui.infomap.core.FilterableInfoMapNode;
			import weave.ui.infomap.core.InfoMapDocument;
			import weave.ui.infomap.core.InfoMapNode;
			import weave.ui.infomap.core.SelectableInfoMapDocument;
			import weave.ui.infomap.ui.DateFilterComponent;
			import weave.ui.infomap.ui.DocThumbnailComponent;
			import weave.ui.infomap.ui.InfoMapPanel;
			import weave.ui.infomap.ui.NodeBaseComponent;
			import weave.ui.infomap.ui.NodeSettingsComponent;
			import weave.utils.BitmapUtils;
			import weave.utils.ColumnUtils;
			import weave.utils.CustomCursorManager;
			import weave.utils.DateUtils;
			
			public const node:FilterableInfoMapNode = newLinkableChild(this,FilterableInfoMapNode);
			
			public const xPos:LinkableNumber = newLinkableChild(this,LinkableNumber);
			public const yPos:LinkableNumber = newLinkableChild(this,LinkableNumber);
			
			public const layout:LinkableDynamicObject = newLinkableChild(this,LinkableDynamicObject,handleLayoutChange);
			
			public const thumbnails:LinkableHashMap = newLinkableChild(this,LinkableHashMap);
			
			public const defaultBorderColor:LinkableNumber = registerLinkableChild(this,new LinkableNumber(13421772),highlightNode,true);
			
			public const selectedBorderColor:LinkableNumber = registerLinkableChild(this,new LinkableNumber(39168),highlightNode,true);
			
			public const defaultThumbnailBorderColor:LinkableNumber = registerLinkableChild(this,new LinkableNumber(000000));
			
			public const selectedThumbnailBorderColor:LinkableNumber = registerLinkableChild(this,new LinkableNumber(16711680));
			
			public const newThumbnailGlowColor:LinkableNumber = registerLinkableChild(this,new LinkableNumber(3407820));
			/**
			 * @public 
			 * A search filter to search within documents handled by this node. 
			 * */ 
			public const searchFilter:LinkableString = newLinkableChild(this,LinkableString);
			
			private var loader:URLLoader = null;
			
			//we override the x,y value because we are binding the values to LinkableNumber 
			//which could be NaN when component loads for the first time
			override public function set x(value:Number):void
			{
				if(parent)
					super.x = isNaN(value)?parent.width/2:value;
				else
					super.x=value
			}
			
			override public function set y(value:Number):void
			{
				if(parent)
					super.y = isNaN(value)?parent.height/2:value;
				else
					super.y=value
						
			}
			
			private var _parentPanel:InfoMapPanel;
			private var _subset:KeyFilter = Weave.root.getObject(Weave.DEFAULT_SUBSET_KEYFILTER) as KeyFilter;
			
			
			
			override protected function createChildren():void
			{

				super.createChildren();
				this.addChild(nodeBase);
			}
			
//			private var log:SessionStateLog = new SessionStateLog(thumbnails);
			
			override protected function childrenCreated():void
			{
				
								
				super.childrenCreated();
								
				//TODO: color property is not bindable to use callbakc function to set the colorproperty
//				linkBindableProperty(defaultBorderColor,unselectedBorder,"color");
//				linkBindableProperty(selectedBorderColor,selectedBorder,"color");
				
				node.keywords.addGroupedCallback(this,createAndSendQuery);
				node.operator.addGroupedCallback(this,createAndSendQuery);
				node.numberOfDocs.addGroupedCallback(this,createAndSendQuery);
				node.dateFilter.startDate.addGroupedCallback(this,createAndSendQuery);
				node.dateFilter.endDate.addGroupedCallback(this,createAndSendQuery);
				node.sources.addGroupedCallback(this,createAndSendQuery);
				//if node is selected we highlight the nodeBase
				node.selected.addGroupedCallback(this,highlightNode);
				
				//for now defaulting to Grid Layout
				
				if(layout.internalObject == null)
					layout.requestLocalObject(GridLayout,false);
				
				(layout.internalObject as IInfoMapNodeLayout).parentNodeHandler = this;
				
				
				nodeBase.settingsImg.addEventListener(MouseEvent.CLICK,settings);
				nodeBase.closeImg.addEventListener(MouseEvent.CLICK,close);
				
				//drag and drop of the node will be use the text area as the handler/anchor point
				nodeBase.keywordTextArea.addEventListener(MouseEvent.MOUSE_DOWN,canvas1_mouseDownHandler);
				nodeBase.keywordTextArea.addEventListener(MouseEvent.MOUSE_UP,canvas1_mouseUpHandler);
				
				
				(layout.internalObject as IInfoMapNodeLayout).drawBaseLayout(graphics);
				
				//sessioning the x and y positions of this node
				linkBindableProperty(xPos,this,"x");
				linkBindableProperty(yPos,this,"y");
				
				
//				UIUtils.linkDisplayObjects(this,thumbnails,true);
				
				//sets a pointer to the node's parent which is an InfoMapPanel
				var hashmap:LinkableHashMap = WeaveAPI.SessionManager.getLinkableOwner(this) as LinkableHashMap;
				_parentPanel = WeaveAPI.SessionManager.getLinkableOwner(hashmap) as InfoMapPanel;
				
				_parentPanel.globalSearchKeyword.addImmediateCallback(this,handleGlobalSearch);
				
				_parentPanel.globalDateFilter.startDate.addGroupedCallback(this,handleGlobalDateChange);
				_parentPanel.globalDateFilter.endDate.addGroupedCallback(this,handleGlobalDateChange);
				
				
				nodeBase.keywordTextArea.addEventListener(MouseEvent.CLICK,handleClick);
				
				getCallbackCollection(_subset).addGroupedCallback(this,handleSubsetChange);
				
				highlightNode();
				
				//we want to trigger the callback for thumbnails at each frame and check the trigger counter
				getCallbackCollection(this).addImmediateCallback(this,invalidateDisplayList);
				createAndSendQuery(false);
				
				docKeySet.addGroupedCallback(this,handleParsedResult,true);
				
				_searchKeySet.addGroupedCallback(this,handleSearchKeySetChange,true);
				
				_selection.addGroupedCallback(this,handleSelectionKeySetChange,true);
				
//				getCallbackCollection(_parentPanel.infoMapsDataSource).addGroupedCallback(this,handleSubsetChange,true);
			}
			
			//this variable is false when the user loads the map for the first time. 			
			private var highlightNewDocuments:Boolean = false;
			public function checkForNewDocuments():void
			{
//				highlightNewDocuments = true;
				createAndSendQuery(false);
			}
		
				
			[Bindable]
			public var nodeBase:NodeBaseComponent = new NodeBaseComponent();
			
			private var docKeySet:KeySet = new KeySet();
			
			/**
			 * @private
			 * This functions creates a query based on the keywords,operator and filters applied and sends a request to the Solr server
			 **/
			private function createAndSendQuery(clearDocuments:Boolean=true):void
			{
				if(!node.keywords.value)
					return;
				
				if(clearDocuments)
					thumbnails.removeAllObjects();
				
				nodeBase.keywordTextArea.text = node.keywords.value;
				nodeBase.keywordTextArea.toolTip = node.keywords.value;
				
				if (this.parent == null)
				{
					WeaveAPI.StageUtils.callLater(this,createAndSendQuery,[clearDocuments]);
					return;
				}
				
				if(!node.sources.value == '')
				{
					var sourceNames:Array = parser.parseCSV(node.sources.value)[0]; //we send only the first row since this is a one-line CSV String
				}
				
				_parentPanel.infoMapsDataSource.getDocumentsForQuery(docKeySet,node.keywords.value,node.operator.value,sourceNames,node.dateFilter);
				
			}
			
			private var thumbnailSize:int = 50;
			
			private var parser:CSVParser = new CSVParser();
			
//			public var titleColTest:IAttributeColumn = null;
			
			/**
			 * @private
			 * This function takes an array collection of links and requests a thumbnail object to display the document object
			 * for each of the corresponding links.
			 * If the thumbnail object is already there then we use the replace its doc object with the latest doc object. 
			 **/
			private function handleParsedResult():void
			{
				if(thumbnails.getObjects().length == 0)
				{
					highlightNewDocuments = false;
				}else{
					highlightNewDocuments = true;
				}
				
				var obj:SelectableInfoMapDocument;
				thumbnails.delayCallbacks();
				var response:Array = docKeySet.keys;
				for(var i:int; i<response.length ;i++)
				{
					
					var link:String = (response[i] as IQualifiedKey).localName;					
					
					var thumbnail:DocThumbnailComponent = new DocThumbnailComponent();
					
					
					//if the thumbnail already exists use previous x,y values
					if(thumbnails.getObject(link))
					{
						thumbnail = thumbnails.requestObject(link,DocThumbnailComponent,false);
						
						//we replace the doc object because, the summary, description might have changed. 
//						thumbnail.doc = obj as SelectableInfoMapDocument;
						
						linkSessionState(defaultThumbnailBorderColor,thumbnail.defaultBorderColor);
						linkSessionState(selectedThumbnailBorderColor,thumbnail.selectedBorderColor);
						linkSessionState(newThumbnailGlowColor,thumbnail.glowColor);
						
						continue;
					}
					thumbnail = thumbnails.requestObject(link,DocThumbnailComponent,false);
					
					addChild(thumbnail);
					
					thumbnail.docURL.value = link;
					
					linkSessionState(defaultThumbnailBorderColor,thumbnail.defaultBorderColor);
					linkSessionState(selectedThumbnailBorderColor,thumbnail.selectedBorderColor);
					linkSessionState(newThumbnailGlowColor,thumbnail.glowColor);
					
					
					if(highlightNewDocuments)
					{
						thumbnail.startGlow();
					}
					
				}
				
				thumbnails.resumeCallbacks();			
				handleSubsetChange();
			}
			
			override public function validateDisplayList():void
			{
				super.validateDisplayList();
//				This was added before using InfoMapsDataSource. This might not be needed
//				TODO: delete later if not required
//				if(detectLinkableObjectChange(validateDisplayList,thumbnails))
//					handleSubsetChange();
				
			}
			
			private var thumbnailsToPlotArray:Array = [];
			private function handleSubsetChange():void
			{
				thumbnailsToPlotArray = [];
				
				//add all thumbanils to dictionary and set it all to false
				for each(var t:DocThumbnailComponent in thumbnails.getObjects())
				{
					var docURL:String = thumbnails.getName(t);
					var qKey:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,docURL);
					if(_subset.containsKey(qKey))
					{
						thumbnailsToPlotArray.push(t);
						t.visible = true;
//						addChild(t);
					}else{
						
						t.visible = false;
					}
					
				}
				(layout.internalObject as IInfoMapNodeLayout).plotThumbnails(thumbnailsToPlotArray);
				handleSelectionKeySetChange();
				handleGlobalSearch();
			}
			
			private var _selection:KeySet = Weave.root.getObject(Weave.DEFAULT_SELECTION_KEYSET) as KeySet;
			
			private function handleSelectionKeySetChange():void
			{
				var docs:Array = thumbnails.getNames();
				
				for each(var doc:String in docs)
				{
					var qKey:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,doc);
					var t:DocThumbnailComponent = thumbnails.getObject(doc) as DocThumbnailComponent;
					var selected:Boolean =_selection.containsKey(qKey) 
					t.highlight(selected);
				}
			}
			
			
			private function handleLayoutChange():void
			{
				if(layout.internalObject == null)
					return;
				(layout.internalObject as IInfoMapNodeLayout).parentNodeHandler = this;
				(layout.internalObject as IInfoMapNodeLayout).drawBaseLayout(graphics);
				(layout.internalObject as IInfoMapNodeLayout).plotThumbnails(thumbnailsToPlotArray);
			}
			
			
			//toggle node selection on click
			private function handleClick(event:Event):void
			{
				if(wasDragged)
				{
					wasDragged = false;
					return;
				}
				if(node.selected.value)
					node.selected.value = false;
				else
					node.selected.value = true;
			}
			
			//highlight node based on node.selected.value
			private function highlightNode():void
			{
				unselectedBorder.color = defaultBorderColor.value;
				selectedBorder.color = selectedBorderColor.value;
				
				if(node.selected.value)
					selectedBorder.play();
				else
					unselectedBorder.play();
			}
			
			//this variable will be  used to avoid selection/unselection when the node is dragged
			private var wasDragged:Boolean = false;
			protected function canvas1_mouseDownHandler(event:MouseEvent):void
			{
				event.stopImmediatePropagation();
				applyKeywords();
				nodeBase.keywordTextArea.setStyle("fontWeight","bold");
				CustomCursorManager.showCursor(CustomCursorManager.HAND_GRAB_CURSOR);
				this.startDrag();
				this.addEventListener(MouseEvent.MOUSE_MOVE,handleMouseMove);
			}
			
			private function handleMouseMove(event:Event):void
			{
				wasDragged = true;
			}
			
			protected function canvas1_mouseUpHandler(event:MouseEvent):void
			{
				nodeBase.keywordTextArea.setStyle("fontWeight","normal");
				CustomCursorManager.removeCurrentCursor();
				this.stopDrag();
				this.removeEventListener(MouseEvent.MOUSE_MOVE,handleMouseMove);
			}
			
			
			
			private function handleKeywordChange(event:KeyboardEvent):void
			{
				if(event.keyCode == Keyboard.ENTER)
				{
					event.preventDefault();
					applyKeywords();
				}
			}
			
			
			private function applyKeywords():void
			{
				// we take the focus back from the keyword text area and assign it back to the node handler
				stage.focus = this;
				nodeBase.keywordTextArea.editable = false;
				nodeBase.keywordTextArea.selectable = false;
				node.keywords.value = nodeBase.keywordTextArea.text;
				toggleEdit = false;
			}
			
			
			
			
			private function filter(event:Event):void
			{
				DateFilterComponent.openInstance(this,node.dateFilter);
			}

			private var _instance:NodeSettingsComponent = null;
			private function settings(event:Event):void
			{
				
				if(_instance)
				{
					PopUpManager.addPopUp(_instance,this);
				}
				else
				{
					_instance = new NodeSettingsComponent();
					_instance.nodeHandler = this;
					PopUpManager.addPopUp(_instance,this);
				}
			}
			
			private function close(event:Event):void
			{
				Alert.show("Are you sure you want to remove this node?",
							 "Remove Node?",
							 Alert.YES | Alert.NO,
							 null,
							 handleCloseEvent
							 );
			}
			
			private function handleCloseEvent(e:CloseEvent):void
			{
					if(e.detail == Alert.YES)
					{
						thumbnails.removeAllObjects();
						var parent:ILinkableHashMap = (WeaveAPI.SessionManager.getLinkableOwner(this) as ILinkableHashMap);
						var nodeName:String  = parent.getName(this);
						parent.removeObject(nodeName);
					}
					else if(e.detail == Alert.NO)
					{
						return;
					}
			}			
			private var toggleEdit:Boolean = false;
			private function edit(event:Event):void
			{
				if(toggleEdit)
				{
					toggleEdit = false;
					stage.focus = this;
					nodeBase.keywordTextArea.editable = false;
					nodeBase.keywordTextArea.selectable = false;
					return;
				}
				
				toggleEdit = true;
				nodeBase.keywordTextArea.editable = true;
				nodeBase.keywordTextArea.selectable = true;
				nodeBase.keywordTextArea.addEventListener(KeyboardEvent.KEY_DOWN,handleKeywordChange,true);
				nodeBase.keywordTextArea.setSelection(nodeBase.keywordTextArea.text.length,nodeBase.keywordTextArea.text.length);
				nodeBase.keywordTextArea.setFocus();
			}
			
			
			private function remove(event:Event):void //doesn't work if you decalre this as Mouse Event. 
			{
				thumbnails.removeAllObjects();
				var parent:ILinkableHashMap = (WeaveAPI.SessionManager.getLinkableOwner(this) as ILinkableHashMap);
				var nodeName:String  = parent.getName(this);
				parent.removeObject(nodeName);
			}
			
			private var searchText:TextArea = new TextArea();
			
			//this flag is used to toggle the search text area. 
			private var toggleSearch:Boolean = false;
			private function search(event:Event):void
			{
				if(toggleSearch)
				{
					this.removeChild(searchText);
					toggleSearch = false;
					return;
				}
				toggleSearch = true;
				searchText.x = (event.currentTarget as Image).x + 20;
				searchText.y = (event.currentTarget as Image).y - 10;
				searchText.width = 100;
				searchText.height = 20;
				searchText.addEventListener(KeyboardEvent.KEY_UP,handleSearch);
				searchText.text = searchFilter.value;
				searchText.toolTip = 'Hit Enter or Esc to close this text box';
				this.addChild(searchText);
				searchText.setFocus();
			}
			
			
			private function handleSearch(event:KeyboardEvent):void
			{
					if(event.keyCode == Keyboard.ENTER  || event.keyCode == Keyboard.ESCAPE)
					{
						this.removeChild(searchText);
						toggleSearch = false;
						return;
					}
					searchFilter.value = searchText.text;
			}
			
			private var _searchKeySet:KeySet = new KeySet();
			private function handleGlobalSearch():void
			{
				
				if(!_parentPanel.globalSearchKeyword.value)
				{
					_searchKeySet.clearKeys();
					return;
				}
				
				var fieldNames:Array = ['link'];
				
				var fieldValues:Array = [];
				
				fieldValues.push(thumbnails.getNames());
				
				if(!node.sources.value == '')
				{
					var sourceNames:Array = parser.parseCSV(node.sources.value)[0]; //we send only the first row since this is a one-line CSV String
				}
				
				
				_parentPanel.infoMapsDataSource.getDocumentsForQueryWithFieldValues(_searchKeySet,_parentPanel.globalSearchKeyword.value,fieldNames,fieldValues,sourceNames,"OR",node.dateFilter);
				
			}
			
			private function handleSearchKeySetChange():void
			{
				var tnails:Array = thumbnails.getObjects();
				
				var searchMatchedKeys:Array =_searchKeySet.keys; 
				
				if(searchMatchedKeys.length == 0)
				{
					for each(var t1:DocThumbnailComponent in tnails)
					{
						t1.visible = true;
					}
				}else
				{
					for each(var t2:DocThumbnailComponent in tnails)
					{
						t2.visible = false;
					}
				}
				
				for each(var k:IQualifiedKey in searchMatchedKeys)
				{
					var t3:DocThumbnailComponent = thumbnails.getObject(k.localName) as DocThumbnailComponent;
					
					if(t3)
						t3.visible = true;
				}
				
			}
			
			private function handleGlobalDateChange():void
			{
				if(node.selected.value)
				{
					node.dateFilter.startDate.value = _parentPanel.globalDateFilter.startDate.value;
					node.dateFilter.endDate.value = _parentPanel.globalDateFilter.endDate.value;
				}
			}
			private function removeEmptyStringElementsFromArray(arg:Array):Array
			{
				var result:Array = [];
				for each(var item:String in arg)
				{
					if(item != "")
						result.push(item);
				}
				
				return result;
			}
			
			
		]]>
	</mx:Script>
	
</mx:Canvas>
