<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas xmlns:mx="http://www.adobe.com/2006/mxml" horizontalScrollPolicy="off" verticalScrollPolicy="off"
		   implements="weave.api.core.ILinkableObject"
		   cacheAsBitmap="false"
		   clipContent="false"
		   autoLayout="false"
		   >
	<!--Show this status box only when list is visible-->
	<mx:Label id="status" x="{nodeBase.keywordTextArea.width}" y="{nodeBase.keywordTextArea.height}" width="300"/>
	<mx:HBox horizontalAlign="left" id="statusBox" y="{nodeBase.height}" width="400" includeInLayout="false">
		<mx:Label id="filterStatus"/>
		<mx:Button focusAlpha="0" id="clearFiltersButton" label="Clear" visible="false" click="handleClearFiltersButton()"/>
		<!--HTML encoding is requried when writing code in binding tag-->
		<!--<mx:Button enabled="false" label="Mark All as Read" visible="false" id="clearNewDocuments" height="100%" click="clearAllNewDocuments()"/>-->
	</mx:HBox>
	<mx:Canvas id="pointsCanvas" enabled="false" visible="false" clipContent="false" width="400" height="300"/>
	<mx:Canvas id="listCanvas" visible="false" clipContent="false" width="400" height="300"/>
	<mx:Glow id="selectedBorder" 
			 alphaFrom="1.0" alphaTo="1.0"   
			 blurXFrom="10.0" blurYFrom="10.0" 
			 blurXTo="10.0" blurYTo="10.0"
			 duration="0" target="{nodeBase}"/>
	<mx:Glow id="unselectedBorder" 
			 alphaFrom="0.0" alphaTo="1.0"   
			 blurXFrom="10.0" blurYFrom="10.0" 
			 blurXTo="10.0" blurYTo="10.0"
			 duration="0" target="{nodeBase}"/>
	<mx:Fade id="fadeIn" alphaFrom="0.0" effectStart="handleFadeInEffectsStart(event)" alphaTo="1.0" duration="750" />
	<mx:Fade id="fadeOut" alphaFrom="1.0" effectEnd="handleFadeOutEffectsEnd(event)" alphaTo="0.0" duration="750" />
	<mx:Sequence id="newDocumentHighlight" target="{nodeBase.keywordTextArea}">
		<mx:Fade id="newDocumentFadeOut" alphaFrom="1.0" alphaTo="0.0" duration="1000" />
		<mx:Fade id="newDocumentFadeIn" alphaFrom="0.0" alphaTo="1.0" duration="1000" />
	</mx:Sequence>
	<mx:Script>
		<![CDATA[
			import weave.ui.infomap.ui.TopicNodeSettingComponent;
			import weave.ui.infomap.ui.TagCloudSettingComponent;
			import weave.ui.infomap.ui.BasicSettingsComponent;
			import weave.ui.ControlPanel;
			import flash.events.MouseEvent;
			
			import spark.accessibility.ToggleButtonAccImpl;
			
			import flash.geom.Point;
			import flash.net.URLRequest;
			import flash.net.navigateToURL;
			import flash.utils.Dictionary;
			
			import mx.collections.ArrayCollection;
			import mx.containers.TabNavigator;
			import mx.controls.Alert;
			import mx.controls.Image;
			import mx.controls.Label;
			import mx.controls.List;
			import mx.controls.Text;
			import mx.controls.TextArea;
			import mx.core.Application;
			import mx.core.IUIComponent;
			import mx.core.UIComponent;
			import mx.core.UITextField;
			import mx.core.mx_internal;
			import mx.events.CloseEvent;
			import mx.events.DragEvent;
			import mx.events.EffectEvent;
			import mx.events.FlexEvent;
			import mx.events.ListEvent;
			import mx.events.SandboxMouseEvent;
			import mx.managers.CursorManager;
			import mx.managers.CursorManagerPriority;
			import mx.managers.DragManager;
			import mx.managers.PopUpManager;
			import mx.managers.PopUpManagerChildList;
			import mx.rpc.AsyncToken;
			import mx.rpc.events.FaultEvent;
			import mx.rpc.events.ResultEvent;
			
			import weave.Weave;
			import weave.api.WeaveAPI;
			import weave.api.copySessionState;
			import weave.api.core.ILinkableHashMap;
			import weave.api.core.ILinkableObject;
			import weave.api.data.IAttributeColumn;
			import weave.api.data.IQualifiedKey;
			import weave.api.detectLinkableObjectChange;
			import weave.api.disposeObjects;
			import weave.api.getCallbackCollection;
			import weave.api.getLinkableOwner;
			import weave.api.getSessionState;
			import weave.api.linkBindableProperty;
			import weave.api.linkSessionState;
			import weave.api.newLinkableChild;
			import weave.api.registerLinkableChild;
			import weave.api.reportError;
			import weave.compiler.Compiler;
			import weave.compiler.StandardLib;
			import weave.core.LinkableDynamicObject;
			import weave.core.LinkableHashMap;
			import weave.core.LinkableNumber;
			import weave.core.LinkableString;
			import weave.core.SessionManager;
			import weave.core.SessionStateLog;
			import weave.core.StageUtils;
			import weave.core.UIUtils;
			import weave.data.AttributeColumns.KeyColumn;
			import weave.data.AttributeColumns.ReferencedColumn;
			import weave.data.CSVParser;
			import weave.data.ColumnReferences.HierarchyColumnReference;
			import weave.data.DataSources.CSVDataSource;
			import weave.data.DataSources.InfoMapsDataSource;
			import weave.data.KeySets.KeyFilter;
			import weave.data.KeySets.KeySet;
			import weave.data.QKeyManager;
			import weave.primitives.ColorRamp;
			import weave.primitives.DateRangeFilter;
			import weave.services.DelayedAsyncInvocation;
			import weave.services.DelayedAsyncResponder;
			import weave.services.beans.TopicClassificationResults;
			import weave.ui.CustomLabel;
			import weave.ui.DraggablePanel;
			import weave.ui.ResizableBox;
			import weave.ui.infomap.core.FilterableInfoMapNode;
			import weave.ui.infomap.core.InfoMapDocument;
			import weave.ui.infomap.core.InfoMapNode;
			import weave.ui.infomap.core.MovedThumbnailPosition;
			import weave.ui.infomap.core.QueryObject;
			import weave.ui.infomap.ui.DateFilterComponent;
			import weave.ui.infomap.ui.DocThumbnailComponent;
			import weave.ui.infomap.ui.DocumentList;
			import weave.ui.infomap.ui.InfoMapPanel;
			import weave.ui.infomap.ui.NodeBaseComponent;
			import weave.ui.infomap.ui.NodeSettingsComponent;
			import weave.ui.infomap.ui.PointsLayout;
			import weave.ui.infomap.ui.RelatedKeywordsListItemObject;
			import weave.ui.infomap.ui.TagCloud;
			import weave.ui.infomap.ui.ThumbnailsLayout;
			import weave.ui.infomap.ui.TopicNodeComponent;
			import weave.utils.BitmapUtils;
			import weave.utils.ColumnUtils;
			import weave.utils.ComputationalGeometryUtils;
			import weave.utils.CustomCursorManager;
			import weave.utils.DateUtils;
			import weave.utils.DebugTimer;
			import weave.utils.EventUtils;
			import weave.utils.VectorUtils;
			import weave.visualization.layers.InteractiveVisualization;
			import weave.visualization.tools.CompoundBarChartTool;
			
			private const currentQuery:QueryObject = newLinkableChild(this,QueryObject);
			
			public const previousQuery:QueryObject = newLinkableChild(this,QueryObject);
			
			public const xPos:LinkableNumber = newLinkableChild(this,LinkableNumber);
			public const yPos:LinkableNumber = newLinkableChild(this,LinkableNumber);
			
			public const layout:LinkableDynamicObject = newLinkableChild(this,LinkableDynamicObject,handleLayoutChange,true);
			
			public const thumbnails:LinkableHashMap = newLinkableChild(this,LinkableHashMap);
			
			public const thumbnailsDefaultColor:LinkableNumber = registerLinkableChild(this,new LinkableNumber(0));
			
			public const movedThumbNails:LinkableHashMap = newLinkableChild(this,LinkableHashMap);
			
			public const comments:LinkableString = newLinkableChild(this,LinkableString);
			
			public const numOfWordsInCloud:LinkableNumber = registerLinkableChild(this,new LinkableNumber(75,function(value:*):Boolean{
																if(value > 100)
																	return false;
																else 
																	return true;},false));
			
			public const numOfMatchedDocuments:LinkableNumber = registerLinkableChild(this, new LinkableNumber(0));
			
			/* We separate dateFilter from previousQuery because when dateFilter is changed from NodeSettingsComponent the behavior of the callbacks
			is unpredictable. It is easier to handle the callbacks for keywords and date separately.*/
//			public const dateFilter:DateRangeFilter = registerLinkableChild(this, new DateRangeFilter(),handleDateFilterChange, true); // ToDo

			public const numOfTopics:LinkableNumber = registerLinkableChild(this, new LinkableNumber(5,function(value:*):Boolean{
				if(value > 10 || value <2)
					return false;
				else 
					return true;},false), handleTopicsPropertiesChange, true);
			
			public const numOfKeywordsInEachTopic:LinkableNumber = registerLinkableChild(this, new LinkableNumber(5,function(value:*):Boolean{
				if(value > 10 || value < 1)
					return false;
				else 
					return true;},false), handleTopicsPropertiesChange, true);
			
			public const spaceBetwwenTopicRect:LinkableNumber = registerLinkableChild(this, new LinkableNumber(3, function(value:*):Boolean{
				if(value > 10 || value < 1)
					return false;
				else 
					return true;},false), handleTopicLayoutSettingChange, true); // ToDo
			
			private function handleTopicLayoutSettingChange():void
			{
				flag_init = true;
				showClassificationResults();
			}
			
			private const listWidth:LinkableNumber = new LinkableNumber();
			
			private var loader:URLLoader = null;
			
			//we override the x,y value because we are binding the values to LinkableNumber 
			//which could be NaN when component loads for the first time
			override public function set x(value:Number):void
			{
				if(parent)
					super.x = isNaN(value)?parent.width/2:value;
				else
					super.x=value
			}
			
			override public function set y(value:Number):void
			{
				if(parent)
					super.y = isNaN(value)?parent.height/2:value;
				else
					super.y=value
				
			}
			
			private var _parentPanel:InfoMapPanel;
			public function get parentPanel():InfoMapPanel
			{
				return _parentPanel;
			}
			
			private var _subset:KeyFilter = Weave.root.getObject(Weave.DEFAULT_SUBSET_KEYFILTER) as KeyFilter;
			
			//We create a private key filter for tag word click
			private var _tagWordSubset:KeyFilter = new KeyFilter();
			
			
			override protected function createChildren():void
			{
				
				super.createChildren();
				this.addChild(nodeBase);
			}
			
			//			private var log:SessionStateLog = new SessionStateLog(thumbnails);
			
			override protected function childrenCreated():void
			{
				super.childrenCreated();
				
				getCallbackCollection(currentQuery).addGroupedCallback(this,createAndSendQuery,false);//currentQuery should always be triggered by change in previousQuery
				getCallbackCollection(previousQuery).addGroupedCallback(this,updateTextArea,true);
				
				//if node is selected we highlight the nodeBase
				//				node.selected.addGroupedCallback(this,highlightNode);
				
				//for now defaulting to Random Layout
				if(layout.internalObject == null)
					layout.requestLocalObject(RandomLayout,false);
				(layout.internalObject as IInfoMapNodeLayout).parentNodeHandler = this;
				
				//opens the settings panel
				nodeBase.settingsImg.addEventListener(MouseEvent.CLICK,settings);
				
//				nodeBase.tickImg.addEventListener(MouseEvent.CLICK,clearAllNewDocuments);
				
				//removes the node from the panel after confirmation
				nodeBase.closeImg.addEventListener(MouseEvent.CLICK,close);
				
				nodeBase.filterImg.visible = false;
				nodeBase.filterImg.addEventListener(MouseEvent.CLICK, toggleTagCloud);
				
				nodeBase.listImg.visible = false;
				nodeBase.listImg.addEventListener(MouseEvent.CLICK,toggleList);
				
				nodeBase.distributionImg.visible = false;
				nodeBase.distributionImg.addEventListener(MouseEvent.CLICK,showDistributionChart);
				
				nodeBase.topicsImg.visible = false;
				nodeBase.topicsImg.addEventListener(MouseEvent.CLICK,showClassificationResults);
				
				nodeBase.pointsImg.visible = false;
				nodeBase.pointsImg.addEventListener(MouseEvent.CLICK,showPoints);
				
				nodeBase.gridImg.visible = false;
				nodeBase.gridImg.addEventListener(MouseEvent.CLICK,showGridView);
				
				//drag and drop of the node will be use the text area as the handler/anchor point
				nodeBase.keywordTextArea.addEventListener(MouseEvent.MOUSE_DOWN,canvas1_mouseDownHandler);
				stage.addEventListener(MouseEvent.MOUSE_UP,canvas1_mouseUpHandler);
				nodeBase.keywordTextArea.addEventListener(KeyboardEvent.KEY_DOWN,keywordTextAreaKeyDownHandler);
				
				//drawing the base which is the node with keywords and icons
				(layout.internalObject as IInfoMapNodeLayout).drawBaseLayout(graphics);
				
				//sessioning the x and y positions of this node
				linkBindableProperty(xPos,this,"x");
				linkBindableProperty(yPos,this,"y");
				
				thumbnailsDefaultColor.addImmediateCallback(this,handleBorderColor,true);
				
				//sets a pointer to the node's parent which is an InfoMapPanel
				if(!_parentPanel)
				{
					var hashmap:LinkableHashMap = WeaveAPI.SessionManager.getLinkableOwner(this) as LinkableHashMap;
					_parentPanel = WeaveAPI.SessionManager.getLinkableOwner(hashmap) as InfoMapPanel;
				}
				
				//adding a callback to the Global Search keyword. This will set the visibility of the thumbnails to true or false
				//based on keyword match
//				_parentPanel.globalSearchKeyword.addImmediateCallback(this,handleGlobalSearch);
				
				//adding a callback to the Global Date Filter
				//TODO: needs to be tested
				_parentPanel.globalDateFilter.startDate.addGroupedCallback(this,handleGlobalDateChange);
				_parentPanel.globalDateFilter.endDate.addGroupedCallback(this,handleGlobalDateChange);
				
				//adding listener to Click event to toggle node selection
				nodeBase.keywordTextArea.addEventListener(MouseEvent.CLICK,handleClick);
				
				//adding callback to subset. Thumbnails will be re-drawn to plot only included thumbnails
				getCallbackCollection(_subset).addGroupedCallback(this,positionThumbnails);
				getCallbackCollection(_tagWordSubset).addGroupedCallback(this,handleTagWordSubsetChange);
				
				//calling function to highlight the node based on node.selected.value
				//				highlightNode();
				
				//we want to trigger the callback for thumbnails at each frame and check the trigger counter
				getCallbackCollection(this).addImmediateCallback(this,invalidateDisplayList);
				
				//the set of keys matching the query is stored in docKeyset. 
				//when the results are stored in this keySet a callback is triggered for parsing the results
				docKeySet.addGroupedCallback(this,handleDocKeySetChange,false);
				
				//this keySet stores the keys matching the search query.
				//when the results are stored in this keySet a callback is triggered for setting the thumbnails' visible to true/false
//				_searchKeySet.addImmediateCallback(this,handleSearchKeySetChange,true);
				
				filteredWords.addGroupedCallback(this,filterListByKeywords,false);
				
				thumbnails.addGroupedCallback(this,positionThumbnails);
				
				//				nodeBase.editImage.addEventListener(MouseEvent.CLICK,handleEditCommentsClick);
				//				
				//				delayedCommentKeyUp = EventUtils.generateDelayedCallback(nodeBase.commentTextArea,handleCommentKeyUp,500,true);
				//				nodeBase.commentTextArea.addEventListener(KeyboardEvent.KEY_UP,delayedCommentKeyUp); 
				//				nodeBase.commentTextArea.addEventListener(FocusEvent.FOCUS_OUT,updateCommentTextArea);
				
//				clickedWordKeySet.addImmediateCallback(this,handleClickedWordKeySetChange);
				prevNewDocsCount.addGroupedCallback(this,updateTextArea);
				
				numOfWordsInCloud.addGroupedCallback(this,redrawWordCloud,false);
				
//				refreshTimer.start();
				//call event for each tick of refreshTimer
				refreshTimer.addEventListener(TimerEvent.TIMER, createAndSendQuery);
				
				//				comments.addImmediateCallback(this,handleCommentsChange,true);
				
				//				createAndSendQuery();
				
				glowFilter.color = thumbnailsDefaultColor.value;
				
				var owner:ILinkableObject = getLinkableOwner(this);
				
				_nodeName= (owner as ILinkableHashMap).getName(this);
				
				entityDistributionDataSource = Weave.root.requestObject(_nodeName + "entityDistributionDataSource",CSVDataSource,false);
				(WeaveAPI.SessionManager as SessionManager).excludeLinkableChildFromSessionState(entityDistributionDataSource,entityDistributionDataSource.csvData);
				(WeaveAPI.SessionManager as SessionManager).excludeLinkableChildFromSessionState(entityDistributionDataSource,entityDistributionDataSource.keyColName);
				(WeaveAPI.SessionManager as SessionManager).excludeLinkableChildFromSessionState(entityDistributionDataSource,entityDistributionDataSource.keyType);
				addChild(topicComponent);
				topicComponent.rectColors.addImmediateCallback(this, handleTopicLayoutSettingChange); // ToDo
			}
			
			private var _nodeName:String = "";
			
			private var delayedCommentKeyUp:Function = null;
			
			private var refreshTimer:Timer = new Timer(60*5*1000);
			
			[Bindable]
			public var nodeBase:NodeBaseComponent = new NodeBaseComponent();
			
			private var docKeySet:KeySet = new KeySet();
			
			/**
			 * @private
			 * Called when the session state of query is changed
			 **/
			private function createAndSendQuery(event:TimerEvent=null):void
			{
				trace("in createAndSendQuery");
				/* this function is called every time the query parameters changes, so we will reset the timer so that it is not called immediately
				when the query changes. This way we can avoid adding old results for a new query. */
				refreshTimer.reset();
				refreshTimer.start();
				
				/* if this is an empty query clear all documents */
				if(!currentQuery.keywords.value)
				{
					handleEmptyResultSet();
					return;
				}
				
				if (this.parent == null)
				{
					WeaveAPI.StageUtils.callLater(this,createAndSendQuery);
					return;
				}
				
				status.text = "Searching...";
				
				/* check to see if this a new query or an old query */
				var isQueryDifferent:* = WeaveAPI.SessionManager.computeDiff(WeaveAPI.SessionManager.getSessionState(previousQuery),
					WeaveAPI.SessionManager.getSessionState(currentQuery));
								
				if(isQueryDifferent)
				{
					/* remove all documents */
					handleEmptyResultSet();
					
					/* Hide any views */
					hideList();
					if(tagCanvas)
						hideTagCloud();
					
					hideIcons();
					
					prevNewDocsCount.value = 0;
				}
				
				/* emptying wordCount before sending it. I am using concat in the InfoMapDataSource. */
				wordCount = [];
				
				/* Make query to get number of documents */
				if(_parentPanel.relatedKeywords.value)
					relatedKeywords = _parentPanel.relatedKeywords.value.split(',');
				
				var numOfDocsQuery:AsyncToken = _parentPanel.infoMapsDataSource.getNumOfDocumentsForQuery(currentQuery.keywords.value.split(','),relatedKeywords,currentQuery.dateFilter);
				
				DelayedAsyncResponder.addResponder(numOfDocsQuery,handleNumOfDocsQueryResult,handleNumOfDocsQueryFault,
					{keywords:currentQuery.keywords.value,startDate:currentQuery.dateFilter.startDate.value,endDate:currentQuery.dateFilter.endDate.value});
				
			}
			
			private function handleNumOfDocsQueryResult(event:ResultEvent,token:Object=null):void
			{
				/* if the query has changed do nothing */
				if(token.keywords != currentQuery.keywords.value ||
					token.startDate != currentQuery.dateFilter.startDate.value ||
					token.endDate != currentQuery.dateFilter.endDate.value)
					return;
				
				var numOfDocs:Number = event.result as Number;
				
				/* If no documents found, show status and do nothing. */
				if(numOfDocs <= 0)
				{
					status.text = "0 documents found.";
					handleEmptyResultSet();
					return;						
				}
				
				status.text = numOfDocs.toString() + " documents found. Fetching documents...";
				numOfMatchedDocuments.value = numOfDocs;
				updateTextArea();
				
				/* Send query to get full result set */
				if(_parentPanel.relatedKeywords.value)
					relatedKeywords = _parentPanel.relatedKeywords.value.split(',');
				
				var docSetQuery:AsyncToken = _parentPanel.infoMapsDataSource.getDocumentsForQueryWithRelatedKeywords(currentQuery.keywords.value.split(','),
						relatedKeywords,currentQuery.dateFilter,2000);
				
				DelayedAsyncResponder.addResponder(docSetQuery,handleQueryWithRelatedKeywordsResults,handleQueryWithRelatedKeywordsFault,token);
			}
			
			
			private function handleQueryWithRelatedKeywordsResults(event:ResultEvent,token:Object=null):void
			{
				//if the query has changed do nothing
				if(token.keywords != currentQuery.keywords.value ||
					token.startDate != currentQuery.dateFilter.startDate.value ||
					token.endDate != currentQuery.dateFilter.endDate.value)
					return;
				
				var docsArray:Array = event.result as Array;
				var docsToAdd:Array = [];
				var keys:Array = [];
				
				var urlCol:IAttributeColumn =_parentPanel.infoMapsDataSource.getColumnByName('url'); 
				
				for (var i:int = 0; i < docsArray.length; i++)
				{
					var link:String = docsArray[i][0];
					
					var key:IQualifiedKey = WeaveAPI.QKeyManager.getQKey("infoMapsDoc",link);
					
					/*if the key is already present in the column, then we only add it to the keys keyset
					we will not add the currentDoc to the docsArray, this way the rows are not repeated in the csvDataString */
					if(urlCol.containsKey(key))
					{
						keys.push(link);
						continue;
					}
					
					docsToAdd.push(docsArray[i]);
					
					keys.push(link);
				}
				
				_parentPanel.infoMapsDataSource.csvData.setSessionState(
					(_parentPanel.infoMapsDataSource.csvData.getSessionState() as Array).concat(docsToAdd));			
				
				docKeySet.replaceKeys(WeaveAPI.QKeyManager.getQKeys("infoMapsDoc",keys));
				
				/* we force to trigger callbacks so that if a empty keyset is replaced with empty keys the callbacks are still called */
				docKeySet.triggerCallbacks(); 
			}
			
			private function handleQueryWithRelatedKeywordsFault(event:FaultEvent, token:Object=null):void
			{
				reportError("Error making query");
			}
			
			
			/**
			 * @private
			 **/
			private function handleDocKeySetChange():void
			{
				trace("in handleDocKeySetChange");
				status.text = "";
				var response:Array = docKeySet.keys;
				
				
				var diff:* = WeaveAPI.SessionManager.computeDiff(WeaveAPI.SessionManager.getSessionState(previousQuery),
					WeaveAPI.SessionManager.getSessionState(currentQuery));
				if(diff)
				{
					//its a new query
					thumbnails.removeAllObjects();
					highlightNewDocuments = false;
				}else
				{
					//its an old query
					if(thumbnails.getObjects().length == 0)
					{
						highlightNewDocuments = false;
					}
					else
					{
						highlightNewDocuments = true;
					}
				}
				
				/* we test the text because htmlText has tags with '/' */
				if(nodeBase.keywordTextArea.text && nodeBase.keywordTextArea.text.indexOf("/") >-1)
					nodeBase.keywordTextArea.htmlText = nodeBase.keywordTextArea.htmlText.replace(/\/[0-9]*/g,"/" +
						numOfMatchedDocuments.value);
				else
					nodeBase.keywordTextArea.htmlText = nodeBase.keywordTextArea.htmlText.replace(/\([0-9]*/g,"(" +
						numOfMatchedDocuments.value);
				
				_reusableThumbnailsToPlotArray = [];
				_currentNewDocsCount = 0;
				_thumbnailCount = 0;
				_nameOrder = [];
				WeaveAPI.StageUtils.startTask(this,_iterateEachThumbnail,WeaveAPI.TASK_PRIORITY_PARSING,_completeThumbnailsIteration);
			}
			
			private var _thumbnailCount:Number = 0;
			private var _nameOrder:Array = [];
			private function _iterateEachThumbnail():Number
			{
				if(_thumbnailCount >= docKeySet.keys.length)
					return 1;
				
				var link:String = (docKeySet.keys[_thumbnailCount] as IQualifiedKey).localName;					
				_nameOrder.push(link);
				var thumbnail:DocThumbnailComponent = thumbnails.getObject(link) as DocThumbnailComponent;
				
				
				if(!thumbnail)//if thumbnail does not exist
				{
					thumbnail = thumbnails.requestObject(link,DocThumbnailComponent,false);
					
					thumbnail.docURL.value = link;
					if(highlightNewDocuments)
					{
						thumbnail.highlighted.value = true;
						_currentNewDocsCount++;
					}
				}
				
				thumbnail.defaultBorderColor.value = thumbnailsDefaultColor.value;
				
				/* first check to see if the thumbnail is present in movedThumbnails */
				var position:MovedThumbnailPosition = movedThumbNails.getObject(thumbnail.docURL.value) as MovedThumbnailPosition;
				
				/* if the document exists in movedThumbnails then make sure to set the moved positions and set hasBeenMoved to true; */
				if(position)
				{
					thumbnail.hasBeenMoved.value = true;
					
					copySessionState(position.xPos,thumbnail.xPos);
					copySessionState(position.yPos,thumbnail.yPos);
				}
				
				
				/* if thumbnail has been moved make sure to add it as a child to Panel else make sure to add it as child to node. */
				if(thumbnail.hasBeenMoved.value)
				{
					if(thumbnail.parent != _parentPanel.map)
					{
						_parentPanel.map.addChild(thumbnail);
						
					}
					//xPos and yPos are not linked
					thumbnail.move(thumbnail.xPos.value,thumbnail.yPos.value);
					
				}else
				{
					if(thumbnail.parent != this)
					{
						thumbnail.visible = false;
					}
				}
				
				var qKey:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,link);
				
				if(_subset.containsKey(qKey) && _tagWordSubset.containsKey(qKey))
				{
					_reusableThumbnailsToPlotArray.push(qKey);
					thumbnail.visible = true;
				}else{
					
					thumbnail.visible = false;
				}
				thumbnail.defaultBorderColor.value = thumbnailsDefaultColor.value;
				linkSessionState(_parentPanel.selectedThumbnailBorderColor,thumbnail.selectedBorderColor);
				linkSessionState(_parentPanel.newThumbnailGlowColor,thumbnail.glowColor);
				
				_thumbnailCount++;
				
				return _thumbnailCount/docKeySet.keys.length;
			}
			
			private function _completeThumbnailsIteration():void
			{
				thumbnails.setNameOrder(_nameOrder);
				//				WeaveAPI.SessionManager.copySessionState(query,previousQuery);
				thumbnails.resumeCallbacks();
				prevNewDocsCount.value = _currentNewDocsCount;
				nodeBase.listImg.visible = true;
				nodeBase.gridImg.visible = true;
				testAndBlinkNode();
				positionThumbnails();
				adjustNodeBase();
				var wordCountQuery:AsyncToken = _parentPanel.infoMapsDataSource.getWordCount(
					currentQuery.keywords.value.split(','),relatedKeywords,currentQuery.dateFilter);
				
				DelayedAsyncResponder.addResponder(wordCountQuery,handleWordCountResult,handleWordCountFault,
					{keywords:currentQuery.keywords.value,startDate:currentQuery.dateFilter.startDate.value,endDate:currentQuery.dateFilter.endDate.value,
						forceHide:true,forceShow:false});
				
				getEntityDistribution();
				getTopicsClassification();
				docListComponent.docKeys = _reusableThumbnailsToPlotArray;
			}
			
			private function handleWordCountResult(event:ResultEvent,token:Object=null):void
			{
				//if the query has changed do nothing
				if(token.keywords != currentQuery.keywords.value ||
					token.startDate != currentQuery.dateFilter.startDate.value ||
					token.endDate != currentQuery.dateFilter.endDate.value)
					return;
				wordCount = event.result as Array;
				nodeBase.filterImg.visible = true;
//				toggleTagCloud(null,token.forceShow,token.forceHide);
			}
			
			private function handleWordCountFault(event:FaultEvent,token:Object=null):void
			{
				reportError("Error making query for word count");
			}
				
			
			private function handleNumOfDocsQueryFault(event:FaultEvent,token:Object=null):void
			{
				Alert.show("Error getting number of documents");
			}
			
			
			private var parser:CSVParser = new CSVParser();
			
			public const prevNewDocsCount:LinkableNumber = registerLinkableChild(this,new LinkableNumber(0)); 
			[Bindable]
			private var _currentNewDocsCount:int = 0;
			//			private var _firstLoad:Boolean = true;
			
			private function clearAllNewDocuments(event:Event=null):void
			{
				_currentNewDocsCount = 0;
				
				for each(var t:DocThumbnailComponent in thumbnails.getObjects())
				{
					t.highlighted.value = false;
				}
				stopGlow();
				prevNewDocsCount.value = 0;
				_currentNewDocsCount = 0;
//				nodeBase.tickImg.visible = false;
//				updateTextArea();
			}
			
			private function getRequiredKeywords():Array
			{
				var selectedKeys:Array = _selection.keys;
				
				var entityColumns:Array = _parentPanel.entityColumnsHashmap.getObjects();
				
				var requriedKeywords:Array = getKeywordsFromEntityColumns(selectedKeys);
				
				return requriedKeywords;
			}
			
			private function getUniqueKeywordsFromArray(keywords:Array):Array
			{
				//get unique keywords from extracted values 
				var dict:Dictionary = new Dictionary();
				
				for each(var word:String in keywords)
				{
					if(dict[word] == undefined)
						dict[word] = word;
				}
				
				var uniqueEntityValues:Array = []
				for each(var prop:String in dict)
				{
					uniqueEntityValues.push(prop);	
				}
				
				return uniqueEntityValues;
			}
			
			private var glowFilter:GlowFilter = new GlowFilter();
			private var glowTimer:Timer = new Timer(125);
			private function startGlow():void
			{
					nodeBase.keywordTextArea.filters = [glowFilter];
					glowTimer.addEventListener(TimerEvent.TIMER,changeGlow);
					glowTimer.start();
			}
			
			private function changeGlow(event:TimerEvent):void
			{
				glowFilter.alpha = 0.125 + (event.target.currentCount % 8) *0.125;
				glowFilter.color = thumbnailsDefaultColor.value;
				nodeBase.keywordTextArea.filters=[glowFilter];
			}
			
			private function stopGlow():void
			{
				glowTimer.stop();
				nodeBase.keywordTextArea.filters = [];
				nodeBase.keywordTextArea.alpha = 1;//restore alpha value to 1 incase timer stops at lesser alpha value
			}
			
			private function adjustNodeBase():void
			{
				nodeBase.keywordTextArea.validateNow();
				var widthOffset:int = 50;
				
				nodeBase.width = nodeBase.keywordTextArea.textWidth + widthOffset;
				if(nodeBase.width < 220)
					nodeBase.width = 220;
				nodeBase.keywordTextArea.width = nodeBase.width;
				nodeBase.keywordTextArea.height= nodeBase.keywordTextArea.mx_internal::getTextField().numLines * 20;
				nodeBase.height = nodeBase.keywordTextArea.height+ 30;
			}
			
			override public function validateDisplayList():void
			{
				super.validateDisplayList();
				//				if(detectLinkableObjectChange(invalidateDisplayList,thumbnails,movedThumbNails))
				//					positionThumbnails();
			}
			
			public var _reusableThumbnailsToPlotArray:Array = [];
			
			/**
			 * This function goes through the list of thumbnails and adds the ones included in the subset to an array.
			 * This array is then sent to a Layout Algorithm to plot the thumbnails. 
			 * After the thumbnails are plotted we call the functions to highlight selected documents and set visiblity based on search keywords.
			 **/
			private function positionThumbnails():void
			{
				//				nodeBase.keywordTextArea.text = query.keywords.value;
//				trace("in positionThumbnails");
//				if(!previousQuery.keywords.value)
//					return;
//				pointsCanvas.y = nodeBase.height;
//				
//				_reusableThumbnailsToPlotArray = [];
//				var tNails:Array = thumbnails.getObjects()
//				
////				if(nodeBase.keywordTextArea.htmlText.indexOf("Total Documents") >-1)
////					nodeBase.keywordTextArea.htmlText = nodeBase.keywordTextArea.htmlText.replace(/Total Documents Found:<\/B> [0-9]*/g,"Total Documents Found:<\/B> " + tNails.length);
////				else
////					nodeBase.keywordTextArea.htmlText +="<br/><b>Total Documents Found:</b> " +  tNails.length;
//				
//				if(nodeBase.keywordTextArea.text && nodeBase.keywordTextArea.text.indexOf("/") >-1)//we test the text because htmlText has tags with '/'
//					nodeBase.keywordTextArea.htmlText = nodeBase.keywordTextArea.htmlText.replace(/\/[0-9]*/g,"/" + numOfMatchedDocuments.value);
//				else
//					nodeBase.keywordTextArea.htmlText = nodeBase.keywordTextArea.htmlText.replace(/\([0-9]*/g,"(" + numOfMatchedDocuments.value);
//				
//				adjustNodeBase();	
//				thumbnails.delayCallbacks();
//				for (var i:int = 0; i<tNails.length; i++)
//				{
//					var t:DocThumbnailComponent = tNails[i];
//					
//					t.defaultBorderColor.value = thumbnailsDefaultColor.value;
//					
//					//first check to see if the thumbnail is present in movedThumbnails
//					var position:MovedThumbnailPosition = movedThumbNails.getObject(t.docURL.value) as MovedThumbnailPosition;
//					
//					//if the document exists in movedThumbnails then make sure to set the moved positions and set hasBeenMoved to true;
//					if(position)
//					{
//						t.hasBeenMoved.value = true;
//						
//						copySessionState(position.xPos,t.xPos);
//						copySessionState(position.yPos,t.yPos);
//					}
//					
//					
//					//if thumbnail has been moved make sure to add it as a child to Panel else make sure to add it as child to node.
//					if(t.hasBeenMoved.value)
//					{
//						if(t.parent != _parentPanel.map)
//						{
//							_parentPanel.map.addChild(t);
//							
//						}
//						//xPos and yPos are not linked
//						t.move(t.xPos.value,t.yPos.value);
//						
//					}else
//					{
//						if(t.parent != this)
//						{
//							t.visible = false;
//							//							pointsCanvas.addChild(t);
//						}
//					}
//					
//					
//					var docURL:String = thumbnails.getName(t);
//					var qKey:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,docURL);
//					
//					//TODO: Handle subsets
//					
//					
//					if(_subset.containsKey(qKey) && _tagWordSubset.containsKey(qKey))
//					{
//						_reusableThumbnailsToPlotArray.push(qKey);
//						t.visible = true;
//					}else{
//						
//						t.visible = false;
//					}
//					
//				}
//				thumbnails.resumeCallbacks();
//				//				(layout.internalObject as IInfoMapNodeLayout).plotThumbnails(thumbnailsToPlotArray);
//				docListComponent.docKeys = _reusableThumbnailsToPlotArray;
//				adjustNodeBase();
//				toggleList(null,true);
				
//				handleGlobalSearch();
			}
			
			private function handleTagWordSubsetChange():void
			{
				if(_tagWordSubset.included.keys.length == 0)
				{
					//unsetting visible property for filtered DocThumbnailComponents
					var thumbs:Array = thumbnails.getObjects();
					for (var i:int = 0; i < thumbs.length; i++)
					{
						var docURL:String = (thumbs[i] as DocThumbnailComponent).docURL.value;
						var qKey:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,docURL);
						
						if(_subset.containsKey(qKey))
						{
							(thumbs[i] as DocThumbnailComponent).visible = true;
						}
					}
					
					addAllDocumentsToList();
					if(_gridView && _gridView.alpha ==1)
						redrawGrid();
						
				}else
				{
					docListComponent.docKeys = _tagWordSubset.included.keys;
				}
			}
			
			private function addAllDocumentsToList():void
			{
				var tNails:Array = thumbnails.getObjects();
				_reusableThumbnailsToPlotArray = [];	
				for (var i:int = 0; i<tNails.length; i++)
				{
					var t:DocThumbnailComponent = tNails[i];
					
					var docURL:String = thumbnails.getName(t);
					var qKey:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,docURL);
					
					if(_subset.containsKey(qKey))
					{
						_reusableThumbnailsToPlotArray.push(qKey);
					}
				}
				docListComponent.docKeys = _reusableThumbnailsToPlotArray;
			}
			
			private var _entitiesToKeysHashMap:Dictionary = new Dictionary();
			public var entityDistributionDataSource:CSVDataSource = new CSVDataSource(); 
			
			private const ENTITY_DISTRIBUTION_ENTITY_COLUMN:String =  "Entities";
			private const ENTITY_DISTRIBUTION_NUMBER_COLUMN:String =  "Number of Documents";
			private const ENTITY_DISTRIBUTION_KEYTYPE:String =  "entityDistribution";
			
			private function getEntityDistribution():void
			{
				
				var entityColumns:Array = _parentPanel.entityColumnsHashmap.getObjects();
				
				if(entityColumns.length == 0)
					return;
				
				var keys:Array = (entityColumns[0] as IAttributeColumn).keys;
				var requiredKeywords:Array = currentQuery.keywords.value.split(',');
				
				/* if there more than 1000 entities we will only show entity distribution for selected entities */
				if(keys.length > 1000)
				{
					keys = requiredKeywords;					
				}
				
				//mapping entities to keys. It maybe possible that each entity is associated with more than one key
				for each(var attrCol:IAttributeColumn in entityColumns)
				{
					for each(var qKey:IQualifiedKey in keys)
					{
						var value:String = ColumnUtils.getString(attrCol,qKey);
						if(value)
						{
							//if the entity is encountered for the first time, create an array containing the key
							//else push the key to the already existing array
							if(_entitiesToKeysHashMap[value] == undefined)
							{
								var a:Array = [qKey];
								_entitiesToKeysHashMap[value] = a;
								
							}else
							{
								(_entitiesToKeysHashMap[value] as Array).push(qKey);
							}
						}
					}
				}
				
				var entities:Array = [];
				for (var key:Object in _entitiesToKeysHashMap)
				{
					entities.push(key);
				}
				
				var relatedKeywords:Array = null;
				
				if(_parentPanel.relatedKeywords.value)
					relatedKeywords = _parentPanel.relatedKeywords.value.split(',');
				
				
				var entityQuery:AsyncToken = _parentPanel.infoMapsDataSource.getEntityDistributionForQuery(requiredKeywords,
															relatedKeywords,entities,currentQuery.dateFilter,2000);
				
				DelayedAsyncResponder.addResponder(entityQuery,handleEntityQueryResults,handleEntityQueryFault,
					{keywords:currentQuery.keywords.value,startDate:currentQuery.dateFilter.startDate.value,endDate:currentQuery.dateFilter.endDate.value});
			}
			
			
			//TODO: clear/invalidate them when the attirbute column changes.
			private var _entitiesToURLsHashMap:Dictionary = new Dictionary();
			private var _URLToEntitiesHashMap:Dictionary = new Dictionary();
			private function handleEntityQueryResults(event:ResultEvent,token:Object=null):void
			{
				//if the query has changed do nothing
				if(token.keywords != currentQuery.keywords.value ||
					token.startDate != currentQuery.dateFilter.startDate.value ||
					token.endDate != currentQuery.dateFilter.endDate.value)
					return;
				var entities:Array = event.result.entities;
				var urls:Array = event.result.urls;
				
				var entityCSVData:Array = [];
				
				entityCSVData.push([ENTITY_DISTRIBUTION_ENTITY_COLUMN,ENTITY_DISTRIBUTION_NUMBER_COLUMN]);
				
				entityDistributionDataSource.keyType.value = ENTITY_DISTRIBUTION_KEYTYPE;
				
				for(var i:int = 0; i<entities.length; i++)
				{
					_entitiesToURLsHashMap[entities[i]] = urls[i];
					entityCSVData.push([entities[i],(urls[i] as Array).length]);

				}
				
				entityDistributionDataSource.csvData.setSessionState(entityCSVData);
				
				
				for(var j:int =0; j<urls.length; j++)
				{
					for(var k:int = 0; k<urls[j].length; k++)
					{
						if(_URLToEntitiesHashMap[urls[j][k]] == undefined)
						{
							_URLToEntitiesHashMap[urls[j][k]] = [entities[j]]; 
						}else
						{
							(_URLToEntitiesHashMap[urls[j][k]] as Array).push(entities[j]);
						}
					}
				}
				
				nodeBase.distributionImg.visible = true;
//				_selection.addGroupedCallback(this,handleSelectionKeySetChange);
			}
			
			private function handleEntityQueryFault(event:FaultEvent,token:Object=null):void
			{
				reportError("Error making query for entities");
				return;
			}
			
			private var _entityChartName:String = "entityDistributionChart";
			private function showDistributionChart(event:Event):void
			{
				//clear any selection so that bars don't appear faded out
				_selection.replaceKeys([]);
//				var className:String = getQualifiedClassName(CompoundBarChartTool).split("::")[1];
//				
//				_entityChartName = Weave.root.generateUniqueName(className);

				var object:CompoundBarChartTool = Weave.root.requestObject(_entityChartName, CompoundBarChartTool, false);
				object.showAllLabels.value = false;
				object.plotter.colorColumn.defaultValue.value = "0x0FDF801";
				
				if (object is DraggablePanel)
					(object as DraggablePanel).restorePanel();
				// put panel in front
				
				//				dispatchEvent(new CloseEvent(CloseEvent.CLOSE));
				
				object.heightColumns.removeAllObjects();
				
				entityDistributionDataSource.putColumnInHashMap(ENTITY_DISTRIBUTION_NUMBER_COLUMN,object.heightColumns);
				
				entityDistributionDataSource.setDynamicColumn(ENTITY_DISTRIBUTION_ENTITY_COLUMN,object.plotter.labelColumn);
				entityDistributionDataSource.setDynamicColumn(ENTITY_DISTRIBUTION_ENTITY_COLUMN,object.plotter.sortColumn);
				
				object.panelTitle.value = 'Entity Distribution for Query "' + currentQuery.keywords.value + '"';
			}
			
			private function handleDocumentSelection(urls:Array):void
			{
				var keys:Array = [];
				//get all keys for selected documents
				for each (var url:String in urls)
				{
					var entities:Array = _URLToEntitiesHashMap[url];
					
					for each(var entity:String in entities)
					{
						if(_entitiesToKeysHashMap[entity])
							keys = keys.concat(_entitiesToKeysHashMap[entity]);
					}
				}
				_selection.delayCallbacks();
				_selection.replaceKeys(keys);
				_selection.resumeCallbacks();
			}
			
			private function handleDocumentSelectedFromList(event:ListEvent):void
			{
				var items:Array = (event.currentTarget as List).selectedItems;
				
				var urls:Array = [];
				for each (var doc:DocThumbnailComponent in items)
				{
					urls.push(doc.docURL.value);
				}
				handleDocumentSelection(urls);
			}
			
			
			private function getKeywordsFromEntityColumns(keys:Array=null):Array
			{
				var entityColumns:Array = _parentPanel.entityColumnsHashmap.getObjects();
				
				var requriedKeywords:Array = [];
				
				if(keys==null)
				{
					keys = (entityColumns[0] as IAttributeColumn).keys;
				}
				
				for each(var attrCol:IAttributeColumn in entityColumns)
				{
					for each(var key:IQualifiedKey in keys)
					{
						var value:String = ColumnUtils.getString(attrCol,key);
						if(value)
						{
							requriedKeywords.push(value);
						}
					}
				}
				
				requriedKeywords = getUniqueKeywordsFromArray(requriedKeywords);
				
				requriedKeywords = getUniqueKeywordsFromArray(requriedKeywords);
				
				return requriedKeywords;
			}
			
			//			private function positionMovedthumbNails():void
			//			{
			//				var thumbnailNames:Array = movedThumbNails.getNames();	
			//				
			//				for each (var url:String in thumbnailNames)
			//				{
			//					var t:DocThumbnailComponent = thumbnails.getObject(url) as DocThumbnailComponent;
			//					
			//					if(!t)
			//						continue;
			//					
			//					if(t.parent != _parentPanel.map)
			//					{
			//						_parentPanel.map.addChild(t);
			//					}
			//					
			//					var position:MovedThumbnailPosition = movedThumbNails.getObject(url) as MovedThumbnailPosition;
			//					
			//					copySessionState(position.xPos,t.xPos);
			//					copySessionState(position.yPos,t.yPos);
			//					
			//				}
			//			}
			
			private var _selection:KeySet = Weave.root.getObject(Weave.DEFAULT_SELECTION_KEYSET) as KeySet;
			/**
			 * Highlights selected documents
			 **/
			private function handleSelectionKeySetChange():void
			{
				
				var keys:Array = _selection.keys;
				if(keys.length == 0)
				{
					handleClearFiltersButton();					
					return;
				}
				var entities:Array = [];
				
				for each (var key:IQualifiedKey in keys)
				{
					if(key.keyType != InfoMapsDataSource.DOC_KEYTYPE)//add all keys except for document keys. We might do away with document keys completely
					{
						for each (var entityColumn:IAttributeColumn in _parentPanel.entityColumnsHashmap.getObjects())
						{
							entities.push(entityColumn.getValueFromKey(key));
						}
					}
				}
				
				var filterURLs:Array = [];
				
				for each (var entity:String in entities)
				{
					var temp:Array = _entitiesToURLsHashMap[entity] as Array;
					if(temp)
						filterURLs = filterURLs.concat(temp);	
				}
				
				filterDocumentsByURLS(filterURLs,"Selected Records");
//				var docs:Array = thumbnails.getNames();
//				
//				var selectedDocs:Array = getSelectedDocumentKeys();
//				
//				//if none are selected set all to 
//				if(selectedDocs.length == 0)
//				{
//					for each(var doc1:String in docs)
//					{
//						var t1:DocThumbnailComponent = thumbnails.getObject(doc1) as DocThumbnailComponent;
//						t1.setMode(DocThumbnailComponent.DEFAULT_MODE);
//					}
//					return;
//				}
//				
//				for each(var doc:String in docs)
//				{
//					var qKey:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,doc);
//					var t:DocThumbnailComponent = thumbnails.getObject(doc) as DocThumbnailComponent;
//					var selected:Boolean =_selection.containsKey(qKey) 
//					if(selected)
//						t.setMode(DocThumbnailComponent.SELECTED_MODE);
//					else
//						t.setMode(DocThumbnailComponent.UNSELECTED_MODE);
//				}
			}
			
			
			private function getSelectedDocumentKeys():Array
			{
				var selectedKeys:Array = _selection.keys;
				var selectedDocs:Array = [];
				
				for each(var key:IQualifiedKey in selectedKeys)
				{
					if(key.keyType == InfoMapsDataSource.DOC_KEYTYPE)
						selectedDocs.push(key);
				}
				
				return selectedDocs;
			}
			
			/**
			 * redraw thumbnails to handle new layout selection
			 **/
			private function handleLayoutChange():void
			{
				if(layout.internalObject == null)
					return;
				(layout.internalObject as IInfoMapNodeLayout).parentNodeHandler = this;
				(layout.internalObject as IInfoMapNodeLayout).drawBaseLayout(graphics);
				//				(layout.internalObject as IInfoMapNodeLayout).plotThumbnails(thumbnailsToPlotArray,true);
			}
			
			private function handleSpacingChange():void
			{
				if(layout.internalObject)
					(layout.internalObject as IInfoMapNodeLayout).plotThumbnails(_reusableThumbnailsToPlotArray,true);
			}
			
//			private var _searchKeySet:KeySet = new KeySet();
			//sends a query to solr for the search keywords filtrered by document links belonging to this node
			private function handleGlobalSearch():void
			{
				
//				if(!_parentPanel.globalSearchKeyword.value)
//				{
////					_searchKeySet.clearKeys();
////					_searchKeySet.triggerCallbacks();
//					return;
//				}
//				
//				var fieldNames:Array = ['link'];
//				
//				var fieldValues:Array = [];
//				
//				fieldValues.push(thumbnails.getNames());
//				
//				if(!query.sources.value == '')
//				{
//					var sourceNames:Array = parser.parseCSV(query.sources.value)[0]; //we send only the first row since this is a one-line CSV String
//				}
//				
//				_parentPanel.infoMapsDataSource.getDocumentsForQueryWithFieldValues(_searchKeySet,_parentPanel.globalSearchKeyword.value,fieldNames,fieldValues,null,"OR",null,2000,false);
				
				
//				filteredWords.value = 
			}
			
			public function filterBy(keywords:String):void
			{
				filteredWords.value = keywords;
			}
			
			//this function is called when the _searchKeySet is set. 
			//This sets the thumbnail's visiblity based if its link is included or excluded in the _searchKeySet
			private function handleSearchKeySetChange():void
			{
				//				var tnails:Array = thumbnails.getObjects();
				//				
				//				var searchMatchedKeys:Array =_searchKeySet.keys; 
				//				
				//				if(searchMatchedKeys.length == 0)
				//				{
				//					//if searchKeys length is zero and if there is search keyword then none of the documents matched. So we set all visiblity to false
				//					//else set all to true;
				//					var visiblity:Boolean =  (_parentPanel.globalSearchKeyword.value != "");
				//					for each(var t1:DocThumbnailComponent in tnails)
				//					{
				//						var qKey1:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,t1.docURL.value);
				//						if(_subset.containsKey(qKey1))
				//						{
				//							
				//							t1.visible = !visiblity;
				//						}
				//					}
				//				}else
				//				{
				//					for each(var t2:DocThumbnailComponent in tnails)
				//					{
				//						var qKey2:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,t2.docURL.value);
				//						if(_subset.containsKey(qKey2))
				//						{
				//							
				//							t2.visible = false;
				//						}
				//					}
				//				}
				//				
				//				for each(var k:IQualifiedKey in searchMatchedKeys)
				//				{
				//					var t3:DocThumbnailComponent = thumbnails.getObject(k.localName) as DocThumbnailComponent;
				//					
				//					if(!t3)
				//						continue;
				//					
				//					var qKey3:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,t3.docURL.value);
				//								
				//					
				//					if(t3 && qKey3 && _subset.containsKey(qKey3))
				//					{
				//						
				//						t3.visible = true;
				//					}
				//				}
				
			}
			
			// ToDo dateFilter should be previousQuery.dateFilter
			private function handleGlobalDateChange():void
			{
//				getCallbackCollection(currentQuery).delayCallbacks();
//				dateFilter.startDate.value = _parentPanel.globalDateFilter.startDate.value;
//				dateFilter.endDate.value = _parentPanel.globalDateFilter.endDate.value;
//				getCallbackCollection(currentQuery).resumeCallbacks();
			}
			private function removeEmptyStringElementsFromArray(arg:Array):Array
			{
				var result:Array = [];
				for each(var item:String in arg)
				{
					if(item != "")
						result.push(item);
				}
				
				return result;
			}
			
			
			private var _wasClicked:Boolean = false;
			//toggle node selection on click
			private function handleClick(event:Event):void
			{
				//if running to blink node.
				stopGlow();
				
				_wasClicked = true;
				
				if(wasDragged)
				{
					wasDragged = false;
					return;
				}
				//				if(node.selected.value)
				//					node.selected.value = false;
				//				else
				//					node.selected.value = true;
			}
			
			//highlight node based on node.selected.value
			private function highlightNode():void
			{
				//				unselectedBorder.color = _parentPanel.defaultNodeBorderColor.value;
				//				selectedBorder.color = _parentPanel.selectedNodeBorderColor.value;
				//				
				//				if(node.selected.value)
				//					selectedBorder.play();
				//				else
				//					unselectedBorder.play();
			}
			
			//this variable will be  used to avoid selection/unselection when the node is dragged
			private var wasDragged:Boolean = false;
			private var _lastX:Number = 0;
			private var _lastY:Number = 0;
			private var sbroot:DisplayObject = Application.application.systemManager.getSandboxRoot();
			private var handCursorID:int = -1;
			protected function canvas1_mouseDownHandler(event:MouseEvent):void
			{
				event.stopImmediatePropagation();
				nodeBase.keywordTextArea.setStyle("fontWeight","bold");
				handCursorID = CustomCursorManager.showCursor(InteractiveVisualization.CURSOR_HAND_GRAB);
				_lastX = x;
				_lastY = y;
				this.addEventListener(MouseEvent.MOUSE_MOVE,handleMouseMove);
				// solution for handling mous_up outside of stage : http://stackoverflow.com/questions/2944122/flash-correctly-handling-click-and-drag-outside-the-browser
				sbroot.addEventListener(SandboxMouseEvent.MOUSE_UP_SOMEWHERE, handleMouseUpSomewhere);
				this.startDrag();
			}
			
			private function handleMouseMove(event:Event):void
			{
				wasDragged = true;
			}
			
			private var stageUtils:StageUtils = new StageUtils();
			protected function canvas1_mouseUpHandler(event:Event):void
			{
				nodeBase.keywordTextArea.setStyle("fontWeight","normal");
				CustomCursorManager.removeCursor(handCursorID);
				this.removeEventListener(MouseEvent.MOUSE_MOVE,handleMouseMove);
				sbroot.removeEventListener(SandboxMouseEvent.MOUSE_UP_SOMEWHERE, handleMouseUpSomewhere);
				this.stopDrag();
			}
			
			private function handleMouseUpSomewhere(event:Event):void
			{
				this.x = _lastX;
				this.y = _lastY;
				canvas1_mouseUpHandler(event);
			}
			
			private function keywordTextAreaKeyDownHandler(event:KeyboardEvent):void
			{
				if(event.keyCode == Keyboard.ENTER)
				{
					event.preventDefault();
					nodeBase.keywordTextArea.editable = false;
					nodeBase.keywordTextArea.selectable = false;
					previousQuery.keywords.value = nodeBase.keywordTextArea.text;
					//getTopicsClassification();
				}
			}
			
			// ToDo ???
//			private function filter(event:Event):void
//			{
//				DateFilterComponent.openInstance(this,dateFilter);
//			}
			
//			private var _instance:NodeSettingsComponent = null;
//			private function settings(event:Event):void
//			{
//				
//				if(_instance)
//				{
//					PopUpManager.addPopUp(_instance,this);
//				}
//				else
//				{
//					_instance = new NodeSettingsComponent();
//					_instance.query = this.currentQuery;
//					_instance.nodeHandler = this;
//					_instance.dateFilter = dateFilter;
//					PopUpManager.addPopUp(_instance,this);
//				}
//			}
			
			private var _instance:ControlPanel = null;
			protected var basicSettingComponent:BasicSettingsComponent;
			protected var tagCloudSettingComponent:TagCloudSettingComponent;
			protected var topicModelSettingComponent:TopicNodeSettingComponent
			private function settings(event:Event):void
			{
				
				if(_instance)
				{
					PopUpManager.addPopUp(_instance,this);
				}
				else
				{
					_instance = new ControlPanel();
					
					basicSettingComponent = new BasicSettingsComponent();
					basicSettingComponent.query = this.previousQuery;
					basicSettingComponent.dateFilter = previousQuery.dateFilter;
					basicSettingComponent.nodeHandler = this;
					
					tagCloudSettingComponent = new TagCloudSettingComponent();
					tagCloudSettingComponent.nodeHandler = this;
					
					topicModelSettingComponent = new TopicNodeSettingComponent();
					topicModelSettingComponent.nodeHandler = this;
					
				_instance.targets = [basicSettingComponent.query.keywords,basicSettingComponent.query.sources, basicSettingComponent.dateFilter.startDate, basicSettingComponent.dateFilter.endDate, numOfWordsInCloud, numOfTopics, numOfKeywordsInEachTopic, spaceBetwwenTopicRect, topicNodeComponent.rectColors]
					_instance.children = [basicSettingComponent, tagCloudSettingComponent, topicModelSettingComponent];
					
					PopUpManager.addPopUp(_instance,this);
				}
			}
			
			private function close(event:Event):void
			{
				Alert.show("Are you sure you want to remove this node?",
					"Remove Node?",
					Alert.YES | Alert.NO,
					null,
					handleCloseEvent
				);
			}
			
			private var tagCanvas:TagCloud = null;
			private var colorRamp:ColorRamp = new ColorRamp();
			private var wordCount:Array = [];
			private function toggleTagCloud(event:Event=null,forceShow:Boolean=false,forceHide:Boolean=false):void
			{
				if(!forceHide|| forceShow || !tagCanvas ||tagCanvas.alpha ==0)//!tagCanvas happens when user clicks the button for the first time 
					status.text = "Loading Word Cloud...";
				fadeOut.play(topicComponents);
				flag_click = true;
				fadeOut.play([pointsCanvas,listCanvas,_pointCanvas]);
				if(_gridView)
					fadeOut.play([_gridView]);
				
				if(wordCount.length == 0)
				{
					var wordCountQuery:AsyncToken = _parentPanel.infoMapsDataSource.getWordCount(
						currentQuery.keywords.value.split(','),relatedKeywords,currentQuery.dateFilter);
					
					DelayedAsyncResponder.addResponder(wordCountQuery,handleWordCountResult,handleWordCountFault,
						{keywords:currentQuery.keywords.value,startDate:currentQuery.dateFilter.startDate.value,endDate:currentQuery.dateFilter.endDate.value,
							forceHide:forceHide,forceShow:forceShow});
					
					return;
				}
				handleClearFiltersButton();
				
				//				statusBox.y = nodeBase.height + statusBox.height;
				if(tagCanvas == null)
				{
					tagCanvas = new TagCloud();
					tagCanvas.addEventListener(MouseEvent.CLICK,handleTagCloudClick);
					tagCanvas.visible = false;
					tagCanvas.includeInLayout = false;
					addChild(tagCanvas);
					tagCanvas.alpha = 0;
					tagCanvas.visible = true;
				}
				tagCanvas.y= nodeBase.height;
				if(StandardLib.arrayCompare(tagCanvas.dataProvider,wordCount) != 0)
				{
					tagCanvas.dataProvider = wordCount;
					tagCanvas.draw(numOfWordsInCloud.value);
				}
				
				status.text = "";
				
				if(forceShow)
				{
					if(tagCanvas.alpha == 1)
						return;
					fadeIn.play([tagCanvas]);
					return;
				}
				
				if(forceHide)
				{
					if(tagCanvas.alpha ==0)
						return;
					fadeOut.play([tagCanvas]);
					return;
				}
				
				//toggle
				if(tagCanvas.alpha ==0)
					fadeIn.play([tagCanvas]);
				else
					fadeOut.play([tagCanvas]);
			}
			
			private function redrawWordCloud():void
			{
				if(tagCanvas != null)
				{
					tagCanvas.dataProvider = [];//clearing word cloud
					removeChild(tagCanvas);
					tagCanvas = null;
					showTagCloud();
				}
			}
			
			public function showTagCloud():void
			{
				toggleTagCloud(null,true);
			}
			
			public function hideTagCloud():void
			{
				toggleTagCloud(null,false,true);
			}
			
			private var docListComponent:DocumentList = new DocumentList();
			private function toggleList(event:Event=null,forceShow:Boolean=false,forceHide:Boolean=false):void
			{
				fadeOut.play(topicComponents);
				flag_click = true;
				
				//if the list is not added yet
				if(!listCanvas.contains(docListComponent))
				{
					listCanvas.alpha = 0;
					listCanvas.addChild(docListComponent);
					docListComponent.docList.addEventListener(ListEvent.ITEM_CLICK,handleDocumentSelectedFromList);
					
					docListComponent.y = nodeBase.height + statusBox.height;
					statusBox.y = docListComponent.y-statusBox.height;
					
					if(forceHide)
						return;
					
					fadeIn.play([listCanvas]);
					//hide other canvases 
					if(tagCanvas)
						fadeOut.play([tagCanvas,pointsCanvas,_pointCanvas]);
					else 
						fadeOut.play([pointsCanvas]);
					return;
				}
				
				docListComponent.y = nodeBase.height + statusBox.height;
				statusBox.y = docListComponent.y-statusBox.height;
				
				//hide other canvases 
				if(tagCanvas)
					fadeOut.play([tagCanvas,pointsCanvas,_pointCanvas]);
				else 
					fadeOut.play([pointsCanvas,_pointCanvas]);
				
				if(_gridView)
					fadeOut.play([_gridView]);
				
				
				if(forceShow)
				{
					if(listCanvas.alpha == 1)
						return;
					fadeIn.play([listCanvas]);
					return;
				}
				
				if(forceHide)
				{
					if(listCanvas.alpha == 0)
						return;
					fadeOut.play([listCanvas]);
					return;
				}	
				
				//toggle list
				if(listCanvas.alpha == 0)
				{
					fadeIn.play([listCanvas]);
				}
					
				else
				{
					fadeOut.play([listCanvas]);
				}
			}
			
			public function showList():void
			{
				toggleList(null,true,false);
			}
			
			public function hideList():void
			{
				toggleList(null,false,true);
			}
			
			private var _gridView:ThumbnailsLayout = null;
			private function showGridView(event:MouseEvent):void
			{
				if(!_gridView)
				{
					_gridView = new ThumbnailsLayout();
					_gridView.alpha = 0;
					_gridView.includeInLayout = false;
					addChild(_gridView);
					_gridView.y = nodeBase.height + statusBox.height;
				}
				
				_gridView.plotThumbnails(includedThumbnails());
				
				if(_gridView.alpha == 1)
				{
					fadeOut.play([_gridView]);
				}else
				{
					fadeOut.play([pointsCanvas,listCanvas,topicComponent,_pointCanvas]);
					if(tagCanvas)
						fadeOut.play([tagCanvas]);
					fadeIn.play([_gridView]);
				}
			}
			
			private function redrawGrid():void
			{
				_gridView.y = nodeBase.height + statusBox.height;
				_gridView.plotThumbnails(includedThumbnails());
			}
			
			/* TODO: if _subset and _tagWordSubset is empty just plot all */
			private function includedThumbnails():Array
			{
				var thumbs:Array = thumbnails.getObjects();
				var requiredThumbs:Array = []
				for (var i:int = 0; i < thumbs.length; i++)
				{
					var docURL:String = (thumbs[i] as DocThumbnailComponent).docURL.value;
					var qKey:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,docURL);
					
					if(_subset.containsKey(qKey) && _tagWordSubset.containsKey(qKey))
					{
						requiredThumbs.push(thumbs[i]);
					}
				}
				return requiredThumbs;
			}
			
			private var _pointCanvas:PointsLayout = new PointsLayout();
			private function showPoints(event:Event=null):void
			{
				if(_pointCanvas.alpha == 1)
				{
					fadeOut.play([_pointCanvas]);
					return;
				}
				handleClearFiltersButton();
				status.text = "Drawing points...";
				var urls:Array = [];
				VectorUtils.copy(_topicsResult.urls,urls);
				var keywords:Array = _topicsResult.keywords;
				
				if(!contains(_pointCanvas))
				{
					addChild(_pointCanvas);
				}
				_pointCanvas.y = nodeBase.height + statusBox.height;
				_pointCanvas.drawPoints(urls, keywords, this);
				
				fadeOut.play([pointsCanvas,listCanvas,topicComponent]);
				if(_gridView)
					fadeOut.play([_gridView]);
				if(tagCanvas)
					fadeOut.play([tagCanvas]);
				fadeIn.play([_pointCanvas]);
				status.text = "";
			}
			
			
//			private function showPointCanvas(event:Event):void
//			{
//				
//				if(!(tagCanvas == null))
//					fadeOut.play([tagCanvas,listCanvas,clearNewDocuments]);
//				else
//					fadeOut.play([listCanvas,clearNewDocuments]);
//				(layout.internalObject as RandomLayout).updateTitleLabel();
//				fadeIn.play([pointsCanvas]);
//			}
			
//			private var clickedWordKeySet:KeySet = new KeySet();
			private var filteredWords:LinkableString = new LinkableString("",null,false);
			private function handleTagCloudClick(event:MouseEvent):void
			{
				//we don't use the event.target for getting the text because this is based on the bounding box clicked and not necessarily the 
				//probed word. So we used the last recorded probed word
				if(event.target is CustomLabel)
					filteredWords.value= ((event.target as CustomLabel).parent as TagCloud).lastProbedWord.value;
				else
					return;
			}
			
			private function filterListByKeywords():void
			{
				if(!filteredWords.value)
				{
					_tagWordSubset.replaceKeys(false,true,[]);					
					return;
				}
				
//				if(!query.sources.value == '')
//				{
//					var sourceNames:Array = parser.parseCSV(query.sources.value)[0]; //we send only the first row since this is a one-line CSV String
//				}
//				
//				_parentPanel.infoMapsDataSource.getDocumentsForQuery(clickedWordKeySet,[],null,query.keywords.value + " " + filteredWords.value,"AND",sourceNames,query.dateFilter);
				
				
				
				status.htmlText= "Filtering list...";
				clearFiltersButton.visible = false;
				
				var filterQuery:AsyncToken = _parentPanel.infoMapsDataSource.getLinksForFilteredQuery(currentQuery.keywords.value.split(','),
					relatedKeywords,currentQuery.dateFilter,filteredWords.value.split(','),2000);
				
				DelayedAsyncResponder.addResponder(filterQuery,handleFilterQueryResult,handleFilterQueryFault);
			}
			
			private function handleFilterQueryResult(event:ResultEvent,token:Object=null):void
			{
				var urls:Array = event.result as Array;
				filterDocumentsByURLS(urls,filteredWords.value);
			}
				
			private function handleFilterQueryFault(event:FaultEvent,token:Object=null):void
			{
				reportError("Error making query for filtering");
				
			}
			
			public function filterDocumentsByURLS(urls:Array,filterMessage:String=""):void
			{
				var keys:Array = [];
				for (var i:int = 0; i < urls.length; i++)
				{
					var key:IQualifiedKey = WeaveAPI.QKeyManager.getQKey("infoMapsDoc",urls[i]);
					keys.push(key);
				}
				
				_tagWordSubset.replaceKeys(false,true,keys);
				
				showList();
				status.text = "";
				filterStatus.htmlText= "<b>Filtered by: </b>" + filterMessage;
				clearFiltersButton.visible = true;
			}
			
			private function getTopicsClassification():void
			{
				var topicsQuery:AsyncToken = null
				if(numOfMatchedDocuments.value <= 20 && numOfTopics.value > 3)
				{
					topicsQuery = _parentPanel.infoMapsDataSource.classifyDocumentsForQuery(currentQuery.keywords.value.split(','),relatedKeywords,currentQuery.dateFilter,
						2000, 3, numOfKeywordsInEachTopic.value);
				}
				else{
				topicsQuery = _parentPanel.infoMapsDataSource.classifyDocumentsForQuery(currentQuery.keywords.value.split(','),relatedKeywords,currentQuery.dateFilter,
					2000, numOfTopics.value, numOfKeywordsInEachTopic.value);
				//trace("Number of Topics and number of keywords in each topic: " + numOfTopics.value + numOfKeywordsInEachTopic.value);
				}
				
				DelayedAsyncResponder.addResponder(topicsQuery,handleTopicsQueryResult,handleTopicsQueryFault,
					{keywords:currentQuery.keywords.value,startDate:currentQuery.dateFilter.startDate.value,endDate:currentQuery.dateFilter.endDate.value});
			}
			
			private function handleTopicsPropertiesChange():void
			{
				if(currentQuery.keywords.value != null)
				{
					getTopicsClassification();
					
					flag_init = true;
					 if(!flag_click){
						flag_click = true;
						flag_topicPropertiesChange = true;
						//showClassificationResults();
					}  
				}
			}
			
			private var topicComponents:Array = new Array();
			private var flag_click:Boolean = true;
			private var flag_init:Boolean =true;
			private var _topicsResult:Object = null;
			private var flag_topicPropertiesChange:Boolean = false;
			//private var _numOfTopics:int = 5;
//			public var topicComponent:TopicNodeComponent = new TopicNodeComponent();
			public const topicComponent:TopicNodeComponent = registerLinkableChild(this, new TopicNodeComponent());
			public function get topicNodeComponent():TopicNodeComponent // ToDo TopicModelSettingComponent
			{
				return topicComponent;
			}
			private function showClassificationResults(event:Event=null, forceShow:Boolean=false,forceHide:Boolean=false):void
			{   
				if(_topicsResult == null)
					return;
				fadeOut.play([pointsCanvas,listCanvas,_pointCanvas]);
				if(tagCanvas)
					fadeOut.play([tagCanvas]);
				if(_gridView)
					fadeOut.play([_gridView]);
				
				if(flag_init){
					
					// ToDo This will not update automatically when new documents come in.
					//var colorRamp:Array = [0x808080, 0xFF0000, 0xFFFF00, 0x808000, 0x008000, 0x800080, 0xFF00FF, 0x0000FF]; // ToDo
					topicComponent.removeAllChildren();
					var urls:Array = _topicsResult.urls;
					var keywords:Array = _topicsResult.keywords;
					
					//store all the urls of the uncategoried documents, it is an 1D.
					var uncategoried:Array = _topicsResult.uncategoried; 
					
					//var topicComponent:TopicNodeComponent = new TopicNodeComponent();
					var parentComponent:UIComponent = new UIComponent();
					parentComponent.width = 400;
					parentComponent.height = 230; // ToDo Add extra 20 for showing spot label
					parentComponent.y= nodeBase.height;
					
					topicComponent.drawTreeMap(urls, keywords, parentComponent, spaceBetwwenTopicRect.value);
					topicComponents.push(topicComponent);
					topicComponent.includeInLayout = false;
					
					//addChild(topicComponent);
					
					flag_init = false;
				}
				
				if (flag_click)
				{
					fadeIn.play(topicComponents);
					flag_click = false;
				}
				else
				{
					fadeOut.play(topicComponents);
					flag_click = true;
				}
			}
			
			private function handleTopicsQueryResult(event:ResultEvent, token:Object = null):void
			{
				if(token.keywords != currentQuery.keywords.value ||
					token.startDate != currentQuery.dateFilter.startDate.value ||
					token.endDate != currentQuery.dateFilter.endDate.value)
					return;
				_topicsResult = event.result;

				if (_topicsResult.keywords == null || _topicsResult.urls == null)
				{
					reportError(lang("Topic Models did not return an Array of results as expected."));
					nodeBase.topicsImg.visible = false;
					nodeBase.pointsImg.visible = false;
					return;
					
				}
				
				nodeBase.topicsImg.visible = true;
				nodeBase.pointsImg.visible = true;
				if(flag_topicPropertiesChange){
					showClassificationResults();
					flag_topicPropertiesChange = false;
				}
			}
			
			private function handleTopicsQueryFault(event:FaultEvent, token:Object = null):void
			{
				trace(["fault", token, event.message].join('\n'));
				reportError(event);
			}
			
			//this variable is false when the user loads the map for the first time. 			
			private var highlightNewDocuments:Boolean = true;
			private function checkForNewDocuments(event:TimerEvent):void
			{
				if(!previousQuery.sources.value == '')
				{
					var sourceNames:Array = parser.parseCSV(previousQuery.sources.value)[0]; //we send only the first row since this is a one-line CSV String
				}
				//emptying wordCount before sending it. I am using concat in the InfoMapDataSource.
				wordCount = [];
				status.text = "Searching...";
				_parentPanel.infoMapsDataSource.getDocumentsForQuery(docKeySet,wordCount,numOfMatchedDocuments,currentQuery.keywords.value,currentQuery.operator.value,sourceNames,currentQuery.dateFilter);
			}
			
			
			
			private function updateTextArea():void
			{
				var diff:* = WeaveAPI.SessionManager.computeDiff(WeaveAPI.SessionManager.getSessionState(previousQuery),WeaveAPI.SessionManager.getSessionState(currentQuery));
				
				if(!previousQuery.keywords.value)
				{
					nodeBase.keywordTextArea.editable = true;
					nodeBase.keywordTextArea.selectable = true;
					nodeBase.keywordTextArea.setFocus();
					nodeBase.keywordTextArea.setSelection(0,0);
					nodeBase.keywordTextArea.htmlText = "";
					newDocumentHighlight.stop();//in case node is blinking
					stopGlow()
					if(listCanvas.contains(docListComponent))
					{
						docListComponent.docKeys = [];//clearing items in list
						hideList();
					}
					if(tagCanvas)
					{
						hideTagCloud();
						tagCanvas.clearCloud();
						tagCanvas.dataProvider = [];//clearing word cloud
						removeChild(tagCanvas);
						tagCanvas = null;
					}
					if(diff)
						copySessionState(previousQuery,currentQuery);
					
					adjustNodeBase();
					return;
				}
				
				//we restrict node length to 200.
				if(previousQuery.keywords.value.length >200)
				{
					nodeBase.keywordTextArea.htmlText = previousQuery.keywords.value.substr(0,200) + " ... ("+numOfMatchedDocuments.value +")";
				}else
				{
					nodeBase.keywordTextArea.htmlText = previousQuery.keywords.value + "("+ numOfMatchedDocuments.value +")";
				}
				nodeBase.keywordTextArea.editable = false;
				nodeBase.keywordTextArea.selectable = false;
				
				
				if(diff)
					copySessionState(previousQuery,currentQuery);
				adjustNodeBase();
				//				testAndBlinkNode();
			}
			
			private function testAndBlinkNode():void
			{
				if((prevNewDocsCount.value>0) || (highlightNewDocuments && _currentNewDocsCount>0 && _currentNewDocsCount != prevNewDocsCount.value))
				{
					//TODO: Replace htmlText with text for testing. See other function using similar testing
					if(nodeBase.keywordTextArea.text.indexOf("/") >-1)
						nodeBase.keywordTextArea.htmlText = nodeBase.keywordTextArea.htmlText.replace(/\([0-9]*\//g,"(" + _currentNewDocsCount + "/");
					else
						nodeBase.keywordTextArea.htmlText = nodeBase.keywordTextArea.htmlText.replace(/\(/g,"(" + _currentNewDocsCount + "/");
					
					adjustNodeBase();
				}
				
				////					nodeBase.tickImg.enabled = true;
				////					nodeBase.tickImg.visible = true;
				//					if(currentNewDocsCount != prevNewDocsCount.value || !_wasClicked)
				//					{
				//						startGlow();
				//					}
				//				}else{
				////					nodeBase.tickImg.enabled = false;
				////					nodeBase.tickImg.visible = false;
				//					stopGlow();
				//				}
				//				
				//				positionThumbnails();
				//				adjustNodeBase();
			}
			
			/* Since we use a private query object we define a public function to set variable */
			public function applyKeywords(keywords:String):void
			{
				previousQuery.keywords.value = keywords;
				if(_parentPanel.relatedKeywords.value)
					relatedKeywords = _parentPanel.relatedKeywords.value.split(',');
			}
			
			private var relatedKeywords:Array = null;
			public function applyKeywordsFromSelection():void
			{
				if(!_parentPanel)
				{
					var hashmap:LinkableHashMap = WeaveAPI.SessionManager.getLinkableOwner(this) as LinkableHashMap;					
					_parentPanel = WeaveAPI.SessionManager.getLinkableOwner(hashmap) as InfoMapPanel;
				}
				previousQuery.keywords.value = getRequiredKeywords().join(',');
				if(_parentPanel.relatedKeywords.value)
					relatedKeywords = _parentPanel.relatedKeywords.value.split(',');
				_selection.clearKeys();
			}
			
			
			private function handleDateFilterChange():void
			{
//								createAndSendQuery(); // ToDo
			}
			
			
			
			
//			private function handleClickedWordKeySetChange():void
//			{
//				var keys:Array = clickedWordKeySet.keys;
//				var includeKeys:Array = [];
//				
//				for each(var k:IQualifiedKey in keys)
//				{
//					if(thumbnails.getObject(k.localName))
//					{
//						includeKeys.push(k);	
//					}
//				}
//				
//				//				_subset.replaceKeys(false,true,includeKeys);
//				_tagWordSubset.replaceKeys(false,true,includeKeys);
//				status.text = "";
//				filterStatus.htmlText= "<b>Filtered by: </b>" + filteredWords.value;
//				clearFiltersButton.visible = true;
//				
//			}
			
			private function handleClearFiltersButton():void
			{
//				_tagWordSubset.replaceKeys(true,true);
				filterStatus.text = "";
				clearFiltersButton.visible = false;
				filteredWords.value = "";
				_tagWordSubset.replaceKeys(false,true,[]);
//				addAllDocumentsToList(); // we don't change the _tagWordSubset so that it's callbacks aren't called.
				
				if(_gridView && _gridView.alpha == 1)
					redrawGrid();
			}
			
			private function handleFadeInEffectsStart(event:EffectEvent):void
			{
				(event.effectInstance.target as DisplayObject).visible = true;
			}
			
			private function handleFadeOutEffectsEnd(event:EffectEvent):void
			{
				(event.effectInstance.target as DisplayObject).visible = false;
//				if(event.effectInstance.target == listCanvas)
//				{
//					handleClearFiltersButton();
//				}
			}
			
			private function handleBorderColor():void
			{
				nodeBase.keywordTextArea.setStyle("borderColor",thumbnailsDefaultColor.value);
			}
			
			private function handleCloseEvent(e:CloseEvent):void
			{
				if(e.detail == Alert.YES)
				{
					thumbnails.removeAllObjects();
					var parent:ILinkableHashMap = (WeaveAPI.SessionManager.getLinkableOwner(this) as ILinkableHashMap);
					var nodeName:String  = parent.getName(this);
					parent.removeObject(nodeName);
				}
				else if(e.detail == Alert.NO)
				{
					return;
				}
			}			
			
			private function hideIcons():void
			{
				nodeBase.gridImg.visible = nodeBase.listImg.visible = nodeBase.filterImg.visible = 
					nodeBase.distributionImg.visible = nodeBase.topicsImg.visible = nodeBase.pointsImg.visible= false;
			}
			
			private function handleEmptyResultSet():void
			{
				thumbnails.removeAllObjects();
				numOfMatchedDocuments.value = 0;
				_currentNewDocsCount = 0;
				prevNewDocsCount.value = 0;
				updateTextArea();
				docKeySet.replaceKeys([]);
			}
			
			public function dispose():void
			{
				refreshTimer.stop();
			}
			
			//							private function handleEditCommentsClick(event:MouseEvent):void
			//			{
			//				nodeBase.editImage.visible = false;
			//				nodeBase.commentTextArea.visible = true;
			//				nodeBase.commentTextArea.setFocus();
			//			}
			//			
			//			private function handleCommentsChange():void
			//			{
			//				if(nodeBase.commentTextArea.text != comments.value)
			//					nodeBase.commentTextArea.text = comments.value;
			//				if(comments.value)
			//				{
			//					nodeBase.commentTextArea.visible = true;
			//					nodeBase.editImage.visible = false;
			//					nodeBase.commentTextArea.validateNow();
			//				}else{
			//					nodeBase.commentTextArea.visible = false;
			//					nodeBase.editImage.visible = true;
			//				}
			//			}
			//			
			//			private function handleCommentKeyUp(event:KeyboardEvent=null):void
			//			{
			//				
			//				comments.value = nodeBase.commentTextArea.text;
			//				if(event.keyCode == Keyboard.ESCAPE)
			//				{
			//					updateCommentTextArea();
			//					nodeBase.keywordTextArea.setFocus();
			//				}
			//			}
			//			
			//			private function updateCommentTextArea(event:Event=null):void
			//			{
			//				nodeBase.commentTextArea.minHeight = nodeBase.commentTextArea.textHeight;
			//
			//				if(nodeBase.commentTextArea.text == "")
			//				{
			//					comments.triggerCallbacks();
			//				}
			//			}	
			
			
			//			private function handleCommentAreaChange(event:Event):void
			//			{
			//				var ta_height:uint = 20;
			//				
			//				nodeBase.commentTextArea.validateNow();
			//				
			//				for(var i:int=0; i < nodeBase.commentTextArea.mx_internal::getTextField().numLines; i++) {
			//					ta_height += nodeBase.commentTextArea.mx_internal::getTextField().getLineMetrics(i).height;
			//				}
			//				
			//				nodeBase.commentTextArea.height = ta_height;
			//				
			//				nodeBase.height +=  ta_height;
			//				nodeBase.invalidateDisplayList();
			//			}
			
		]]>
	</mx:Script>
	
</mx:Canvas>
