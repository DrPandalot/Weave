<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas xmlns:mx="http://www.adobe.com/2006/mxml" horizontalScrollPolicy="off" verticalScrollPolicy="off"
		   implements="weave.api.core.ILinkableObject"
		   cacheAsBitmap="false"
		   clipContent="false"
		   autoLayout="false"
		   dragDrop ="dragDropHandler(event)"
		   dragEnter="dragEnterHandler(event)"
		>
	<mx:Glow id="selectedBorder" 
			 alphaFrom="1.0" alphaTo="1.0"   
			 blurXFrom="10.0" blurYFrom="10.0" 
			 blurXTo="10.0" blurYTo="10.0"
			 duration="0" target="{nodeBase}"/>
	<mx:Glow id="unselectedBorder" 
			 alphaFrom="0.0" alphaTo="1.0"   
			 blurXFrom="10.0" blurYFrom="10.0" 
			 blurXTo="10.0" blurYTo="10.0"
			 duration="0" target="{nodeBase}"/>	
	<mx:Script>
		<![CDATA[
			import flash.events.MouseEvent;
			import flash.geom.Point;
			import flash.net.URLRequest;
			import flash.net.navigateToURL;
			import flash.utils.Dictionary;
			
			import mx.collections.ArrayCollection;
			import mx.controls.Alert;
			import mx.controls.Image;
			import mx.controls.Label;
			import mx.controls.Text;
			import mx.controls.TextArea;
			import mx.core.IUIComponent;
			import mx.events.CloseEvent;
			import mx.events.DragEvent;
			import mx.events.FlexEvent;
			import mx.managers.CursorManager;
			import mx.managers.DragManager;
			import mx.managers.PopUpManager;
			import mx.managers.PopUpManagerChildList;
			import mx.rpc.events.FaultEvent;
			import mx.rpc.events.ResultEvent;
			
			import weave.Weave;
			import weave.api.WeaveAPI;
			import weave.api.copySessionState;
			import weave.api.core.ILinkableHashMap;
			import weave.api.core.ILinkableObject;
			import weave.api.data.IAttributeColumn;
			import weave.api.data.IQualifiedKey;
			import weave.api.detectLinkableObjectChange;
			import weave.api.disposeObjects;
			import weave.api.getCallbackCollection;
			import weave.api.getLinkableOwner;
			import weave.api.getSessionState;
			import weave.api.linkBindableProperty;
			import weave.api.linkSessionState;
			import weave.api.newLinkableChild;
			import weave.api.registerLinkableChild;
			import weave.core.LinkableDynamicObject;
			import weave.core.LinkableHashMap;
			import weave.core.LinkableNumber;
			import weave.core.LinkableString;
			import weave.core.SessionStateLog;
			import weave.core.StageUtils;
			import weave.core.UIUtils;
			import weave.core.weave_internal;
			import weave.data.AttributeColumns.ReferencedColumn;
			import weave.data.CSVParser;
			import weave.data.ColumnReferences.HierarchyColumnReference;
			import weave.data.DataSources.InfoMapsDataSource;
			import weave.data.KeySets.KeyFilter;
			import weave.data.KeySets.KeySet;
			import weave.data.QKeyManager;
			import weave.primitives.DateRangeFilter;
			import weave.ui.infomap.core.FilterableInfoMapNode;
			import weave.ui.infomap.core.InfoMapDocument;
			import weave.ui.infomap.core.InfoMapNode;
			import weave.ui.infomap.core.MovedThumbnailPosition;
			import weave.ui.infomap.ui.DateFilterComponent;
			import weave.ui.infomap.ui.DocThumbnailComponent;
			import weave.ui.infomap.ui.InfoMapPanel;
			import weave.ui.infomap.ui.NodeBaseComponent;
			import weave.ui.infomap.ui.NodeSettingsComponent;
			import weave.utils.BitmapUtils;
			import weave.utils.ColumnUtils;
			import weave.utils.CustomCursorManager;
			import weave.utils.DateUtils;
			import weave.utils.EventUtils;
			
			public const node:FilterableInfoMapNode = newLinkableChild(this,FilterableInfoMapNode);
			
			public const xPos:LinkableNumber = newLinkableChild(this,LinkableNumber);
			public const yPos:LinkableNumber = newLinkableChild(this,LinkableNumber);
			
			public const layout:LinkableDynamicObject = newLinkableChild(this,LinkableDynamicObject,handleLayoutChange,true);
			
			public const thumbnails:LinkableHashMap = newLinkableChild(this,LinkableHashMap);
			
			public const movedThumbNails:LinkableHashMap = newLinkableChild(this,LinkableHashMap);
			
			public const comments:LinkableString = newLinkableChild(this,LinkableString);
			
			private var loader:URLLoader = null;
			
			//we override the x,y value because we are binding the values to LinkableNumber 
			//which could be NaN when component loads for the first time
			override public function set x(value:Number):void
			{
				if(parent)
					super.x = isNaN(value)?parent.width/2:value;
				else
					super.x=value
			}
			
			override public function set y(value:Number):void
			{
				if(parent)
					super.y = isNaN(value)?parent.height/2:value;
				else
					super.y=value
						
			}
			
			private var _parentPanel:InfoMapPanel;
			private var _subset:KeyFilter = Weave.root.getObject(Weave.DEFAULT_SUBSET_KEYFILTER) as KeyFilter;
			
			
			
			override protected function createChildren():void
			{

				super.createChildren();
				this.addChild(nodeBase);
			}
			
//			private var log:SessionStateLog = new SessionStateLog(thumbnails);
			
			override protected function childrenCreated():void
			{
				
								
				super.childrenCreated();
								
				node.keywords.addGroupedCallback(this,createAndSendQuery);
				node.operator.addGroupedCallback(this,createAndSendQuery);
				node.numberOfDocs.addGroupedCallback(this,createAndSendQuery);
				node.dateFilter.startDate.addGroupedCallback(this,createAndSendQuery);
				node.dateFilter.endDate.addGroupedCallback(this,createAndSendQuery);
				node.sources.addGroupedCallback(this,createAndSendQuery);
				
				//if node is selected we highlight the nodeBase
				node.selected.addGroupedCallback(this,highlightNode);
				
				//for now defaulting to Grid Layout
				if(layout.internalObject == null)
					layout.requestLocalObject(GridLayout,false);
				(layout.internalObject as IInfoMapNodeLayout).parentNodeHandler = this;
				
				//opens the settings panel
				nodeBase.settingsImg.addEventListener(MouseEvent.CLICK,settings);
				
				//removes the node from the panel after confirmation
				nodeBase.closeImg.addEventListener(MouseEvent.CLICK,close);
				
				//drag and drop of the node will be use the text area as the handler/anchor point
				nodeBase.keywordTextArea.addEventListener(MouseEvent.MOUSE_DOWN,canvas1_mouseDownHandler);
				nodeBase.keywordTextArea.addEventListener(MouseEvent.MOUSE_UP,canvas1_mouseUpHandler);
				nodeBase.keywordTextArea.addEventListener(KeyboardEvent.KEY_DOWN,keywordTextAreaKeyDownHandler);
				
				//drawing the base which is the node with keywords and icons
				(layout.internalObject as IInfoMapNodeLayout).drawBaseLayout(graphics);
				
				//sessioning the x and y positions of this node
				linkBindableProperty(xPos,this,"x");
				linkBindableProperty(yPos,this,"y");
				
				//sets a pointer to the node's parent which is an InfoMapPanel
				var hashmap:LinkableHashMap = WeaveAPI.SessionManager.getLinkableOwner(this) as LinkableHashMap;
				_parentPanel = WeaveAPI.SessionManager.getLinkableOwner(hashmap) as InfoMapPanel;
				
				//adding a callback to the Global Search keyword. This will set the visibility of the thumbnails to true or false
				//based on keyword match
				_parentPanel.globalSearchKeyword.addImmediateCallback(this,handleGlobalSearch);
				
				//adding a callback to the Global Date Filter
				//TODO: needs to be tested
				_parentPanel.globalDateFilter.startDate.addGroupedCallback(this,handleGlobalDateChange);
				_parentPanel.globalDateFilter.endDate.addGroupedCallback(this,handleGlobalDateChange);
				
				//adding listener to Click event to toggle node selection
				nodeBase.keywordTextArea.addEventListener(MouseEvent.CLICK,handleClick);
				
				//adding callback to subset. Thumbnails will be re-drawn to plot only included thumbnails
				getCallbackCollection(_subset).addGroupedCallback(this,positionThumbnails);
				
//				thumbnails.childListCallbacks.addGroupedCallback(this,handleThumbnails);
				
				//calling function to highlight the node based on node.selected.value
				highlightNode();
				
				//we want to trigger the callback for thumbnails at each frame and check the trigger counter
				getCallbackCollection(this).addImmediateCallback(this,invalidateDisplayList);
				
				//the set of keys matching the query is stored in docKeyset. 
				//when the results are stored in this keySet a callback is triggered for parsing the results
				docKeySet.addGroupedCallback(this,handleThumbnails,true);
				
				//this keySet stores the keys matching the search query.
				//when the results are stored in this keySet a callback is triggered for setting the thumbnails' visible to true/false
				_searchKeySet.addImmediateCallback(this,handleSearchKeySetChange,true);
				
				//adding a callback to the selection KeySet to highlight/unhighlight documents
				_selection.addGroupedCallback(this,handleSelectionKeySetChange,true);
				
				nodeBase.editImage.addEventListener(MouseEvent.CLICK,handleEditCommentsClick);
				
				delayedCommentKeyUp = EventUtils.generateDelayedCallback(nodeBase.commentTextArea,handleCommentKeyUp,500,true);
				nodeBase.commentTextArea.addEventListener(KeyboardEvent.KEY_UP,delayedCommentKeyUp); 
				nodeBase.commentTextArea.addEventListener(FocusEvent.FOCUS_OUT,updateCommentTextArea);
				
				comments.addImmediateCallback(this,handleCommentsChange,true);
				
				createAndSendQuery();
				
				
				
				node.detectQueryChange(handleThumbnails);
				
			}
			
			private var delayedCommentKeyUp:Function = null;
			
			private function handleEditCommentsClick(event:MouseEvent):void
			{
				nodeBase.editImage.visible = false;
				nodeBase.commentTextArea.visible = true;
				nodeBase.commentTextArea.setFocus();
			}
			
			private function handleCommentsChange():void
			{
				if(nodeBase.commentTextArea.text != comments.value)
					nodeBase.commentTextArea.text = comments.value;
				if(comments.value)
				{
					nodeBase.commentTextArea.visible = true;
					nodeBase.editImage.visible = false;
					nodeBase.commentTextArea.validateNow();
				}else{
					nodeBase.commentTextArea.visible = false;
					nodeBase.editImage.visible = true;
				}
			}
			
			private function handleCommentKeyUp(event:KeyboardEvent=null):void
			{
				
				comments.value = nodeBase.commentTextArea.text;
				if(event.keyCode == Keyboard.ESCAPE)
				{
					updateCommentTextArea();
					nodeBase.keywordTextArea.setFocus();
				}
			}
			
			private function updateCommentTextArea(event:Event=null):void
			{
				nodeBase.commentTextArea.minHeight = nodeBase.commentTextArea.textHeight;

				if(nodeBase.commentTextArea.text == "")
				{
					comments.triggerCallbacks();
				}
			}
			
			private var _redraw:Boolean = false;
//			private function handleQueryChange():void
//			{
//				_redraw = true;
//				createAndSendQuery();
//				
//			}
			
			private function dragEnterHandler(event:DragEvent):void
			{
				 
				if(event.dragInitiator is DocThumbnailComponent)
				{
					DragManager.acceptDragDrop(this);
				}
			}
			
			private function dragDropHandler(event:DragEvent):void
			{
				var t:DocThumbnailComponent = event.dragInitiator as DocThumbnailComponent;
				
				if(!(t.parent == this))
				{
					movedThumbNails.removeObject(t.docURL.value);
					
					addChild(t);
					
					t.hasBeenMoved.value = false;
					
					//setting the X and Y with reference to the map
//					var tGlobalPoint2:Point = _parentPanel.map.contentToGlobal(new Point(event.stageX,event.stageY));
					var localPoint2:Point =  this.globalToLocal(new Point(event.stageX,event.stageY));
					
					t.move(localPoint2.x,localPoint2.y);
					
				}
			}
			
			//this variable is false when the user loads the map for the first time. 			
			private var highlightNewDocuments:Boolean = true;
			public function checkForNewDocuments():void
			{
				_redraw = false;
				createAndSendQuery();
			}
		
				
			[Bindable]
			public var nodeBase:NodeBaseComponent = new NodeBaseComponent();
			
			private var docKeySet:KeySet = new KeySet();
			
			/**
			 * @private
			 * This functions creates a query based on the keywords,operator and filters applied and sends a request to the Solr server
			 **/
			private function createAndSendQuery():void
			{
				if(!node.keywords.value)
				{
					nodeBase.keywordTextArea.editable = true;
					nodeBase.keywordTextArea.selectable = true;
					nodeBase.keywordTextArea.setFocus();
					nodeBase.keywordTextArea.setSelection(0,0);
					return;
				}
				nodeBase.keywordTextArea.editable = false;
				nodeBase.keywordTextArea.selectable = false;
//				if(clearDocuments)
//					thumbnails.removeAllObjects();
//				getCallbackCollection(node).delayCallbacks();
//				thumbnails.delayCallbacks();
//				if(_redraw)
//				{
//					thumbnails.removeAllObjects();
//					highlightNewDocuments = false;
//				}
				
				if (this.parent == null)
				{
					WeaveAPI.StageUtils.callLater(this,createAndSendQuery);
					return;
				}
				
				if(!node.sources.value == '')
				{
					var sourceNames:Array = parser.parseCSV(node.sources.value)[0]; //we send only the first row since this is a one-line CSV String
				}
				
				_parentPanel.infoMapsDataSource.getDocumentsForQuery(docKeySet,node.keywords.value,node.operator.value,sourceNames,node.dateFilter);
				
			}
			
			private var parser:CSVParser = new CSVParser();
			private var _firstLoad:Boolean = true;
			
			/**
			 * @private
			 * This function takes an array collection of links and requests a thumbnail object to display the document object
			 * for each of the corresponding links.
			 * If the thumbnail object is already there then we use the replace its doc object with the latest doc object. 
			 **/
			private function handleThumbnails():void
			{
				var response:Array = docKeySet.keys;
				var nameOrder:Array = [];
				
//				if(response.length == 0)
//				{
//					thumbnails.resumeCallbacks();
//					getCallbackCollection(node).resumeCallbacks();
//					return;
//				}

				if(_firstLoad && node.thumbnails.getNames().length == 0 && movedThumbNails.getNames().length == 0)
				{
					highlightNewDocuments = false;
				}else{
					
					if(node.detectQueryChange(handleThumbnails))
					{
						thumbnails.removeAllObjects();
						
						highlightNewDocuments = false;
					}else{
						highlightNewDocuments = true;
					}
				}
				
				_firstLoad = false;
				
				
				
				for(var i:int; i<response.length ;i++)
				{
					
					var link:String = (response[i] as IQualifiedKey).localName;					
					nameOrder.push(link);
					var thumbnail:DocThumbnailComponent = thumbnails.getObject(link) as DocThumbnailComponent;
					
					
					if(!thumbnail)
					{
						thumbnail = thumbnails.requestObject(link,DocThumbnailComponent,false);
						
						if(highlightNewDocuments)
						{
							thumbnail.startGlow();
						}
					}
						
										
					thumbnail.docURL.value = link;
					
					linkSessionState(_parentPanel.defaultThumbnailBorderColor,thumbnail.defaultBorderColor);
					linkSessionState(_parentPanel.selectedThumbnailBorderColor,thumbnail.selectedBorderColor);
					linkSessionState(_parentPanel.newThumbnailGlowColor,thumbnail.glowColor);
					
					
				}
				thumbnails.setNameOrder(nameOrder);
				positionThumbnails();
			}
			
			override public function validateDisplayList():void
			{
				super.validateDisplayList();
				if(detectLinkableObjectChange(invalidateDisplayList,thumbnails) || detectLinkableObjectChange(invalidateDisplayList,movedThumbNails))
					positionThumbnails();
			}
			
			public var thumbnailsToPlotArray:Array = [];
			
			/**
			 * This function goes through the list of thumbnails and adds the ones included in the subset to an array.
			 * This array is then sent to a Layout Algorithm to plot the thumbnails. 
			 * After the thumbnails are plotted we call the functions to highlight selected documents and set visiblity based on search keywords.
			 **/
			private function positionThumbnails():void
			{
				nodeBase.keywordTextArea.text = node.keywords.value;
				nodeBase.keywordTextArea.toolTip = node.keywords.value;
				thumbnailsToPlotArray = [];
				var tNails:Array = thumbnails.getObjects()

				for (var i:int = 0; i<tNails.length; i++)
				{
					var t:DocThumbnailComponent = tNails[i];
					
					//first check to see if the thumbnail is present in movedThumbnails
					var position:MovedThumbnailPosition = movedThumbNails.getObject(t.docURL.value) as MovedThumbnailPosition;
					
					//if the document exists in movedThumbnails then make sure to set the moved positions and set hasBeenMoved to true;
					if(position)
					{
						t.hasBeenMoved.value = true;
						
						copySessionState(position.xPos,t.xPos);
						copySessionState(position.yPos,t.yPos);
					}
					
					
					//if thumbnail has been moved make sure to add it as a child to Panel else make sure to add it as child to node.
					if(t.hasBeenMoved.value)
					{
						if(t.parent != _parentPanel.map)
						{
							_parentPanel.map.addChild(t);
							
						}
						
					}else
					{
						if(t.parent != this)
						{
							addChild(t);
						}
					}
					
					
					var docURL:String = thumbnails.getName(t);
					var qKey:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,docURL);
					if(_subset.containsKey(qKey))
					{
						thumbnailsToPlotArray.push(t);
						t.visible = true;
					}else{
						
						t.visible = false;
					}
					
				}
				(layout.internalObject as IInfoMapNodeLayout).plotThumbnails(thumbnailsToPlotArray);
				handleSelectionKeySetChange();
				handleGlobalSearch();
			}
			
//			private function positionMovedthumbNails():void
//			{
//				var thumbnailNames:Array = movedThumbNails.getNames();	
//				
//				for each (var url:String in thumbnailNames)
//				{
//					var t:DocThumbnailComponent = thumbnails.getObject(url) as DocThumbnailComponent;
//					
//					if(!t)
//						continue;
//					
//					if(t.parent != _parentPanel.map)
//					{
//						_parentPanel.map.addChild(t);
//					}
//					
//					var position:MovedThumbnailPosition = movedThumbNails.getObject(url) as MovedThumbnailPosition;
//					
//					copySessionState(position.xPos,t.xPos);
//					copySessionState(position.yPos,t.yPos);
//					
//				}
//			}
			
			private var _selection:KeySet = Weave.root.getObject(Weave.DEFAULT_SELECTION_KEYSET) as KeySet;
			/**
			 * Highlights selected documents
			 **/
			private function handleSelectionKeySetChange():void
			{
				var docs:Array = thumbnails.getNames();
				
				for each(var doc:String in docs)
				{
					var qKey:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,doc);
					var t:DocThumbnailComponent = thumbnails.getObject(doc) as DocThumbnailComponent;
					var selected:Boolean =_selection.containsKey(qKey) 
					t.highlight(selected);
				}
			}
			
			/**
			 * redraw thumbnails to handle new layout selection
			 **/
			private function handleLayoutChange():void
			{
				if(layout.internalObject == null)
					return;
				(layout.internalObject as IInfoMapNodeLayout).parentNodeHandler = this;
				(layout.internalObject as IInfoMapNodeLayout).drawBaseLayout(graphics);
				(layout.internalObject as IInfoMapNodeLayout).plotThumbnails(thumbnailsToPlotArray,true);
			}
			
			private function handleSpacingChange():void
			{
				if(layout.internalObject)
					(layout.internalObject as IInfoMapNodeLayout).plotThumbnails(thumbnailsToPlotArray,true);
			}
			
			private var _searchKeySet:KeySet = new KeySet();
			//sends a query to solr for the search keywords filtrered by document links belonging to this node
			private function handleGlobalSearch():void
			{
				
				if(!_parentPanel.globalSearchKeyword.value)
				{
					_searchKeySet.clearKeys();
					_searchKeySet.triggerCallbacks();
					return;
				}
				
				var fieldNames:Array = ['link'];
				
				var fieldValues:Array = [];
				
				fieldValues.push(thumbnails.getNames());
				
				if(!node.sources.value == '')
				{
					var sourceNames:Array = parser.parseCSV(node.sources.value)[0]; //we send only the first row since this is a one-line CSV String
				}
				
				
				_parentPanel.infoMapsDataSource.getDocumentsForQueryWithFieldValues(_searchKeySet,_parentPanel.globalSearchKeyword.value,fieldNames,fieldValues,sourceNames,"OR",node.dateFilter);
				
			}
			
			//this function is called when the _searchKeySet is set. 
			//This sets the thumbnail's visiblity based if its link is included or excluded in the _searchKeySet
			private function handleSearchKeySetChange():void
			{
				var tnails:Array = thumbnails.getObjects();
				
				var searchMatchedKeys:Array =_searchKeySet.keys; 
				
				if(searchMatchedKeys.length == 0)
				{
					//if searchKeys length is zero and if there is search keyword then none of the documents matched. So we set all visiblity to false
					//else set all to true;
					var visiblity:Boolean =  (_parentPanel.globalSearchKeyword.value != "");
					for each(var t1:DocThumbnailComponent in tnails)
					{
						var qKey1:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,t1.docURL.value);
						if(_subset.containsKey(qKey1))
							t1.visible = !visiblity;
					}
				}else
				{
					for each(var t2:DocThumbnailComponent in tnails)
					{
						var qKey2:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,t2.docURL.value);
						if(_subset.containsKey(qKey2))
							t2.visible = false;
					}
				}
				
				for each(var k:IQualifiedKey in searchMatchedKeys)
				{
					var t3:DocThumbnailComponent = thumbnails.getObject(k.localName) as DocThumbnailComponent;
					var qKey3:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,t3.docURL.value);
											
					if(t3 && _subset.containsKey(qKey3))
						t3.visible = true;
				}
				
			}
			
			private function handleGlobalDateChange():void
			{
				if(node.selected.value)
				{
					node.dateFilter.startDate.value = _parentPanel.globalDateFilter.startDate.value;
					node.dateFilter.endDate.value = _parentPanel.globalDateFilter.endDate.value;
				}
			}
			private function removeEmptyStringElementsFromArray(arg:Array):Array
			{
				var result:Array = [];
				for each(var item:String in arg)
				{
					if(item != "")
						result.push(item);
				}
				
				return result;
			}
			
			//toggle node selection on click
			private function handleClick(event:Event):void
			{
				if(wasDragged)
				{
					wasDragged = false;
					return;
				}
				if(node.selected.value)
					node.selected.value = false;
				else
					node.selected.value = true;
			}
			
			//highlight node based on node.selected.value
			private function highlightNode():void
			{
//				unselectedBorder.color = _parentPanel.defaultNodeBorderColor.value;
//				selectedBorder.color = _parentPanel.selectedNodeBorderColor.value;
//				
//				if(node.selected.value)
//					selectedBorder.play();
//				else
//					unselectedBorder.play();
			}
			
			//this variable will be  used to avoid selection/unselection when the node is dragged
			private var wasDragged:Boolean = false;
			protected function canvas1_mouseDownHandler(event:MouseEvent):void
			{
				event.stopImmediatePropagation();
				nodeBase.keywordTextArea.setStyle("fontWeight","bold");
				CustomCursorManager.showCursor(CustomCursorManager.HAND_GRAB_CURSOR);
				this.startDrag();
				this.addEventListener(MouseEvent.MOUSE_MOVE,handleMouseMove);
			}
			
			private function handleMouseMove(event:Event):void
			{
				wasDragged = true;
			}
			
			protected function canvas1_mouseUpHandler(event:MouseEvent):void
			{
				nodeBase.keywordTextArea.setStyle("fontWeight","normal");
				CustomCursorManager.removeCurrentCursor();
				this.stopDrag();
				this.removeEventListener(MouseEvent.MOUSE_MOVE,handleMouseMove);
			}
			
			private function keywordTextAreaKeyDownHandler(event:KeyboardEvent):void
			{
				if(event.keyCode == Keyboard.ENTER)
				{
					event.preventDefault();
					node.keywords.value = nodeBase.keywordTextArea.text;
					nodeBase.keywordTextArea.editable = false;
					nodeBase.keywordTextArea.selectable = false;
				}
			}
			
			private function handleCommentAreaChange(event:Event):void
			{
				var ta_height:uint = 20;
				
				nodeBase.commentTextArea.validateNow();
				
				for(var i:int=0; i < nodeBase.commentTextArea.mx_internal::getTextField().numLines; i++) {
					ta_height += nodeBase.commentTextArea.mx_internal::getTextField().getLineMetrics(i).height;
				}
				
				nodeBase.commentTextArea.height = ta_height;
				
				nodeBase.height +=  ta_height;
				nodeBase.invalidateDisplayList();
			}
			
			private function filter(event:Event):void
			{
				DateFilterComponent.openInstance(this,node.dateFilter);
			}
			
			private var _instance:NodeSettingsComponent = null;
			private function settings(event:Event):void
			{
				
				if(_instance)
				{
					PopUpManager.addPopUp(_instance,this);
				}
				else
				{
					_instance = new NodeSettingsComponent();
					_instance.nodeHandler = this;
					PopUpManager.addPopUp(_instance,this);
				}
			}
			
			private function close(event:Event):void
			{
				Alert.show("Are you sure you want to remove this node?",
					"Remove Node?",
					Alert.YES | Alert.NO,
					null,
					handleCloseEvent
				);
			}
			
			private function handleCloseEvent(e:CloseEvent):void
			{
				if(e.detail == Alert.YES)
				{
					thumbnails.removeAllObjects();
					var parent:ILinkableHashMap = (WeaveAPI.SessionManager.getLinkableOwner(this) as ILinkableHashMap);
					var nodeName:String  = parent.getName(this);
					parent.removeObject(nodeName);
				}
				else if(e.detail == Alert.NO)
				{
					return;
				}
			}			
			
			
		]]>
	</mx:Script>
	
</mx:Canvas>
