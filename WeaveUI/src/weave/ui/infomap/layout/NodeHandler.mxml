<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas xmlns:mx="http://www.adobe.com/2006/mxml" horizontalScrollPolicy="off" verticalScrollPolicy="off"
		   implements="weave.api.core.ILinkableObject"
		   cacheAsBitmap="false"
		   clipContent="false"
		   autoLayout="false"
		   dragDrop ="dragDropHandler(event)"
		   dragEnter="dragEnterHandler(event)"
		   >
	<!--Show this status box only when list is visible-->
	<mx:Label id="status" x="{nodeBase.keywordTextArea.width}" y="{nodeBase.keywordTextArea.height}" width="150"/>
	<mx:HBox horizontalAlign="left" id="statusBox" y="{nodeBase.height}" width="400" includeInLayout="false">
		<mx:Label id="filterStatus"/>
		<mx:Button focusAlpha="0" id="clearFiltersButton" label="Clear" visible="false" click="handleClearFiltersButton()"/>
		<!--HTML encoding is requried when writing code in binding tag-->
		<!--<mx:Button enabled="false" label="Mark All as Read" visible="false" id="clearNewDocuments" height="100%" click="clearAllNewDocuments()"/>-->
	</mx:HBox>
	<mx:Canvas id="pointsCanvas" enabled="false" visible="false" clipContent="false" width="400" height="300"/>
	<mx:Canvas id="listCanvas" visible="false" clipContent="false" width="400" height="300"/>
	<mx:Glow id="selectedBorder" 
			 alphaFrom="1.0" alphaTo="1.0"   
			 blurXFrom="10.0" blurYFrom="10.0" 
			 blurXTo="10.0" blurYTo="10.0"
			 duration="0" target="{nodeBase}"/>
	<mx:Glow id="unselectedBorder" 
			 alphaFrom="0.0" alphaTo="1.0"   
			 blurXFrom="10.0" blurYFrom="10.0" 
			 blurXTo="10.0" blurYTo="10.0"
			 duration="0" target="{nodeBase}"/>
	<mx:Fade id="fadeIn" alphaFrom="0.0" effectStart="handleFadeInEffectsStart(event)" alphaTo="1.0" duration="750" />
	<mx:Fade id="fadeOut" alphaFrom="1.0" effectEnd="handleFadeOutEffectsEnd(event)" alphaTo="0.0" duration="750" />
	<mx:Sequence id="newDocumentHighlight" target="{nodeBase.keywordTextArea}">
		<mx:Fade id="newDocumentFadeOut" alphaFrom="1.0" alphaTo="0.0" duration="1000" />
		<mx:Fade id="newDocumentFadeIn" alphaFrom="0.0" alphaTo="1.0" duration="1000" />
	</mx:Sequence>
	<mx:Script>
		<![CDATA[
			import flash.events.MouseEvent;
			import flash.geom.Point;
			import flash.net.URLRequest;
			import flash.net.navigateToURL;
			import flash.utils.Dictionary;
			
			import mx.collections.ArrayCollection;
			import mx.containers.TabNavigator;
			import mx.controls.Alert;
			import mx.controls.Image;
			import mx.controls.Label;
			import mx.controls.Text;
			import mx.controls.TextArea;
			import mx.core.Application;
			import mx.core.IUIComponent;
			import mx.core.UITextField;
			import mx.core.mx_internal;
			import mx.events.CloseEvent;
			import mx.events.DragEvent;
			import mx.events.EffectEvent;
			import mx.events.FlexEvent;
			import mx.events.SandboxMouseEvent;
			import mx.managers.CursorManager;
			import mx.managers.CursorManagerPriority;
			import mx.managers.DragManager;
			import mx.managers.PopUpManager;
			import mx.managers.PopUpManagerChildList;
			import mx.rpc.events.FaultEvent;
			import mx.rpc.events.ResultEvent;
			
			import weave.Weave;
			import weave.api.WeaveAPI;
			import weave.api.copySessionState;
			import weave.api.core.ILinkableHashMap;
			import weave.api.core.ILinkableObject;
			import weave.api.data.IAttributeColumn;
			import weave.api.data.IQualifiedKey;
			import weave.api.detectLinkableObjectChange;
			import weave.api.disposeObjects;
			import weave.api.getCallbackCollection;
			import weave.api.getLinkableOwner;
			import weave.api.getSessionState;
			import weave.api.linkBindableProperty;
			import weave.api.linkSessionState;
			import weave.api.newLinkableChild;
			import weave.api.registerLinkableChild;
			import weave.compiler.Compiler;
			import weave.compiler.StandardLib;
			import weave.core.LinkableDynamicObject;
			import weave.core.LinkableHashMap;
			import weave.core.LinkableNumber;
			import weave.core.LinkableString;
			import weave.core.SessionManager;
			import weave.core.SessionStateLog;
			import weave.core.StageUtils;
			import weave.core.UIUtils;
			import weave.data.AttributeColumns.KeyColumn;
			import weave.data.AttributeColumns.ReferencedColumn;
			import weave.data.CSVParser;
			import weave.data.ColumnReferences.HierarchyColumnReference;
			import weave.data.DataSources.InfoMapsDataSource;
			import weave.data.KeySets.KeyFilter;
			import weave.data.KeySets.KeySet;
			import weave.data.QKeyManager;
			import weave.primitives.ColorRamp;
			import weave.primitives.DateRangeFilter;
			import weave.services.DelayedAsyncInvocation;
			import weave.ui.CustomLabel;
			import weave.ui.ResizableBox;
			import weave.ui.infomap.core.FilterableInfoMapNode;
			import weave.ui.infomap.core.InfoMapDocument;
			import weave.ui.infomap.core.InfoMapNode;
			import weave.ui.infomap.core.MovedThumbnailPosition;
			import weave.ui.infomap.core.QueryObject;
			import weave.ui.infomap.ui.DateFilterComponent;
			import weave.ui.infomap.ui.DocThumbnailComponent;
			import weave.ui.infomap.ui.DocumentList;
			import weave.ui.infomap.ui.InfoMapPanel;
			import weave.ui.infomap.ui.NodeBaseComponent;
			import weave.ui.infomap.ui.NodeSettingsComponent;
			import weave.ui.infomap.ui.TagCloud;
			import weave.utils.BitmapUtils;
			import weave.utils.ColumnUtils;
			import weave.utils.CustomCursorManager;
			import weave.utils.DateUtils;
			import weave.utils.EventUtils;
			import weave.utils.VectorUtils;
			import weave.visualization.layers.InteractiveVisualization;
			
			public const node:FilterableInfoMapNode = newLinkableChild(this,FilterableInfoMapNode);
			
			private const query:QueryObject = newLinkableChild(this,QueryObject);
			
			public const previousQuery:QueryObject = newLinkableChild(this,QueryObject);
			
			public const xPos:LinkableNumber = newLinkableChild(this,LinkableNumber);
			public const yPos:LinkableNumber = newLinkableChild(this,LinkableNumber);
			
			public const layout:LinkableDynamicObject = newLinkableChild(this,LinkableDynamicObject,handleLayoutChange,true);
			
			public const thumbnails:LinkableHashMap = newLinkableChild(this,LinkableHashMap);
			
			public const thumbnailsDefaultColor:LinkableNumber = registerLinkableChild(this,new LinkableNumber(0));
			
			public const movedThumbNails:LinkableHashMap = newLinkableChild(this,LinkableHashMap);
			
			public const comments:LinkableString = newLinkableChild(this,LinkableString);
			
			public const numOfWordsInCloud:LinkableNumber = registerLinkableChild(this,new LinkableNumber(75,function(value:*):Boolean{
																if(value > 100)
																	return false;
																else 
																	return true;},false));
			
			private const listWidth:LinkableNumber = new LinkableNumber();
			
			private var loader:URLLoader = null;
			
			//we override the x,y value because we are binding the values to LinkableNumber 
			//which could be NaN when component loads for the first time
			override public function set x(value:Number):void
			{
				if(parent)
					super.x = isNaN(value)?parent.width/2:value;
				else
					super.x=value
			}
			
			override public function set y(value:Number):void
			{
				if(parent)
					super.y = isNaN(value)?parent.height/2:value;
				else
					super.y=value
				
			}
			
			private var _parentPanel:InfoMapPanel;
			private var _subset:KeyFilter = Weave.root.getObject(Weave.DEFAULT_SUBSET_KEYFILTER) as KeyFilter;
			
			//We create a private key filter for tag word click
			private var _tagWordSubset:KeyFilter = new KeyFilter();
			
			
			override protected function createChildren():void
			{
				
				super.createChildren();
				this.addChild(nodeBase);
			}
			
			//			private var log:SessionStateLog = new SessionStateLog(thumbnails);
			
			override protected function childrenCreated():void
			{
				
				
				super.childrenCreated();
				
				nodeBase.controlBox.visible = false;
				
				getCallbackCollection(query).addGroupedCallback(this,createAndSendQuery,true);
				getCallbackCollection(previousQuery).addGroupedCallback(this,updateTextArea,true);
				
				//if node is selected we highlight the nodeBase
				//				node.selected.addGroupedCallback(this,highlightNode);
				
				//for now defaulting to Random Layout
				if(layout.internalObject == null)
					layout.requestLocalObject(RandomLayout,false);
				(layout.internalObject as IInfoMapNodeLayout).parentNodeHandler = this;
				
				//opens the settings panel
				nodeBase.settingsImg.addEventListener(MouseEvent.CLICK,settings);
				
				nodeBase.tickImg.addEventListener(MouseEvent.CLICK,clearAllNewDocuments);
				
				//removes the node from the panel after confirmation
				nodeBase.closeImg.addEventListener(MouseEvent.CLICK,close);
				
				nodeBase.filterImg.addEventListener(MouseEvent.CLICK, toggleTagCloud);
				//				nodeBase.searchImg.addEventListener(MouseEvent.CLICK,showPointCanvas);
				nodeBase.listImg.addEventListener(MouseEvent.CLICK,toggleList);
				//drag and drop of the node will be use the text area as the handler/anchor point
				nodeBase.keywordTextArea.addEventListener(MouseEvent.MOUSE_DOWN,canvas1_mouseDownHandler);
				stage.addEventListener(MouseEvent.MOUSE_UP,canvas1_mouseUpHandler);
				nodeBase.keywordTextArea.addEventListener(KeyboardEvent.KEY_DOWN,keywordTextAreaKeyDownHandler);
				
				//drawing the base which is the node with keywords and icons
				(layout.internalObject as IInfoMapNodeLayout).drawBaseLayout(graphics);
				
				//sessioning the x and y positions of this node
				linkBindableProperty(xPos,this,"x");
				linkBindableProperty(yPos,this,"y");
				
				thumbnailsDefaultColor.addImmediateCallback(this,handleBorderColor,true);
				
				//sets a pointer to the node's parent which is an InfoMapPanel
				var hashmap:LinkableHashMap = WeaveAPI.SessionManager.getLinkableOwner(this) as LinkableHashMap;
				_parentPanel = WeaveAPI.SessionManager.getLinkableOwner(hashmap) as InfoMapPanel;
				
				//adding a callback to the Global Search keyword. This will set the visibility of the thumbnails to true or false
				//based on keyword match
//				_parentPanel.globalSearchKeyword.addImmediateCallback(this,handleGlobalSearch);
				
				//adding a callback to the Global Date Filter
				//TODO: needs to be tested
				_parentPanel.globalDateFilter.startDate.addGroupedCallback(this,handleGlobalDateChange);
				_parentPanel.globalDateFilter.endDate.addGroupedCallback(this,handleGlobalDateChange);
				
				//adding listener to Click event to toggle node selection
				nodeBase.keywordTextArea.addEventListener(MouseEvent.CLICK,handleClick);
				
				//adding callback to subset. Thumbnails will be re-drawn to plot only included thumbnails
				getCallbackCollection(_subset).addGroupedCallback(this,positionThumbnails);
				getCallbackCollection(_tagWordSubset).addGroupedCallback(this,positionThumbnails);
				
				//calling function to highlight the node based on node.selected.value
				//				highlightNode();
				
				//we want to trigger the callback for thumbnails at each frame and check the trigger counter
				getCallbackCollection(this).addImmediateCallback(this,invalidateDisplayList);
				
				//the set of keys matching the query is stored in docKeyset. 
				//when the results are stored in this keySet a callback is triggered for parsing the results
				docKeySet.addGroupedCallback(this,handleThumbnails,false);
				
				//this keySet stores the keys matching the search query.
				//when the results are stored in this keySet a callback is triggered for setting the thumbnails' visible to true/false
				_searchKeySet.addImmediateCallback(this,handleSearchKeySetChange,true);
				
				//adding a callback to the selection KeySet to highlight/unhighlight documents
				_selection.addGroupedCallback(this,handleSelectionKeySetChange);
				
				filteredWords.addGroupedCallback(this,filterListByKeywords,false);
				
				thumbnails.addGroupedCallback(this,positionThumbnails);
				
				//				nodeBase.editImage.addEventListener(MouseEvent.CLICK,handleEditCommentsClick);
				//				
				//				delayedCommentKeyUp = EventUtils.generateDelayedCallback(nodeBase.commentTextArea,handleCommentKeyUp,500,true);
				//				nodeBase.commentTextArea.addEventListener(KeyboardEvent.KEY_UP,delayedCommentKeyUp); 
				//				nodeBase.commentTextArea.addEventListener(FocusEvent.FOCUS_OUT,updateCommentTextArea);
				
				clickedWordKeySet.addImmediateCallback(this,handleClickedWordKeySetChange);
				prevNewDocsCount.addGroupedCallback(this,updateTextArea);
				
				numOfWordsInCloud.addGroupedCallback(this,redrawWordCloud,false);
				
				refreshTimer.start();
				//call event for each tick of refreshTimer
				refreshTimer.addEventListener(TimerEvent.TIMER, checkForNewDocuments);
				
				//				comments.addImmediateCallback(this,handleCommentsChange,true);
				
				//				createAndSendQuery();
				
				glowFilter.color = thumbnailsDefaultColor.value;
				
			}
			
			private var delayedCommentKeyUp:Function = null;
			
			//			
			
			
			private function dragEnterHandler(event:DragEvent):void
			{
				
				//				if(event.dragInitiator is DocThumbnailComponent && movedThumbNails.getObject((event.dragInitiator as DocThumbnailComponent).docURL.value))
				//				{
				//					DragManager.acceptDragDrop(this);
				//				}
			}
			
			private function dragDropHandler(event:DragEvent):void
			{
				//				var t:DocThumbnailComponent = event.dragInitiator as DocThumbnailComponent;
				//				
				//				if(!(t.parent == this))
				//				{
				//					movedThumbNails.removeObject(t.docURL.value);
				//					
				//					pointsCanvas.addChild(t);
				//					
				//					t.hasBeenMoved.value = false;
				//					
				//					//setting the X and Y with reference to the map
				////					var tGlobalPoint2:Point = _parentPanel.map.contentToGlobal(new Point(event.stageX,event.stageY));
				//					var localPoint2:Point =  this.globalToLocal(new Point(event.stageX,event.stageY));
				//					
				//					t.move(localPoint2.x,localPoint2.y);
				//					
				//				}
			}
			
			
			private var refreshTimer:Timer = new Timer(60*5*1000);
			
			//this variable is false when the user loads the map for the first time. 			
			private var highlightNewDocuments:Boolean = true;
			private function checkForNewDocuments(event:TimerEvent):void
			{
				if(!previousQuery.sources.value == '')
				{
					var sourceNames:Array = parser.parseCSV(previousQuery.sources.value)[0]; //we send only the first row since this is a one-line CSV String
				}
				//emptying wordCount before sending it. I am using concat in the InfoMapDataSource.
				wordCount = [];
				status.text = "Searching...";
				_parentPanel.infoMapsDataSource.getDocumentsForQuery(docKeySet,wordCount,query.keywords.value,query.operator.value,sourceNames,query.dateFilter);
			}
			
			
			
			private function updateTextArea():void
			{
				if(!previousQuery.keywords.value)
				{
					nodeBase.keywordTextArea.editable = true;
					nodeBase.keywordTextArea.selectable = true;
					nodeBase.keywordTextArea.setFocus();
					nodeBase.keywordTextArea.setSelection(0,0);
					nodeBase.keywordTextArea.htmlText = "";
					newDocumentHighlight.stop();//in case node is blinking
					stopGlow()
					if(listCanvas.contains(d))
					{
						d.docKeys = [];//clearing items in list
						hideList();
					}
					if(tagCanvas)
					{
						hideTagCloud();
						tagCanvas.clearCloud();
						tagCanvas.dataProvider = [];//clearing word cloud
						removeChild(tagCanvas);
						tagCanvas = null;
					}
					return;
				}
				
//				nodeBase.keywordTextArea.htmlText = "<b>Query: </b> " + previousQuery.keywords.value;
				nodeBase.keywordTextArea.htmlText = previousQuery.keywords.value + "()";
				nodeBase.keywordTextArea.editable = false;
				nodeBase.keywordTextArea.selectable = false;
				
				var diff:* = WeaveAPI.SessionManager.computeDiff(WeaveAPI.SessionManager.getSessionState(previousQuery),WeaveAPI.SessionManager.getSessionState(query));
				
				if(diff)
					copySessionState(previousQuery,query);
				
				testAndBlinkNode();
			}
			
			private function testAndBlinkNode():void
			{
				if((prevNewDocsCount.value>0) || (highlightNewDocuments && currentNewDocsCount>0 && currentNewDocsCount != prevNewDocsCount.value))
				{
					if(nodeBase.keywordTextArea.htmlText.indexOf("/") >-1)
						nodeBase.keywordTextArea.htmlText = nodeBase.keywordTextArea.htmlText.replace(/\([0-9]*\//g,"(" + currentNewDocsCount + "/");
					else
						nodeBase.keywordTextArea.htmlText = nodeBase.keywordTextArea.htmlText.replace(/\(/g,"(" + currentNewDocsCount + "/");
						
					
					nodeBase.tickImg.enabled = true;
					nodeBase.tickImg.visible = true;
					if(currentNewDocsCount != prevNewDocsCount.value || !_wasClicked)
					{
						startGlow();
					}
				}else{
					nodeBase.tickImg.enabled = false;
					nodeBase.tickImg.visible = false;
					stopGlow();
				}
				
				positionThumbnails();
				adjustNodeBase();
			}
			
			/* Since we use a private query object we define a public function to set variable */
			public function applyKeywords(keywords:String):void
			{
				query.keywords.value = keywords;	
			}
			
			[Bindable]
			public var nodeBase:NodeBaseComponent = new NodeBaseComponent();
			
			private var docKeySet:KeySet = new KeySet();
			
			/**
			 * @private
			 * This functions creates a query based on the keywords,operator and filters applied and sends a request to the Solr server
			 **/
			private function createAndSendQuery():void
			{
				trace("in createAndSendQuery");
				//this function is called every time the query parameters changes, so we will reset the timer so that it is not called immediately
				//when the query changes. This way we can avoid adding old results for a new query.
				refreshTimer.reset();
				refreshTimer.start();
				
				if(!query.keywords.value)
				{
					getCallbackCollection(previousQuery).delayCallbacks();
					thumbnails.delayCallbacks();
					previousQuery.keywords.value = ""; //clearing previous query
					thumbnails.removeAllObjects();//remove any old objects if any
					getCallbackCollection(previousQuery).resumeCallbacks();
					thumbnails.resumeCallbacks();
					return;
				}
				
				if (this.parent == null)
				{
					WeaveAPI.StageUtils.callLater(this,createAndSendQuery);
					return;
				}
				status.text = "Searching...";
				
				//delay callbacks till we get back query results
				thumbnails.delayCallbacks();

				var diff:* = WeaveAPI.SessionManager.computeDiff(WeaveAPI.SessionManager.getSessionState(previousQuery),WeaveAPI.SessionManager.getSessionState(query));
				if(diff)//diff is undefined if there is no difference.
				{
					thumbnails.removeAllObjects();
					currentNewDocsCount = 0;
					hideList();
					hideTagCloud();
				}
				
				
				if(!query.sources.value == '')
				{
					var sourceNames:Array = parser.parseCSV(query.sources.value)[0]; //we send only the first row since this is a one-line CSV String
				}
				
				for each(var t:DocThumbnailComponent in thumbnails.getObjects())
				{
					if(t.highlighted.value)
						currentNewDocsCount++;
				}
				
				
				//emptying wordCount before sending it. I am using concat in the InfoMapDataSource.
				wordCount = [];
				
				
				_parentPanel.infoMapsDataSource.getDocumentsForQuery(docKeySet,wordCount,query.keywords.value,query.operator.value,sourceNames,query.dateFilter);
				
				//				var numOfDocsQuery:DelayedAsyncInvocation = InfoMapsDataSource.getNumberOfMatchedDocuments(
				//											query.keywords.value,query.operator.value,sourceNames,query.dateFilter);
				
				//				numOfDocsQuery.addAsyncResponder(function(event:ResultEvent,token:Object=null):void{
				//					nodeBase.keywordTextArea.htmlText +="<b>Total Documents Found:</b> " +  event.result.toString();
				//					adjustNodeBase();
				//					status.text = "";
				//				},function(event:FaultEvent,token:Object=null):void{
				//					nodeBase.keywordTextArea.htmlText +="<br/>No documents found" ;
				//				});
				
				
			}
			
			private var parser:CSVParser = new CSVParser();
			private var timer:Timer = new Timer(2000);
			
			public const prevNewDocsCount:LinkableNumber = registerLinkableChild(this,new LinkableNumber(0)); 
			[Bindable]
			private var currentNewDocsCount:int = 0;
			//			private var _firstLoad:Boolean = true;
			
			/**
			 * @private
			 * This function takes an array collection of links and requests a thumbnail object to display the document object
			 * for each of the corresponding links.
			 * If the thumbnail object is already there then we use the replace its doc object with the latest doc object. 
			 **/
			private function handleThumbnails():void
			{
				trace("in handleThumbnails");
				status.text = "";
				nodeBase.controlBox.visible = true;
				var response:Array = docKeySet.keys;
				
				//				if(d.docList != null)
				//					d.docList.dataProvider = docKeySet.keys;
				
				var nameOrder:Array = [];
				
				//				if(response.length == 0)
				//				{
				//					thumbnails.resumeCallbacks();
				//					getCallbackCollection(node).resumeCallbacks();
				//					return;
				//				}
				
				var diff:* = WeaveAPI.SessionManager.computeDiff(WeaveAPI.SessionManager.getSessionState(previousQuery),WeaveAPI.SessionManager.getSessionState(query));
				if(diff)
				{
					//its a new query
					thumbnails.removeAllObjects();
					highlightNewDocuments = false;
				}else{
					//its an old query
					if(thumbnails.getObjects().length == 0)
						highlightNewDocuments = false;
					else
						highlightNewDocuments = true;
				}
				
				
				for(var i:int; i<response.length ;i++)
				{
					
					var link:String = (response[i] as IQualifiedKey).localName;					
					nameOrder.push(link);
					var thumbnail:DocThumbnailComponent = thumbnails.getObject(link) as DocThumbnailComponent;
					
					
					if(!thumbnail)
					{
						thumbnail = thumbnails.requestObject(link,DocThumbnailComponent,false);
						
						if(highlightNewDocuments)
						{
							thumbnail.highlighted.value = true;
							currentNewDocsCount++;
						}
					}
					
					
					thumbnail.docURL.value = link;
					
					//					linkSessionState(_parentPanel.defaultThumbnailBorderColor,thumbnail.defaultBorderColor);
					linkSessionState(_parentPanel.selectedThumbnailBorderColor,thumbnail.selectedBorderColor);
					linkSessionState(_parentPanel.newThumbnailGlowColor,thumbnail.glowColor);
					
				}
				
				
//				if(!highlightNewDocuments)
//				{
//					currentNewDocsCount = 0;
//				}
				
				thumbnails.setNameOrder(nameOrder);
				WeaveAPI.SessionManager.copySessionState(query,previousQuery);
				thumbnails.resumeCallbacks();
				prevNewDocsCount.value = currentNewDocsCount;
				testAndBlinkNode();
			}
			
			private function clearAllNewDocuments(event:Event=null):void
			{
				currentNewDocsCount = 0;
				
				for each(var t:DocThumbnailComponent in thumbnails.getObjects())
				{
					t.highlighted.value = false;
				}
				stopGlow();
				prevNewDocsCount.value = 0;
				currentNewDocsCount = 0;
				nodeBase.tickImg.visible = false;
//				updateTextArea();
			}
			
			private var glowFilter:GlowFilter = new GlowFilter();
			private var glowTimer:Timer = new Timer(125);
			private function startGlow():void
			{
					nodeBase.keywordTextArea.filters = [glowFilter];
					glowTimer.addEventListener(TimerEvent.TIMER,changeGlow);
					glowTimer.start();
			}
			
			private function changeGlow(event:TimerEvent):void
			{
				glowFilter.alpha = 0.125 + (event.target.currentCount % 8) *0.125;
				glowFilter.color = thumbnailsDefaultColor.value;
				nodeBase.keywordTextArea.filters=[glowFilter];
			}
			
			private function stopGlow():void
			{
				glowTimer.stop();
				nodeBase.keywordTextArea.filters = [];
				nodeBase.keywordTextArea.alpha = 1;//restore alpha value to 1 incase timer stops at lesser alpha value
			}
			
			private function adjustNodeBase():void
			{
				nodeBase.keywordTextArea.validateNow();
				nodeBase.width = nodeBase.keywordTextArea.textWidth + 50;
				nodeBase.keywordTextArea.width = nodeBase.width;
				nodeBase.keywordTextArea.height= nodeBase.keywordTextArea.mx_internal::getTextField().numLines * 20;
				nodeBase.height = nodeBase.keywordTextArea.height+ 30;
			}
			
			override public function validateDisplayList():void
			{
				super.validateDisplayList();
				//				if(detectLinkableObjectChange(invalidateDisplayList,thumbnails,movedThumbNails))
				//					positionThumbnails();
			}
			
			public var thumbnailsToPlotArray:Array = [];
			
			/**
			 * This function goes through the list of thumbnails and adds the ones included in the subset to an array.
			 * This array is then sent to a Layout Algorithm to plot the thumbnails. 
			 * After the thumbnails are plotted we call the functions to highlight selected documents and set visiblity based on search keywords.
			 **/
			private function positionThumbnails():void
			{
				//				nodeBase.keywordTextArea.text = query.keywords.value;
				trace("in positionThumbnails");
				if(!previousQuery.keywords.value)
					return;
				pointsCanvas.y = nodeBase.height;
				
				thumbnailsToPlotArray = [];
				var tNails:Array = thumbnails.getObjects()
				
//				if(nodeBase.keywordTextArea.htmlText.indexOf("Total Documents") >-1)
//					nodeBase.keywordTextArea.htmlText = nodeBase.keywordTextArea.htmlText.replace(/Total Documents Found:<\/B> [0-9]*/g,"Total Documents Found:<\/B> " + tNails.length);
//				else
//					nodeBase.keywordTextArea.htmlText +="<br/><b>Total Documents Found:</b> " +  tNails.length;
				
				if(nodeBase.keywordTextArea.htmlText.indexOf("/") >-1)
					nodeBase.keywordTextArea.htmlText = nodeBase.keywordTextArea.htmlText.replace(/\/[0-9]*/g,"/" + tNails.length);
				else
					nodeBase.keywordTextArea.htmlText = nodeBase.keywordTextArea.htmlText.replace(/\([0-9]*/g,"(" + tNails.length);
				
				adjustNodeBase();	
				
				for (var i:int = 0; i<tNails.length; i++)
				{
					var t:DocThumbnailComponent = tNails[i];
					
					t.defaultBorderColor.value = thumbnailsDefaultColor.value;
					
					//first check to see if the thumbnail is present in movedThumbnails
					var position:MovedThumbnailPosition = movedThumbNails.getObject(t.docURL.value) as MovedThumbnailPosition;
					
					//if the document exists in movedThumbnails then make sure to set the moved positions and set hasBeenMoved to true;
					if(position)
					{
						t.hasBeenMoved.value = true;
						
						copySessionState(position.xPos,t.xPos);
						copySessionState(position.yPos,t.yPos);
					}
					
					
					//if thumbnail has been moved make sure to add it as a child to Panel else make sure to add it as child to node.
					if(t.hasBeenMoved.value)
					{
						if(t.parent != _parentPanel.map)
						{
							_parentPanel.map.addChild(t);
							
						}
						//xPos and yPos are not linked
						t.move(t.xPos.value,t.yPos.value);
						
					}else
					{
						if(t.parent != this)
						{
							t.visible = false;
							//							pointsCanvas.addChild(t);
						}
					}
					
					
					var docURL:String = thumbnails.getName(t);
					var qKey:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,docURL);
					
					//TODO: Handle subsets
					
					
					if(_subset.containsKey(qKey) && _tagWordSubset.containsKey(qKey))
					{
						thumbnailsToPlotArray.push(t);
						t.visible = true;
					}else{
						
						t.visible = false;
					}
					
				}
				//				(layout.internalObject as IInfoMapNodeLayout).plotThumbnails(thumbnailsToPlotArray);
				d.docKeys = thumbnailsToPlotArray;
				handleSelectionKeySetChange();
				adjustNodeBase();
//				handleGlobalSearch();
			}
			
			//			private function positionMovedthumbNails():void
			//			{
			//				var thumbnailNames:Array = movedThumbNails.getNames();	
			//				
			//				for each (var url:String in thumbnailNames)
			//				{
			//					var t:DocThumbnailComponent = thumbnails.getObject(url) as DocThumbnailComponent;
			//					
			//					if(!t)
			//						continue;
			//					
			//					if(t.parent != _parentPanel.map)
			//					{
			//						_parentPanel.map.addChild(t);
			//					}
			//					
			//					var position:MovedThumbnailPosition = movedThumbNails.getObject(url) as MovedThumbnailPosition;
			//					
			//					copySessionState(position.xPos,t.xPos);
			//					copySessionState(position.yPos,t.yPos);
			//					
			//				}
			//			}
			
			private var _selection:KeySet = Weave.root.getObject(Weave.DEFAULT_SELECTION_KEYSET) as KeySet;
			/**
			 * Highlights selected documents
			 **/
			private function handleSelectionKeySetChange():void
			{
				var docs:Array = thumbnails.getNames();
				
				var selectedDocs:Array = getSelectedDocumentKeys();
				
				//if none are selected set all to 
				if(selectedDocs.length == 0)
				{
					for each(var doc1:String in docs)
					{
						var t1:DocThumbnailComponent = thumbnails.getObject(doc1) as DocThumbnailComponent;
						t1.setMode(DocThumbnailComponent.DEFAULT_MODE);
					}
					return;
				}
				
				for each(var doc:String in docs)
				{
					var qKey:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,doc);
					var t:DocThumbnailComponent = thumbnails.getObject(doc) as DocThumbnailComponent;
					var selected:Boolean =_selection.containsKey(qKey) 
					if(selected)
						t.setMode(DocThumbnailComponent.SELECTED_MODE);
					else
						t.setMode(DocThumbnailComponent.UNSELECTED_MODE);
				}
			}
			
			
			private function getSelectedDocumentKeys():Array
			{
				var selectedKeys:Array = _selection.keys;
				var selectedDocs:Array = [];
				
				for each(var key:IQualifiedKey in selectedKeys)
				{
					if(key.keyType == InfoMapsDataSource.DOC_KEYTYPE)
						selectedDocs.push(key);
				}
				
				return selectedDocs;
			}
			
			/**
			 * redraw thumbnails to handle new layout selection
			 **/
			private function handleLayoutChange():void
			{
				if(layout.internalObject == null)
					return;
				(layout.internalObject as IInfoMapNodeLayout).parentNodeHandler = this;
				(layout.internalObject as IInfoMapNodeLayout).drawBaseLayout(graphics);
				//				(layout.internalObject as IInfoMapNodeLayout).plotThumbnails(thumbnailsToPlotArray,true);
			}
			
			private function handleSpacingChange():void
			{
				if(layout.internalObject)
					(layout.internalObject as IInfoMapNodeLayout).plotThumbnails(thumbnailsToPlotArray,true);
			}
			
			private var _searchKeySet:KeySet = new KeySet();
			//sends a query to solr for the search keywords filtrered by document links belonging to this node
			private function handleGlobalSearch():void
			{
				
//				if(!_parentPanel.globalSearchKeyword.value)
//				{
////					_searchKeySet.clearKeys();
////					_searchKeySet.triggerCallbacks();
//					return;
//				}
//				
//				var fieldNames:Array = ['link'];
//				
//				var fieldValues:Array = [];
//				
//				fieldValues.push(thumbnails.getNames());
//				
//				if(!query.sources.value == '')
//				{
//					var sourceNames:Array = parser.parseCSV(query.sources.value)[0]; //we send only the first row since this is a one-line CSV String
//				}
//				
//				_parentPanel.infoMapsDataSource.getDocumentsForQueryWithFieldValues(_searchKeySet,_parentPanel.globalSearchKeyword.value,fieldNames,fieldValues,null,"OR",null,2000,false);
				
				
//				filteredWords.value = 
			}
			
			public function filterBy(keywords:String):void
			{
				filteredWords.value = keywords;
			}
			
			//this function is called when the _searchKeySet is set. 
			//This sets the thumbnail's visiblity based if its link is included or excluded in the _searchKeySet
			private function handleSearchKeySetChange():void
			{
				//				var tnails:Array = thumbnails.getObjects();
				//				
				//				var searchMatchedKeys:Array =_searchKeySet.keys; 
				//				
				//				if(searchMatchedKeys.length == 0)
				//				{
				//					//if searchKeys length is zero and if there is search keyword then none of the documents matched. So we set all visiblity to false
				//					//else set all to true;
				//					var visiblity:Boolean =  (_parentPanel.globalSearchKeyword.value != "");
				//					for each(var t1:DocThumbnailComponent in tnails)
				//					{
				//						var qKey1:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,t1.docURL.value);
				//						if(_subset.containsKey(qKey1))
				//						{
				//							
				//							t1.visible = !visiblity;
				//						}
				//					}
				//				}else
				//				{
				//					for each(var t2:DocThumbnailComponent in tnails)
				//					{
				//						var qKey2:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,t2.docURL.value);
				//						if(_subset.containsKey(qKey2))
				//						{
				//							
				//							t2.visible = false;
				//						}
				//					}
				//				}
				//				
				//				for each(var k:IQualifiedKey in searchMatchedKeys)
				//				{
				//					var t3:DocThumbnailComponent = thumbnails.getObject(k.localName) as DocThumbnailComponent;
				//					
				//					if(!t3)
				//						continue;
				//					
				//					var qKey3:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,t3.docURL.value);
				//								
				//					
				//					if(t3 && qKey3 && _subset.containsKey(qKey3))
				//					{
				//						
				//						t3.visible = true;
				//					}
				//				}
				
			}
			
			private function handleGlobalDateChange():void
			{
				getCallbackCollection(query).delayCallbacks();
				query.dateFilter.startDate.value = _parentPanel.globalDateFilter.startDate.value;
				query.dateFilter.endDate.value = _parentPanel.globalDateFilter.endDate.value;
				getCallbackCollection(query).resumeCallbacks();
			}
			private function removeEmptyStringElementsFromArray(arg:Array):Array
			{
				var result:Array = [];
				for each(var item:String in arg)
				{
					if(item != "")
						result.push(item);
				}
				
				return result;
			}
			
			
			private var _wasClicked:Boolean = false;
			//toggle node selection on click
			private function handleClick(event:Event):void
			{
				//if running to blink node.
				stopGlow();
				
				_wasClicked = true;
				
				if(wasDragged)
				{
					wasDragged = false;
					return;
				}
				//				if(node.selected.value)
				//					node.selected.value = false;
				//				else
				//					node.selected.value = true;
			}
			
			//highlight node based on node.selected.value
			private function highlightNode():void
			{
				//				unselectedBorder.color = _parentPanel.defaultNodeBorderColor.value;
				//				selectedBorder.color = _parentPanel.selectedNodeBorderColor.value;
				//				
				//				if(node.selected.value)
				//					selectedBorder.play();
				//				else
				//					unselectedBorder.play();
			}
			
			//this variable will be  used to avoid selection/unselection when the node is dragged
			private var wasDragged:Boolean = false;
			private var _lastX:Number = 0;
			private var _lastY:Number = 0;
			private var sbroot:DisplayObject = Application.application.systemManager.getSandboxRoot();
			private var handCursorID:int = -1;
			protected function canvas1_mouseDownHandler(event:MouseEvent):void
			{
				event.stopImmediatePropagation();
				nodeBase.keywordTextArea.setStyle("fontWeight","bold");
				handCursorID = CustomCursorManager.showCursor(InteractiveVisualization.CURSOR_HAND_GRAB);
				_lastX = x;
				_lastY = y;
				this.addEventListener(MouseEvent.MOUSE_MOVE,handleMouseMove);
				// solution for handling mous_up outside of stage : http://stackoverflow.com/questions/2944122/flash-correctly-handling-click-and-drag-outside-the-browser
				sbroot.addEventListener(SandboxMouseEvent.MOUSE_UP_SOMEWHERE, handleMouseUpSomewhere);
				this.startDrag();
			}
			
			private function handleMouseMove(event:Event):void
			{
				wasDragged = true;
			}
			
			private var stageUtils:StageUtils = new StageUtils();
			protected function canvas1_mouseUpHandler(event:Event):void
			{
				nodeBase.keywordTextArea.setStyle("fontWeight","normal");
				CustomCursorManager.removeCursor(handCursorID);
				this.removeEventListener(MouseEvent.MOUSE_MOVE,handleMouseMove);
				sbroot.removeEventListener(SandboxMouseEvent.MOUSE_UP_SOMEWHERE, handleMouseUpSomewhere);
				this.stopDrag();
			}
			
			private function handleMouseUpSomewhere(event:Event):void
			{
				this.x = _lastX;
				this.y = _lastY;
				canvas1_mouseUpHandler(event);
			}
			
			private function keywordTextAreaKeyDownHandler(event:KeyboardEvent):void
			{
				if(event.keyCode == Keyboard.ENTER)
				{
					event.preventDefault();
					query.keywords.value = nodeBase.keywordTextArea.text;
					nodeBase.keywordTextArea.editable = false;
					nodeBase.keywordTextArea.selectable = false;
				}
			}
			
			private function filter(event:Event):void
			{
				DateFilterComponent.openInstance(this,query.dateFilter);
			}
			
			private var _instance:NodeSettingsComponent = null;
			private function settings(event:Event):void
			{
				
				if(_instance)
				{
					PopUpManager.addPopUp(_instance,this);
				}
				else
				{
					_instance = new NodeSettingsComponent();
					_instance.query = this.query;
					_instance.nodeHandler = this;
					PopUpManager.addPopUp(_instance,this);
				}
			}
			
			private function close(event:Event):void
			{
				Alert.show("Are you sure you want to remove this node?",
					"Remove Node?",
					Alert.YES | Alert.NO,
					null,
					handleCloseEvent
				);
			}
			
			private var tagCanvas:TagCloud = null;
			private var colorRamp:ColorRamp = new ColorRamp();
			private var wordCount:Array = [];
			private function toggleTagCloud(event:Event=null,forceShow:Boolean=false,forceHide:Boolean=false):void
			{
				clearFiltersButton.visible = false;
				//				statusBox.y = nodeBase.height + statusBox.height;
				if(tagCanvas == null)
				{
					tagCanvas = new TagCloud();
					tagCanvas.addEventListener(MouseEvent.CLICK,handleTagCloudClick);
					tagCanvas.alpha = 0;
					tagCanvas.includeInLayout = false;
					addChild(tagCanvas);
				}
				tagCanvas.y= nodeBase.height;
				if(StandardLib.arrayCompare(tagCanvas.dataProvider,wordCount) != 0)
				{
					tagCanvas.dataProvider = wordCount;
					tagCanvas.draw(numOfWordsInCloud.value);
				}
				fadeOut.play([pointsCanvas,listCanvas]);
				if(forceShow)
				{
					fadeIn.play([tagCanvas]);
					return;
				}
				
				if(forceHide)
				{
					fadeOut.play([tagCanvas]);
					return;
				}
				
				//toggle
				if(tagCanvas.alpha ==0)
					fadeIn.play([tagCanvas]);
				else
					fadeOut.play([tagCanvas]);
				
			}
			
			private function redrawWordCloud():void
			{
				if(tagCanvas != null)
				{
					tagCanvas.dataProvider = [];//clearing word cloud
					removeChild(tagCanvas);
					tagCanvas = null;
					showTagCloud();
				}
			}
			
			public function showTagCloud():void
			{
				toggleTagCloud(null,true);
			}
			
			public function hideTagCloud():void
			{
				toggleTagCloud(null,false,true);
			}
			
			private var d:DocumentList = new DocumentList();
			private function toggleList(event:Event=null,forceShow:Boolean=false,forceHide:Boolean=false):void
			{
				//if the list is not added yet
				if(!listCanvas.contains(d))
				{
					listCanvas.visible = false;
					listCanvas.addChild(d);
					
					d.y = nodeBase.height + statusBox.height;
					statusBox.y = d.y-statusBox.height;
					
					if(forceHide)
						return;
					
					fadeIn.play([listCanvas]);
					//hide other canvases 
					if(tagCanvas)
						fadeOut.play([tagCanvas,pointsCanvas]);
					else 
						fadeOut.play([pointsCanvas]);
					return;
				}
				
				d.y = nodeBase.height + statusBox.height;
				statusBox.y = d.y-statusBox.height;
				
				//hide other canvases 
				if(tagCanvas)
					fadeOut.play([tagCanvas,pointsCanvas]);
				else 
					fadeOut.play([pointsCanvas]);
				
				if(forceShow)
				{
					fadeIn.play([listCanvas]);
					return;
				}
				
				if(forceHide)
				{
					fadeOut.play([listCanvas]);
					return;
				}	
				
				//toggle list
				if(listCanvas.alpha == 0)
				{
					fadeIn.play([listCanvas]);
				}
					
				else
				{
					fadeOut.play([listCanvas]);
				}
			}
			
			public function showList():void
			{
				toggleList(null,true,false);
			}
			
			public function hideList():void
			{
				toggleList(null,false,true);
			}
			
//			private function showPointCanvas(event:Event):void
//			{
//				
//				if(!(tagCanvas == null))
//					fadeOut.play([tagCanvas,listCanvas,clearNewDocuments]);
//				else
//					fadeOut.play([listCanvas,clearNewDocuments]);
//				(layout.internalObject as RandomLayout).updateTitleLabel();
//				fadeIn.play([pointsCanvas]);
//			}
			
			private var clickedWordKeySet:KeySet = new KeySet();
			private var filteredWords:LinkableString = new LinkableString("",null,false);
			private function handleTagCloudClick(event:MouseEvent):void
			{
				//we don't use the event.target for getting the text because this is based on the bounding box clicked and not necessarily the 
				//probed word. So we used the last recorded probed word
				if(event.target is CustomLabel)
					filteredWords.value= ((event.target as CustomLabel).parent as TagCloud).lastProbedWord.value;
				else
					return;
			}
			
			private function filterListByKeywords():void
			{
				if(!filteredWords.value)
					return;
				
				if(!query.sources.value == '')
				{
					var sourceNames:Array = parser.parseCSV(query.sources.value)[0]; //we send only the first row since this is a one-line CSV String
				}
				
				_parentPanel.infoMapsDataSource.getDocumentsForQuery(clickedWordKeySet,[],query.keywords.value + " " + filteredWords.value,"AND",sourceNames,query.dateFilter);
				status.htmlText= "Filtering list...";
				clearFiltersButton.visible = false;
				//				statusBox.width = 200;
				showList();
			}
			
			private function handleClickedWordKeySetChange():void
			{
				var keys:Array = clickedWordKeySet.keys;
				var includeKeys:Array = [];
				
				for each(var k:IQualifiedKey in keys)
				{
					if(thumbnails.getObject(k.localName))
					{
						includeKeys.push(k);	
					}
				}
				
				//				_subset.replaceKeys(false,true,includeKeys);
				_tagWordSubset.replaceKeys(false,true,includeKeys);
				status.text = "";
				filterStatus.htmlText= "<b>Filtered by: </b>" + filteredWords.value;
				clearFiltersButton.visible = true;
				
			}
			
			private function handleClearFiltersButton():void
			{
				_tagWordSubset.replaceKeys(true,true);
				filterStatus.text = "";
				clearFiltersButton.visible = false;
				filteredWords.value = "";
			}
			
			private function handleFadeInEffectsStart(event:EffectEvent):void
			{
				(event.effectInstance.target as DisplayObject).visible = true;
			}
			
			private function handleFadeOutEffectsEnd(event:EffectEvent):void
			{
				(event.effectInstance.target as DisplayObject).visible = false;
			}
			
			private function handleBorderColor():void
			{
				nodeBase.keywordTextArea.setStyle("borderColor",thumbnailsDefaultColor.value);
			}
			
			private function handleCloseEvent(e:CloseEvent):void
			{
				if(e.detail == Alert.YES)
				{
					thumbnails.removeAllObjects();
					var parent:ILinkableHashMap = (WeaveAPI.SessionManager.getLinkableOwner(this) as ILinkableHashMap);
					var nodeName:String  = parent.getName(this);
					parent.removeObject(nodeName);
				}
				else if(e.detail == Alert.NO)
				{
					return;
				}
			}			
			
			//							private function handleEditCommentsClick(event:MouseEvent):void
			//			{
			//				nodeBase.editImage.visible = false;
			//				nodeBase.commentTextArea.visible = true;
			//				nodeBase.commentTextArea.setFocus();
			//			}
			//			
			//			private function handleCommentsChange():void
			//			{
			//				if(nodeBase.commentTextArea.text != comments.value)
			//					nodeBase.commentTextArea.text = comments.value;
			//				if(comments.value)
			//				{
			//					nodeBase.commentTextArea.visible = true;
			//					nodeBase.editImage.visible = false;
			//					nodeBase.commentTextArea.validateNow();
			//				}else{
			//					nodeBase.commentTextArea.visible = false;
			//					nodeBase.editImage.visible = true;
			//				}
			//			}
			//			
			//			private function handleCommentKeyUp(event:KeyboardEvent=null):void
			//			{
			//				
			//				comments.value = nodeBase.commentTextArea.text;
			//				if(event.keyCode == Keyboard.ESCAPE)
			//				{
			//					updateCommentTextArea();
			//					nodeBase.keywordTextArea.setFocus();
			//				}
			//			}
			//			
			//			private function updateCommentTextArea(event:Event=null):void
			//			{
			//				nodeBase.commentTextArea.minHeight = nodeBase.commentTextArea.textHeight;
			//
			//				if(nodeBase.commentTextArea.text == "")
			//				{
			//					comments.triggerCallbacks();
			//				}
			//			}	
			
			
			//			private function handleCommentAreaChange(event:Event):void
			//			{
			//				var ta_height:uint = 20;
			//				
			//				nodeBase.commentTextArea.validateNow();
			//				
			//				for(var i:int=0; i < nodeBase.commentTextArea.mx_internal::getTextField().numLines; i++) {
			//					ta_height += nodeBase.commentTextArea.mx_internal::getTextField().getLineMetrics(i).height;
			//				}
			//				
			//				nodeBase.commentTextArea.height = ta_height;
			//				
			//				nodeBase.height +=  ta_height;
			//				nodeBase.invalidateDisplayList();
			//			}
			
		]]>
	</mx:Script>
	
</mx:Canvas>
