<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas xmlns:mx="http://www.adobe.com/2006/mxml" horizontalScrollPolicy="off" verticalScrollPolicy="off"
		   implements="weave.api.core.ILinkableObject"
		   cacheAsBitmap="false"
		   clipContent="false"
		   autoLayout="false"
		   >
	<mx:Glow id="selectedBorder" 
			 alphaFrom="1.0" alphaTo="1.0"   
			 blurXFrom="10.0" blurYFrom="10.0" 
			 blurXTo="10.0" blurYTo="10.0"
			 duration="0" target="{nodeBase}"/>
	<mx:Glow id="unselectedBorder" 
			 alphaFrom="0.0" alphaTo="1.0"   
			 blurXFrom="10.0" blurYFrom="10.0" 
			 blurXTo="10.0" blurYTo="10.0"
			 duration="0" target="{nodeBase}"/>	
	<mx:Script>
		<![CDATA[
			import flash.events.MouseEvent;
			import flash.geom.Point;
			import flash.net.URLRequest;
			import flash.net.navigateToURL;
			import flash.utils.Dictionary;
			
			import mx.collections.ArrayCollection;
			import mx.controls.Alert;
			import mx.controls.Image;
			import mx.controls.Label;
			import mx.controls.Text;
			import mx.controls.TextArea;
			import mx.events.CloseEvent;
			import mx.events.FlexEvent;
			import mx.managers.CursorManager;
			import mx.managers.PopUpManager;
			import mx.managers.PopUpManagerChildList;
			import mx.rpc.events.FaultEvent;
			import mx.rpc.events.ResultEvent;
			
			import weave.Weave;
			import weave.api.WeaveAPI;
			import weave.api.core.ILinkableHashMap;
			import weave.api.core.ILinkableObject;
			import weave.api.data.IQualifiedKey;
			import weave.api.disposeObjects;
			import weave.api.getCallbackCollection;
			import weave.api.linkBindableProperty;
			import weave.api.linkSessionState;
			import weave.api.newLinkableChild;
			import weave.api.registerLinkableChild;
			import weave.core.LinkableDynamicObject;
			import weave.core.LinkableHashMap;
			import weave.core.LinkableNumber;
			import weave.core.LinkableString;
			import weave.core.StageUtils;
			import weave.core.UIUtils;
			import weave.data.CSVParser;
			import weave.data.KeySets.KeyFilter;
			import weave.data.KeySets.KeySet;
			import weave.ui.infomap.core.DateRangeFilter;
			import weave.ui.infomap.core.FilterableInfoMapNode;
			import weave.ui.infomap.core.InfoMapDocument;
			import weave.ui.infomap.core.InfoMapNode;
			import weave.ui.infomap.core.SelectableInfoMapDocument;
			import weave.ui.infomap.ui.DateFilterComponent;
			import weave.ui.infomap.ui.DocThumbnailComponent;
			import weave.ui.infomap.ui.DocumentSummaryComponent;
			import weave.ui.infomap.ui.InfoMapPanel;
			import weave.ui.infomap.ui.NodeBaseComponent;
			import weave.ui.infomap.ui.NodeSettingsComponent;
			import weave.ui.infomap.utils.DateUtils;
			import weave.utils.BitmapUtils;
			import weave.utils.CustomCursorManager;
			
			public const node:FilterableInfoMapNode = newLinkableChild(this,FilterableInfoMapNode);
			
			public const xPos:LinkableNumber = newLinkableChild(this,LinkableNumber);
			public const yPos:LinkableNumber = newLinkableChild(this,LinkableNumber);
			
			public const layout:LinkableDynamicObject = newLinkableChild(this,LinkableDynamicObject,handleLayoutChange);
			
			public const thumbnails:LinkableHashMap = newLinkableChild(this,LinkableHashMap);
			
			public const defaultBorderColor:LinkableNumber = registerLinkableChild(this,new LinkableNumber(13421772),highlightNode,true);
			
			public const selectedBorderColor:LinkableNumber = registerLinkableChild(this,new LinkableNumber(39168),highlightNode,true);
			
			public const defaultThumbnailBorderColor:LinkableNumber = registerLinkableChild(this,new LinkableNumber(000000),highlightNode,true);
			
			public const selectedThumbnailBorderColor:LinkableNumber = registerLinkableChild(this,new LinkableNumber(16711680),highlightNode,true);
			
			public const newThumbnailBorderColor:LinkableNumber = registerLinkableChild(this,new LinkableNumber(00255));
			/**
			 * @public 
			 * A search filter to search within documents handled by this node. 
			 * */ 
			public const searchFilter:LinkableString = newLinkableChild(this,LinkableString);
			
			private var loader:URLLoader = null;
			
			//we override the x,y value because we are binding the values to LinkableNumber 
			//which could be NaN when component loads for the first time
			override public function set x(value:Number):void
			{
				if(parent)
					super.x = isNaN(value)?parent.width/2:value;
				else
					super.x=value
			}
			
			override public function set y(value:Number):void
			{
				if(parent)
					super.y = isNaN(value)?parent.height/2:value;
				else
					super.y=value
						
			}
			
			private var _parentPanel:InfoMapPanel;
			private var _subset:KeyFilter = Weave.root.getObject(Weave.DEFAULT_SUBSET_KEYFILTER) as KeyFilter;
			override protected function childrenCreated():void
			{
				
				this.addChild(nodeBase);

				linkBindableProperty(defaultBorderColor,unselectedBorder,"color");
				linkBindableProperty(selectedBorderColor,selectedBorder,"color");
				
				node.keywords.addGroupedCallback(this,createAndSendQuery,true);
				node.operator.addGroupedCallback(this,createAndSendQuery,true);
				node.numberOfDocs.addGroupedCallback(this,createAndSendQuery,true);
				node.dateFilter.startDate.addGroupedCallback(this,createAndSendQuery,true);
				node.dateFilter.endDate.addGroupedCallback(this,createAndSendQuery,true);
				node.sources.addGroupedCallback(this,createAndSendQuery,true);
				//if node is selected we highlight the nodeBase
				node.selected.addGroupedCallback(this,highlightNode);
				
				//for now defaulting to Radial Layout
				
				if(layout.internalObject == null)
					layout.requestLocalObject(RadialLayout,false);
				
				(layout.internalObject as IInfoMapNodeLayout).parentNodeHandler = this;
				
				
				nodeBase.settingsImg.addEventListener(MouseEvent.CLICK,settings);
				nodeBase.closeImg.addEventListener(MouseEvent.CLICK,close);
				
				//drag and drop of the node will be use the text area as the handler/anchor point
				nodeBase.keywordTextArea.addEventListener(MouseEvent.MOUSE_DOWN,canvas1_mouseDownHandler);
				nodeBase.keywordTextArea.addEventListener(MouseEvent.MOUSE_UP,canvas1_mouseUpHandler);
				
				
				(layout.internalObject as IInfoMapNodeLayout).drawBaseLayout(graphics);
				
				//sessioning the x and y positions of this node
				linkBindableProperty(xPos,this,"x");
				linkBindableProperty(yPos,this,"y");
				
				
				UIUtils.linkDisplayObjects(this,thumbnails,true);
				
				//sets a pointer to the node's parent which is an InfoMapPanel
				var hashmap:LinkableHashMap = WeaveAPI.SessionManager.getLinkableOwner(this) as LinkableHashMap;
				_parentPanel = WeaveAPI.SessionManager.getLinkableOwner(hashmap) as InfoMapPanel;
				
				_parentPanel.globalSearchKeyword.addImmediateCallback(this,handleGlobalSearch);
				
				_parentPanel.globalDateFilter.startDate.addGroupedCallback(this,handleGlobalDateChange);
				_parentPanel.globalDateFilter.endDate.addGroupedCallback(this,handleGlobalDateChange);
				
				
				nodeBase.keywordTextArea.addEventListener(MouseEvent.CLICK,handleClick);
				
				getCallbackCollection(_subset).addGroupedCallback(this,handleSubsetChange);
			}
			
			private var highlightNewDocuments:Boolean = false;
			public function checkForNewDocuments():void
			{
				highlightNewDocuments = true;
				createAndSendQuery(false);
			}
		
				
			[Bindable]
			public var nodeBase:NodeBaseComponent = new NodeBaseComponent();
			
			
			
			/**
			 * @private
			 * This functions creates a query based on the keywords,operator and filters applied and sends a request to the Solr server
			 **/
			private function createAndSendQuery(clearDocuments:Boolean=true):void
			{
				
				if(clearDocuments)
					thumbnails.removeAllObjects();
				
				nodeBase.keywordTextArea.text = node.keywords.value;
				nodeBase.keywordTextArea.toolTip = node.keywords.value;
				
				if (this.parent == null)
				{
					StageUtils.callLater(this,createAndSendQuery);
					return;
				}
				
				this.invalidateDisplayList();
				
				var solrURL:String = "http://129.63.8.219:8080/solr/select/?version=2.2&start=0&rows="+node.numberOfDocs.value.toString()+"&indent=on&q=";	
				var query:String = "";
				query = (node.keywords.value as String);				
				
				//if query is emtpy do nothing
				if(query=="")
					return;
				
				
				var temp:Array = removeEmptyStringElementsFromArray(query.split(" "));	
				
				//after removing the empty strings we check to see if it is a single or empty word.
				//if it is not a single word we add the operator between each keyword
				//spliting the keywords at the spaces. 
				if(temp.length != 0 || temp.length != 1)
					query = temp.join(" "+node.operator.value+" ");
				
				//applying source filters
				if(!node.sources.value == '')
				{
					var sourceNames:Array = node.sources.value.split(',');
					
					query += "&fq="
					
					for each(var sourceName:String in sourceNames)
					{
						query += 'source:"'+sourceName+'" OR ';
					}
					
					//removing last OR 
					query = query.substr(0,query.length-4);
				}
				
				//applying date filters if set
				if(node.dateFilter.endDate.value && node.dateFilter.startDate.value )
				{
					if(node.dateFilter.startDate.value != '' && node.dateFilter.endDate.value != '')
					{
						
						var sDate:Date = DateUtils.getDateFromString(node.dateFilter.startDate.value);
						var eDate:Date = DateUtils.getDateFromString(node.dateFilter.endDate.value);
						
						
						//Solr requires the date format to be ISO 8601 Standard Compliant
						//It should be in the form: 1995-12-31T23:59:59Z 
						var sStr:String = DateUtils.getDateInStringFormat(sDate,'YYYY-MM-DD');
						
						//For start date we append 00:00:00 to set time to start of the day
						sStr = sStr + 'T00:00:00Z';
						
						var eStr:String = DateUtils.getDateInStringFormat(eDate,'YYYY-MM-DD');
						
						//For end date we append 23:59:59 to set time to end of day
						eStr = eStr + 'T23:59:59Z';
						
						query += "&fq=date_published:["+sStr+" TO "+eStr + "]";
					}
				}
				
				//creating and sending the query to the Solr server
				var url:String = solrURL + query;
				loader = new URLLoader();
				var request:URLRequest = new URLRequest(url);
				loader.addEventListener(Event.COMPLETE, xmlLoadCompleteHandler);
				loader.addEventListener(IOErrorEvent.IO_ERROR,handleRequestError);
				loader.load(request);
			}
			
			
			private function handleRequestError(event:Event):void
			{
				Alert.show("There was an error in your request. Please make sure your keywords are separated by commas.","Error");
			}
				
			
			private function xmlLoadCompleteHandler(event:Event):void {
				// checks to avoid null point error
				if(loader){
					// checks for data presence
					if(loader.data){
						var xml:XML = new XML(loader.data);
						parseSolrResponse(xml);
					}
				}
				
			}
			
			
			private function parseSolrResponse(result:XML):void
			{
				
				var response:ArrayCollection = new ArrayCollection();
				var docsArray:Array = [];
				var docObject:SelectableInfoMapDocument;
				for each(var doc:XML in result.result.doc)
				{
					
					var link:String = doc.str.(@name=="link").text().toXMLString();
					var linkLen:int = link.length;
					var linkExtension:String = link.substring(linkLen-3,linkLen);
					var imgExtension:String = ".jpg"
						
//					currently disabled pdf files for cleaner results and testing purposes 
					if(linkExtension == "pdf"){
						link = "http://129.63.8.219:8080/"+link.substring(link.indexOf("infomap"),linkLen);
						imgExtension = ".png";
					}
					else if(link.substring(linkLen-3,linkLen-1) == "doc"){
						link = "http://129.63.8.219:8080/"+link.substring(link.indexOf("infomap"),linkLen);
						imgExtension = ".png";
					}

						//each document retrived is added to the docs map in the parent infomap panel
						docObject = _parentPanel.docs.requestObject(link,SelectableInfoMapDocument,false);					
						var currentDoc:Array = []
						
						docObject.title.value = doc.str.(@name=="title").text().toXMLString();
						currentDoc.push(doc.str.(@name=="title").text().toXMLString());
						
						docObject.url.value = link;
						currentDoc.push(link);
						
						//TODO:right now limiting to 500 characters. Need to change this later to a better solution
						docObject.summary.value = (doc.str.(@name=="description").text().toXMLString() as String).substr(0,500);
						currentDoc.push((doc.str.(@name=="description").text().toXMLString() as String).substr(0,500));
						
						var imgURL:String = doc.str.(@name=="imgName").text().toXMLString();
						
						docObject.imageURL.value = "http://129.63.8.219:8080/infomap/thumbnails/"+  imgURL + imgExtension;					
						currentDoc.push("http://129.63.8.219:8080/infomap/thumbnails/"+  imgURL + imgExtension);
						
						docObject.date.value = doc.date.text().toXMLString();
						currentDoc.push(doc.date.text().toXMLString());
						
						docsArray.push(currentDoc);
						response.addItem(link);
				}
				
				var csvDataString:String = parser.createCSVFromArrays(docsArray);
				csvDataString = _parentPanel.docsInCSV.csvDataString.value + '\n' + csvDataString;
				
				_parentPanel.docsInCSV.csvDataString.value = csvDataString;
				
				handleParsedResult(response);
			}
			

			private	var docPreview:DocumentSummaryComponent = null;
			
			private var thumbnailSize:int = 50;
			
			private var parser:CSVParser = new CSVParser();
			
			
			/**
			 * @private
			 * This function takes an array collection of links and requests a thumbnail object to display the document object
			 * for each of the corresponding links.
			 * If the thumbnail object is already there then we use the replace its doc object with the latest doc object. 
			 **/
			private function handleParsedResult(response:ArrayCollection):void
			{
				var obj:SelectableInfoMapDocument;
				for(var i:int; i<response.length ;i++)
				{
					var link:String = response[i] as String;					
					obj = _parentPanel.docs.requestObject(link,SelectableInfoMapDocument,false);
					var thumbnail:DocThumbnailComponent = new DocThumbnailComponent();
					
					//if the thumbnail already exists use previous x,y values
					if(thumbnails.getObject(link))
					{
						thumbnail = thumbnails.requestObject(link,DocThumbnailComponent,false);
						
						//we replace the doc object because, the summary, description might have changed. 
						thumbnail.doc = obj as SelectableInfoMapDocument;
						continue;
					}
					thumbnail = thumbnails.requestObject(link,DocThumbnailComponent,false);
					
					thumbnail.doc = obj as SelectableInfoMapDocument;
					
					if(highlightNewDocuments)
					{
						thumbnail.defaultBorderColor.value = newThumbnailBorderColor.value;
					}
					
				}
				
				handleSubsetChange();
				
				//we now have all the required thumbnails, so we use the layout to plot them
				(layout.internalObject as IInfoMapNodeLayout).plotThumbnails(thumbnailsToPlotArray);
				
				
			}
			
			private var thumbNailsToPlot:Dictionary = new Dictionary();
			private var thumbnailsToPlotArray:Array = [];
			private function handleSubsetChange():void
			{
//				var currentThumbnails:Array = thumbnails.getNames();
//				for each (var link:String in currentThumbnails)
//				{
//					if(!_subset.containsKey(WeaveAPI.QKeyManager.getQKey("infomapDocURL",link)))
//						thumbnails.removeObject(link);
//				}
				
				var includedKeys:Array = _subset.included.keys;
				var excludedKeys:Array = _subset.excluded.keys;
				
				var dictKey:*;
				
				//add all thumbanils to dictionary and set it all to false
				for each(var t:DocThumbnailComponent in thumbnails.getObjects())
				{
					thumbNailsToPlot[t] = false;
					t.visible = false;
				}
				
				//add only included keys from subset
				if(includedKeys.length>0)
				{
					for each (var iKey:IQualifiedKey in includedKeys)
					{
						var includedThumbnail:DocThumbnailComponent = thumbnails.getObject(iKey.localName) as DocThumbnailComponent;
						
						if(includedThumbnail)
						{
							thumbNailsToPlot[includedThumbnail] = true;
							includedThumbnail.visible = true;						
						}
					}
				}else //else set all thumbnails to be added
				{
					for (dictKey in thumbNailsToPlot)
					{
						thumbNailsToPlot[dictKey] = true;
						(dictKey as DocThumbnailComponent).visible = true;
					}
				}
				
				//remove excluded keys if any
				if(excludedKeys.length >0)
				{
					for each(var xKey:IQualifiedKey in excludedKeys)
					{
						var excludedThumbnail:DocThumbnailComponent = thumbnails.getObject(xKey.localName) as DocThumbnailComponent;
						
						if(excludedThumbnail)
						{
							thumbNailsToPlot[excludedThumbnail] = false;
							excludedThumbnail.visible = false;
						}
						
					}
				}
				
				thumbnailsToPlotArray = [];
				//add all thumbnails to be plotted to an array
				for (dictKey in thumbNailsToPlot)
				{
					if(thumbNailsToPlot[dictKey])
						thumbnailsToPlotArray.push(dictKey);
				}
				
				
				(layout.internalObject as IInfoMapNodeLayout).plotThumbnails(thumbnailsToPlotArray);
			}
			
			
			
			
			private function handleLayoutChange():void
			{
				if(layout.internalObject == null)
					return;
				(layout.internalObject as IInfoMapNodeLayout).parentNodeHandler = this;
				(layout.internalObject as IInfoMapNodeLayout).drawBaseLayout(graphics);
				(layout.internalObject as IInfoMapNodeLayout).plotThumbnails(thumbnailsToPlotArray);
			}
			
//			private function handleMouseOver():void
//			{
//				nodeControl.closeImg.visible = true;
//				nodeControl.editImg.visible = true;
//				nodeControl.searchImg.visible = true;
//				nodeControl.filterImg.visible = true;
//			}
//			
//			
//			private function handleMouseOut():void
//			{
//				nodeControl.closeImg.visible = false;
//				nodeControl.editImg.visible = false;
//				nodeControl.searchImg.visible = false;
//				nodeControl.filterImg.visible = false;
//			}
			
			//toggle node selection on click
			private function handleClick(event:Event):void
			{
				if(wasDragged)
				{
					wasDragged = false;
					return;
				}
				if(node.selected.value)
					node.selected.value = false;
				else
					node.selected.value = true;
			}
			
			//highlight node based on node.selected.value
			private function highlightNode():void
			{
				if(node.selected.value)
					selectedBorder.play();
				else
					unselectedBorder.play();
			}
			
			//this variable will be  used to avoid selection/unselection when the node is dragged
			private var wasDragged:Boolean = false;
			protected function canvas1_mouseDownHandler(event:MouseEvent):void
			{
				
				applyKeywords();
				nodeBase.keywordTextArea.setStyle("fontWeight","bold");
				CustomCursorManager.showCursor(CustomCursorManager.HAND_GRAB_CURSOR);
				this.startDrag();
				this.addEventListener(MouseEvent.MOUSE_MOVE,handleMouseMove);
			}
			
			private function handleMouseMove(event:Event):void
			{
				wasDragged = true;
			}
			
			protected function canvas1_mouseUpHandler(event:MouseEvent):void
			{
				nodeBase.keywordTextArea.setStyle("fontWeight","normal");
				CustomCursorManager.removeCurrentCursor();
				this.stopDrag();
				this.removeEventListener(MouseEvent.MOUSE_MOVE,handleMouseMove);
			}
			
			
			
			private function handleKeywordChange(event:KeyboardEvent):void
			{
				if(event.keyCode == Keyboard.ENTER)
				{
					event.preventDefault();
					applyKeywords();
				}
			}
			
			
			private function applyKeywords():void
			{
				// we take the focus back from the keyword text area and assign it back to the node handler
				stage.focus = this;
				nodeBase.keywordTextArea.editable = false;
				nodeBase.keywordTextArea.selectable = false;
				node.keywords.value = nodeBase.keywordTextArea.text;
				toggleEdit = false;
			}
			
			
			
			
			private function filter(event:Event):void
			{
				DateFilterComponent.openInstance(this,node.dateFilter);
			}

			private var _instance:NodeSettingsComponent = null;
			private function settings(event:Event):void
			{
				
				if(_instance)
				{
					PopUpManager.addPopUp(_instance,this);
				}
				else
				{
					_instance = new NodeSettingsComponent();
					_instance.nodeHandler = this;
					PopUpManager.addPopUp(_instance,this);
				}
			}
			
			private function close(event:Event):void
			{
				Alert.show("Are you sure you want to remove this node?",
							 "Remove Node?",
							 Alert.YES | Alert.NO,
							 null,
							 handleCloseEvent
							 );
			}
			
			private function handleCloseEvent(e:CloseEvent):void
			{
					if(e.detail == Alert.YES)
					{
						thumbnails.removeAllObjects();
						var parent:ILinkableHashMap = (WeaveAPI.SessionManager.getLinkableOwner(this) as ILinkableHashMap);
						var nodeName:String  = parent.getName(this);
						parent.removeObject(nodeName);
					}
					else if(e.detail == Alert.NO)
					{
						return;
					}
			}			
			private var toggleEdit:Boolean = false;
			private function edit(event:Event):void
			{
				if(toggleEdit)
				{
					toggleEdit = false;
					stage.focus = this;
					nodeBase.keywordTextArea.editable = false;
					nodeBase.keywordTextArea.selectable = false;
					return;
				}
				
				toggleEdit = true;
				nodeBase.keywordTextArea.editable = true;
				nodeBase.keywordTextArea.selectable = true;
				nodeBase.keywordTextArea.addEventListener(KeyboardEvent.KEY_DOWN,handleKeywordChange,true);
				nodeBase.keywordTextArea.setSelection(nodeBase.keywordTextArea.text.length,nodeBase.keywordTextArea.text.length);
				nodeBase.keywordTextArea.setFocus();
			}
			
			
			private function remove(event:Event):void //doesn't work if you decalre this as Mouse Event. 
			{
				thumbnails.removeAllObjects();
				var parent:ILinkableHashMap = (WeaveAPI.SessionManager.getLinkableOwner(this) as ILinkableHashMap);
				var nodeName:String  = parent.getName(this);
				parent.removeObject(nodeName);
			}
			
			private var searchText:TextArea = new TextArea();
			
			//this flag is used to toggle the search text area. 
			private var toggleSearch:Boolean = false;
			private function search(event:Event):void
			{
				if(toggleSearch)
				{
					this.removeChild(searchText);
					toggleSearch = false;
					return;
				}
				toggleSearch = true;
				searchText.x = (event.currentTarget as Image).x + 20;
				searchText.y = (event.currentTarget as Image).y - 10;
				searchText.width = 100;
				searchText.height = 20;
				searchText.addEventListener(KeyboardEvent.KEY_UP,handleSearch);
				searchText.text = searchFilter.value;
				searchText.toolTip = 'Hit Enter or Esc to close this text box';
				this.addChild(searchText);
				searchText.setFocus();
			}
			
			
			private function handleSearch(event:KeyboardEvent):void
			{
					if(event.keyCode == Keyboard.ENTER  || event.keyCode == Keyboard.ESCAPE)
					{
						this.removeChild(searchText);
						toggleSearch = false;
						return;
					}
					searchFilter.value = searchText.text;
			}
			
			private function handleGlobalSearch():void
			{
				if(node.selected.value)
					searchFilter.value = _parentPanel.globalSearchKeyword.value;
			}
			
			private function handleGlobalDateChange():void
			{
				if(node.selected.value)
				{
					node.dateFilter.startDate.value = _parentPanel.globalDateFilter.startDate.value;
					node.dateFilter.endDate.value = _parentPanel.globalDateFilter.endDate.value;
				}
			}
			private function removeEmptyStringElementsFromArray(arg:Array):Array
			{
				var result:Array = [];
				for each(var item:String in arg)
				{
					if(item != "")
						result.push(item);
				}
				
				return result;
			}
			
		]]>
	</mx:Script>
	
</mx:Canvas>
