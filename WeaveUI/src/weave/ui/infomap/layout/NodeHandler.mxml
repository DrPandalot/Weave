<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas xmlns:mx="http://www.adobe.com/2006/mxml"
		   xmlns:ui="weave.ui.infomap.ui.*"
		   autoLayout="false" cacheAsBitmap="false" clipContent="false" creationPolicy="all"
		   horizontalScrollPolicy="off" implements="weave.api.core.ILinkableObject"
		   verticalScrollPolicy="off">
	<!--Show this status box only when list is visible-->
	<mx:Label id="status" x="{nodeBase.keywordTextArea.width}" y="{nodeBase.keywordTextArea.height}"
			  width="300"/>
	<!--<mx:HBox horizontalAlign="left" id="statusBox" y="{nodeBase.height}" width="400" includeInLayout="false">
		<mx:Label id="filterStatus"/>
		<mx:Button focusAlpha="0" id="clearFiltersButton" label="Clear" visible="false" click="handleClearFiltersButton()"/>
	</mx:HBox>-->
	<!--<mx:Canvas id="listCanvas" alpha="0" visible="false" clipContent="false" width="400" height="500" includeInLayout="false"/>-->
	<!--<ui:ThumbnailsLayout id="gridView" alpha="0" clipContent="false" includeInLayout="false"/>-->
	<mx:Glow id="selectedBorder" alphaFrom="1.0" alphaTo="1.0" blurXFrom="10.0" blurXTo="10.0"
			 blurYFrom="10.0" blurYTo="10.0" duration="0" target="{nodeBase}"/>
	<mx:Glow id="unselectedBorder" alphaFrom="0.0" alphaTo="1.0" blurXFrom="10.0" blurXTo="10.0"
			 blurYFrom="10.0" blurYTo="10.0" duration="0" target="{nodeBase}"/>
	<mx:Fade id="fadeIn" alphaFrom="0.0" alphaTo="1.0" duration="750"
			 effectEnd="handleEffectsEnd(event)" effectStart="handleEffectsStart(event)"/>
	<mx:Fade id="fadeOut" alphaFrom="1.0" alphaTo="0.0" duration="750"
			 effectEnd="handleEffectsEnd(event)" effectStart="handleEffectsStart(event)"/>
	<mx:Sequence id="newDocumentHighlight" target="{nodeBase.keywordTextArea}">
		<mx:Fade id="newDocumentFadeOut" alphaFrom="1.0" alphaTo="0.0" duration="1000"/>
		<mx:Fade id="newDocumentFadeIn" alphaFrom="0.0" alphaTo="1.0" duration="1000"/>
	</mx:Sequence>
	<mx:Script>
		<![CDATA[
			import flash.events.MouseEvent;
			import flash.geom.Point;
			import flash.net.URLRequest;
			import flash.net.navigateToURL;
			import flash.utils.Dictionary;
			import flash.utils.getDefinitionByName;
			
			import mx.collections.ArrayCollection;
			import mx.containers.TabNavigator;
			import mx.controls.Alert;
			import mx.controls.Image;
			import mx.controls.Label;
			import mx.controls.List;
			import mx.controls.Text;
			import mx.controls.TextArea;
			import mx.core.Application;
			import mx.core.IUIComponent;
			import mx.core.UIComponent;
			import mx.core.UITextField;
			import mx.core.mx_internal;
			import mx.effects.Effect;
			import mx.events.CloseEvent;
			import mx.events.DragEvent;
			import mx.events.EffectEvent;
			import mx.events.FlexEvent;
			import mx.events.ListEvent;
			import mx.events.SandboxMouseEvent;
			import mx.managers.CursorManager;
			import mx.managers.CursorManagerPriority;
			import mx.managers.DragManager;
			import mx.managers.PopUpManager;
			import mx.managers.PopUpManagerChildList;
			import mx.rpc.AsyncToken;
			import mx.rpc.Fault;
			import mx.rpc.events.FaultEvent;
			import mx.rpc.events.ResultEvent;
			
			import org.igniterealtime.xiff.data.ping.PingExtension;
			
			import spark.accessibility.ToggleButtonAccImpl;
			
			import weave.Weave;
			import weave.api.WeaveAPI;
			import weave.api.copySessionState;
			import weave.api.core.ILinkableHashMap;
			import weave.api.core.ILinkableObject;
			import weave.api.data.IAttributeColumn;
			import weave.api.data.IQualifiedKey;
			import weave.api.detectLinkableObjectChange;
			import weave.api.disposeObjects;
			import weave.api.getCallbackCollection;
			import weave.api.getLinkableOwner;
			import weave.api.getSessionState;
			import weave.api.linkBindableProperty;
			import weave.api.linkSessionState;
			import weave.api.newLinkableChild;
			import weave.api.registerLinkableChild;
			import weave.api.reportError;
			import weave.compiler.Compiler;
			import weave.compiler.StandardLib;
			import weave.core.LinkableBoolean;
			import weave.core.LinkableDynamicObject;
			import weave.core.LinkableHashMap;
			import weave.core.LinkableNumber;
			import weave.core.LinkableString;
			import weave.core.SessionManager;
			import weave.core.SessionStateLog;
			import weave.core.StageUtils;
			import weave.core.UIUtils;
			import weave.data.AttributeColumns.KeyColumn;
			import weave.data.AttributeColumns.ReferencedColumn;
			import weave.data.CSVParser;
			import weave.data.ColumnReferences.HierarchyColumnReference;
			import weave.data.DataSources.CSVDataSource;
			import weave.data.DataSources.InfoMapsDataSource;
			import weave.data.KeySets.KeyFilter;
			import weave.data.KeySets.KeySet;
			import weave.data.QKeyManager;
			import weave.primitives.ColorRamp;
			import weave.primitives.DateRangeFilter;
			import weave.services.DelayedAsyncInvocation;
			import weave.services.DelayedAsyncResponder;
			import weave.services.InfoMapAdminInterface;
			import weave.services.addAsyncResponder;
			import weave.services.beans.SolrClusterObject;
			import weave.services.beans.TopicClassificationResults;
			import weave.ui.ControlPanel;
			import weave.ui.CustomLabel;
			import weave.ui.DraggablePanel;
			import weave.ui.ResizableBox;
			import weave.ui.SubMenu;
			import weave.ui.infomap.core.FilterableInfoMapNode;
			import weave.ui.infomap.core.InfoMapDocument;
			import weave.ui.infomap.core.InfoMapNode;
			import weave.ui.infomap.core.MovedThumbnailPosition;
			import weave.ui.infomap.core.QueryObject;
			import weave.ui.infomap.ui.AbstractListView;
			import weave.ui.infomap.ui.BasicSettingsComponent;
			import weave.ui.infomap.ui.DateFilterComponent;
			import weave.ui.infomap.ui.DocThumbnailComponent;
			import weave.ui.infomap.ui.DocumentListView;
			import weave.ui.infomap.ui.InfoMapPanel;
			import weave.ui.infomap.ui.NodeBaseComponent;
			import weave.ui.infomap.ui.NodeSettingsComponent;
			import weave.ui.infomap.ui.PointsLayout;
			import weave.ui.infomap.ui.RadialMenu;
			import weave.ui.infomap.ui.RelatedKeywordsListItemObject;
			import weave.ui.infomap.ui.TagCloud;
			import weave.ui.infomap.ui.TagCloudSettingComponent;
			import weave.ui.infomap.ui.ThumbnailsLayout;
			import weave.ui.infomap.ui.ThumbnailsListView;
			import weave.ui.infomap.ui.TopicNodeComponent;
			import weave.ui.infomap.ui.TopicNodeSettingComponent;
			import weave.utils.BitmapUtils;
			import weave.utils.ColumnUtils;
			import weave.utils.ComputationalGeometryUtils;
			import weave.utils.CustomCursorManager;
			import weave.utils.DateUtils;
			import weave.utils.DebugTimer;
			import weave.utils.EventUtils;
			import weave.utils.VectorUtils;
			import weave.visualization.layers.InteractiveVisualization;
			import weave.visualization.tools.CompoundBarChartTool;
			import weave.visualization.tools.RadVizTool;
			
			private const currentQuery:QueryObject = newLinkableChild(this,QueryObject);
			
			public const previousQuery:QueryObject = newLinkableChild(this,QueryObject);
			
			public const xPos:LinkableNumber = newLinkableChild(this,LinkableNumber);
			public const yPos:LinkableNumber = newLinkableChild(this,LinkableNumber);
			
//			public const layout:LinkableDynamicObject = newLinkableChild(this,LinkableDynamicObject,handleLayoutChange,true);
			
			public const thumbnails:LinkableHashMap = newLinkableChild(this,LinkableHashMap);
			
			public const thumbnailsDefaultColor:LinkableNumber = registerLinkableChild(this,new LinkableNumber(0));
			
			public const movedThumbNails:LinkableHashMap = newLinkableChild(this,LinkableHashMap);
			
			public const comments:LinkableString = newLinkableChild(this,LinkableString);
			
			public const numOfWordsInCloud:LinkableNumber = registerLinkableChild(this,new LinkableNumber(75,function(value:*):Boolean{
																if(value > 100)
																	return false;
																else 
																	return true;},false));
			
			public const numOfMatchedDocuments:LinkableNumber = registerLinkableChild(this, new LinkableNumber(0));
			
			public const showNewDocumentsOnTop:LinkableBoolean = registerLinkableChild(this,new LinkableBoolean(false,null,false));
			
			/* We separate dateFilter from previousQuery because when dateFilter is changed from NodeSettingsComponent the behavior of the callbacks
			is unpredictable. It is easier to handle the callbacks for keywords and date separately.*/
//			public const dateFilter:DateRangeFilter = registerLinkableChild(this, new DateRangeFilter(),handleDateFilterChange, true); // ToDo

			public const numOfTopics:LinkableNumber = registerLinkableChild(this, new LinkableNumber(5,function(value:*):Boolean{
				if(value > 10 || value <2)
					return false;
				else 
					return true;},false), handleTopicsPropertiesChange, true);
			
			public const numOfKeywordsInEachTopic:LinkableNumber = registerLinkableChild(this, new LinkableNumber(5,function(value:*):Boolean{
				if(value > 10 || value < 1)
					return false;
				else 
					return true;},false), handleTopicsPropertiesChange, true);
			
			public const spaceBetwwenTopicRect:LinkableNumber = registerLinkableChild(this, new LinkableNumber(3, function(value:*):Boolean{
				if(value > 10 || value < 1)
					return false;
				else 
					return true;},false), handleTopicLayoutSettingChange, true); // ToDo
			
			public const enablePinView:LinkableBoolean = registerLinkableChild(this,new LinkableBoolean(true));
			
			public static const LIST_VIEW:String = "List";
			public static const THUMBNAILS_VIEW:String = "Thumbnails";
			public static const TOPICS_VIEW:String = "Topics";
			public static const WORD_CLOUD_VIEW:String = "Word Cloud";
			public static const POINTS_VIEW:String = "Points";
			public static const views:Array = [LIST_VIEW,THUMBNAILS_VIEW,TOPICS_VIEW,WORD_CLOUD_VIEW,POINTS_VIEW];
			public const currentView:LinkableString =  registerLinkableChild(this,new LinkableString(LIST_VIEW,function(value:*):Boolean{
				if(views.indexOf(value) != -1)
					return true;
				else
					return false;
			},false));
			
			private function handleTopicLayoutSettingChange():void
			{
				flag_init = true;
				showClassificationResults();
			}
			
			private const listWidth:LinkableNumber = new LinkableNumber();
			
			private var loader:URLLoader = null;
			
			//we override the x,y value because we are binding the values to LinkableNumber 
			//which could be NaN when component loads for the first time
			override public function set x(value:Number):void
			{
				if(parent)
					super.x = isNaN(value)?parent.width/2:value;
				else
					super.x=value
			}
			
			override public function set y(value:Number):void
			{
				if(parent)
					super.y = isNaN(value)?parent.height/2:value;
				else
					super.y=value
				
			}
			
			private var _parentPanel:InfoMapPanel;
			public function get parentPanel():InfoMapPanel
			{
				return _parentPanel;
			}
			
			private var _subset:KeyFilter = Weave.root.getObject(Weave.DEFAULT_SUBSET_KEYFILTER) as KeyFilter;
			
			//We create a private key filter for tag word click
//			private var _tagWordSubset:KeyFilter = new KeyFilter();
			
			
			override protected function createChildren():void
			{
				
				super.createChildren();
				this.addChild(nodeBase);
			}
			
			/* We will use this variable to send a query to data sources on first load of the node */
			private var _firstLoad:Boolean = true;
			
			[Embed( source="/weave/resources/images/cancel.png")]
			private var CloseImgClass:Class;
			private var _closeImgText:String ="Remove node";
			
			[Embed( source="/weave/resources/images/tinyWrench.png")]
			private var SettingsImgClass:Class;
			private var _settingsImgText:String = "Settings Panel" ;
			
			[Embed( source="/weave/resources/images/list.png")]
			private var ListImgClass:Class;
			private var _listImgText:String = "List View";
			
			[Embed( source="/weave/resources/images/cloud.png")]
			private var WordCloudImgClass:Class;
			private var _wordCloudText:String = "Word Cloud";
			
			[Embed( source="/weave/resources/images/bar_chart.png")]
			private var EntityDistributionImgClass:Class;
			private var _entityDistributionImgText:String = "Entity Distribution";
			
			[Embed( source="/weave/resources/images/cluster.png")]
			private var ClusterImgClass:Class;
			private var _clusterImgText:String = "Clusters by LINGO";
			
			
			[Embed( source="/weave/resources/images/topics.png")]
			private var TopicsImgClass:Class;
			private var _topicsImgText:String = "Topics View";
			
			[Embed( source="/weave/resources/images/grid.png")]
			private var GridImgClass:Class;
			private var _gridImgText:String = "Grid View";
			
			[Embed( source="/weave/resources/images/sphere.png")]
			private var PointsImgClass:Class;
			private var _pointsImgText:String = "Points View";
			
			[Embed( source="/weave/resources/images/arrowDown.png")]
			private var _subMenuIcon:Class;
			private var _menuButton:Image = new Image();
			private var _subMenu:SubMenu;
			override protected function childrenCreated():void
			{
				super.childrenCreated();
				
//				getCallbackCollection(currentQuery).addGroupedCallback(this,createAndSendQuery,false);//currentQuery should always be triggered by change in previousQuery
				getCallbackCollection(previousQuery).addGroupedCallback(this,handleChangeToPrevQuery,true);
				
				//if node is selected we highlight the nodeBase
				//				node.selected.addGroupedCallback(this,highlightNode);
				
				//for now defaulting to Random Layout
//				if(layout.internalObject == null)
//					layout.requestLocalObject(RandomLayout,false);
//				(layout.internalObject as IInfoMapNodeLayout).parentNodeHandler = this;
				
				//opens the settings panel
				_menuButton.source = _subMenuIcon;
				nodeBase.addChildAt(_menuButton,0);
				_menuButton.x = 0 - _menuButton.height;
				_subMenu = new SubMenu(_menuButton,[MouseEvent.CLICK, MouseEvent.DOUBLE_CLICK]);
				
//				_radialMenu =  new RadialMenu(nodeBase as UIComponent,MouseEvent.ROLL_OVER, MouseEvent.ROLL_OUT,RadialMenu.LINE_STYLE);
//				nodeBase.addChildAt(_radialMenu,0);
//				_radialMenu.x = (0-_radialMenu.height);
				
//				var closeImg:Bitmap = new CloseImgClass() as Bitmap;
//				_radialMenu.addMenuItem(closeImg,_closeImgText,close);
				
//				nodeBase.tickImg.addEventListener(MouseEvent.CLICK,clearAllNewDocuments);
				
				//removes the node from the panel after confirmation
//				var settingsImg:Bitmap = new SettingsImgClass() as Bitmap;
//				_radialMenu.addMenuItem(settingsImg,_settingsImgText,settings);
				
				//drag and drop of the node will be use the text area as the handler/anchor point
				nodeBase.keywordTextArea.addEventListener(MouseEvent.MOUSE_DOWN,canvas1_mouseDownHandler);
				stage.addEventListener(MouseEvent.MOUSE_UP,canvas1_mouseUpHandler);
				nodeBase.keywordTextArea.addEventListener(KeyboardEvent.KEY_DOWN,keywordTextAreaKeyDownHandler);
				nodeBase.addEventListener(DragEvent.DRAG_ENTER,handleDragEnter);
				
				nodeBase.addEventListener(MouseEvent.ROLL_OVER,handleViewOnRollOver);
				nodeBase.addEventListener(MouseEvent.ROLL_OUT,handleViewOnRollOut);
				
				
				//drawing the base which is the node with keywords and icons
//				(layout.internalObject as IInfoMapNodeLayout).drawBaseLayout(graphics);
				
				//sessioning the x and y positions of this node
				linkBindableProperty(xPos,this,"x");
				linkBindableProperty(yPos,this,"y");
				
				thumbnailsDefaultColor.addImmediateCallback(this,handleBorderColor,true);
				
				//sets a pointer to the node's parent which is an InfoMapPanel
				if(!_parentPanel)
				{
					var hashmap:LinkableHashMap = WeaveAPI.SessionManager.getLinkableOwner(this) as LinkableHashMap;
					_parentPanel = WeaveAPI.SessionManager.getLinkableOwner(hashmap) as InfoMapPanel;
				}
				
				//adding a callback to the Global Search keyword. This will set the visibility of the thumbnails to true or false
				//based on keyword match
//				_parentPanel.globalSearchKeyword.addImmediateCallback(this,handleGlobalSearch);
				
				//adding a callback to the Global Date Filter
				//TODO: needs to be tested
				_parentPanel.globalDateFilter.startDate.addGroupedCallback(this,handleGlobalDateChange);
				_parentPanel.globalDateFilter.endDate.addGroupedCallback(this,handleGlobalDateChange);
				
				//adding listener to Click event to toggle node selection
				nodeBase.keywordTextArea.addEventListener(MouseEvent.CLICK,handleClick);
				
//				getCallbackCollection(_tagWordSubset).addGroupedCallback(this,handleTagWordSubsetChange);
				
				//calling function to highlight the node based on node.selected.value
				//				highlightNode();
				
				//we want to trigger the callback for thumbnails at each frame and check the trigger counter
				getCallbackCollection(this).addImmediateCallback(this,invalidateDisplayList);
				
				//the set of keys matching the query is stored in docKeyset. 
				//when the results are stored in this keySet a callback is triggered for parsing the results
				docKeySet.addGroupedCallback(this,handleDocKeySetChange,false);
				
				//this keySet stores the keys matching the search query.
				//when the results are stored in this keySet a callback is triggered for setting the thumbnails' visible to true/false
//				_searchKeySet.addImmediateCallback(this,handleSearchKeySetChange,true);
				
//				clickedWordKeySet.addImmediateCallback(this,handleClickedWordKeySetChange);
				prevNewDocsCount.addGroupedCallback(this,handleChangeToPrevQuery);
				
				numOfWordsInCloud.addGroupedCallback(this,redrawWordCloud,false);
				
//				refreshTimer.start();
				//call event for each tick of refreshTimer
				refreshTimer.addEventListener(TimerEvent.TIMER, createAndSendQuery);
				
				//				comments.addImmediateCallback(this,handleCommentsChange,true);
				
				//				createAndSendQuery();
				
				glowFilter.color = thumbnailsDefaultColor.value;
				
				var owner:ILinkableObject = getLinkableOwner(this);
				
				_nodeName= (owner as ILinkableHashMap).getName(this);
				
				entityDistributionDataSource = Weave.root.requestObject(_nodeName + "entityDistributionDataSource",CSVDataSource,false);
				(WeaveAPI.SessionManager as SessionManager).excludeLinkableChildFromSessionState(entityDistributionDataSource,entityDistributionDataSource.csvData);
				(WeaveAPI.SessionManager as SessionManager).excludeLinkableChildFromSessionState(entityDistributionDataSource,entityDistributionDataSource.keyColName);
				(WeaveAPI.SessionManager as SessionManager).excludeLinkableChildFromSessionState(entityDistributionDataSource,entityDistributionDataSource.keyType);

				clusterCSVDataSource = Weave.root.requestObject(_nodeName + "clusterDataSource",CSVDataSource,false);
				_clusterRadVizName = Weave.root.generateUniqueName(_nodeName + "Clusters");
				
				addChild(topicComponent);
				topicComponent.rectColors.addImmediateCallback(this, handleTopicLayoutSettingChange); // ToDo
				
				parentPanel.entityColumnsHashmap.addGroupedCallback(this,getEntityDistribution);
				
				_selection.addGroupedCallback(this,handleSelectionKeySetChange);
				
				docListComponent.parentNode = this;
				thumbnailListComponent.parentNode = this;
				
				getCallbackCollection(movedThumbNails).addGroupedCallback(this, handleMovedThumbnailsChangesInViews);
				
				showNewDocumentsOnTop.addGroupedCallback(this,handleSortNewDocsChange);
				
				_pointCanvas.visible = false;
				_pointCanvas.alpha = 0;
				_viewToObjectMapping[POINTS_VIEW] = _pointCanvas;
				
				thumbnailListComponent.visible = false;
				thumbnailListComponent.alpha = 0;
				_viewToObjectMapping[THUMBNAILS_VIEW] = thumbnailListComponent;
				
				docListComponent.visible = false;
				docListComponent.alpha = 0;
				addChild(docListComponent);
				docListComponent.docList.addEventListener(ListEvent.ITEM_CLICK,handleDocumentSelectedFromList);
				_viewToObjectMapping[LIST_VIEW] = docListComponent;
				
				topicComponent.visible = false;
				topicComponent.alpha = 0;
				_viewToObjectMapping[TOPICS_VIEW] = topicComponent;
				
				wordCloud.visible = false;
				wordCloud.alpha = 0;
				_viewToObjectMapping[WORD_CLOUD_VIEW] = wordCloud;
				
				_pinImg = new Image();
				_pinImg.width = _pinImg.height = 14; //width & height is not updated. Bug in Image Class. Needs a listener for Update event.
				_pinImg.buttonMode = true;
				nodeBase.addChild(_pinImg);
				_pinImg.x = nodeBase.width; 
				_pinImg.y = 0;
				
				enablePinView.addGroupedCallback(this,handlePinViewChange,true);
				_pinImg.addEventListener(MouseEvent.CLICK,togglePinViews);
				currentView.addGroupedCallback(this,handleCurrentViewChange,true);
			}
			
			private var _viewToObjectMapping:Dictionary = new Dictionary();
			
			private var _nodeName:String = "";
			
			private var delayedCommentKeyUp:Function = null;
			
			private var refreshTimer:Timer = new Timer(60*5*1000);
			
			[Bindable]
			public var nodeBase:NodeBaseComponent = new NodeBaseComponent();
			
			private var docKeySet:KeySet = new KeySet();
			
			//////////////////////////////
			// Query Functions
			//////////////////////////////
			
			/**
			 * @private
			 * Called when the session state of query is changed
			 **/
			private var _currentQueryTerms:Array = [];
			private function createAndSendQuery(event:TimerEvent=null):void
			{
				/* this function is called every time the query parameters changes, so we will reset the timer so that it is not called immediately
				when the query changes. This way we can avoid adding old results for a new query. */
				refreshTimer.reset();
				refreshTimer.start();
				
				_subMenu.addSubMenuItem("Edit Query",editQuery);
				_subMenu.addSubMenuItem("Settings",settings);
				_subMenu.addSubMenuItem("Close",close);
				_subMenu.addSubMenuItem("Add/Remove Pin Views",togglePinViews);
				
				/* if this is an empty query clear all documents */
				if(!currentQuery.keywords.value)
				{	
					_currentQueryTerms = [];
					handleEmptyResultSet();
					return;
				}
				
				if (this.parent == null)
				{
					WeaveAPI.StageUtils.callLater(this,createAndSendQuery);
					return;
				}
				
				status.text = "Searching...";
				
				/* check to see if this a new query or an old query */
				var isQueryDifferent:Boolean = QueryObject.isQueryDifferent(previousQuery,currentQuery);
								
				/* Make query to get number of documents */
				/* We first check to see if they are separated by commas if not then assume space*/
				if(_parentPanel.relatedKeywords.value)
					_currentRelatedKeywords = _parentPanel.relatedKeywords.value.indexOf(",") != -1?
						_parentPanel.relatedKeywords.value.split(','):_parentPanel.relatedKeywords.value.split(' ');

//				if(isQueryDifferent)
//				{
//					/* remove all documents */
//					handleEmptyResultSet();
//					
//					/* Hide any views */
//					hideAllViews();
//					
//					hideIcons();
//					
//					prevNewDocsCount.value = 0;
//					
//				}
				
				_currentQueryTerms = currentQuery.keywords.value.indexOf(',') != -1?currentQuery.keywords.value.split(','):
					currentQuery.keywords.value.split(' ');
				if(isQueryDifferent || _firstLoad)
				{
					InfoMapAdminInterface.instance.queryDataSources(_currentQueryTerms,
						_currentRelatedKeywords);
				}
				
				var numOfDocsQuery:AsyncToken = _parentPanel.infoMapsDataSource.getNumOfDocumentsForQuery(
					_currentQueryTerms,_currentRelatedKeywords,currentQuery.operator.value,currentQuery.dateFilter,currentQuery.sources.value);
				
				var token:QueryObject = new QueryObject();
				copySessionState(currentQuery,token);
				addAsyncResponder(numOfDocsQuery,handleNumOfDocsQueryResult,handleNumOfDocsQueryFault,token);
				
			}
			
			private function handleNumOfDocsQueryResult(event:ResultEvent,token:QueryObject=null):void
			{
				var diff:Boolean = QueryObject.isQueryDifferent(token as QueryObject, currentQuery);
				
				if(diff)
				{
					return;
				}
				
				var numOfDocs:Number = event.result as Number;
				
				/* If no documents found, show status and do nothing. */
				if(numOfDocs <= 0)
				{
					status.text = "0 documents found. Checking with data sources...";
					addAsyncResponder(InfoMapAdminInterface.instance.getTotalNumberOfQueryResultsFromSource
						(_currentQueryTerms,_currentRelatedKeywords),handleTotalResults,handleTotalResultsFault);
					handleEmptyResultSet();
					adjustNodeBase();
					return;						
				}
				
				if(!_firstLoad && numOfMatchedDocuments.value == numOfDocs)
				{
					status.text = "";
					adjustNodeBase();
					return;
				}
				
				_firstLoad = false;
				
				/* emptying wordCount before sending it. I am using concat in the InfoMapDataSource. */
				wordCount = [];
				
				status.text = numOfDocs.toString() + " documents found. Fetching documents...";
				numOfMatchedDocuments.value = numOfDocs;
				handleChangeToPrevQuery();
				
				var docSetQuery:AsyncToken = _parentPanel.infoMapsDataSource.getDocumentsForQueryWithRelatedKeywords(
					_currentQueryTerms,_currentRelatedKeywords,currentQuery.operator.value,currentQuery.sources.value,
					currentQuery.dateFilter,2000,currentQuery.sortBy.value);
				
				addAsyncResponder(docSetQuery,handleQueryWithRelatedKeywordsResults,handleQueryWithRelatedKeywordsFault,token);
				
				var wordCountQuery:AsyncToken = _parentPanel.infoMapsDataSource.getWordCount(_currentQueryTerms,_currentRelatedKeywords,
					currentQuery.operator.value,currentQuery.sources.value,currentQuery.dateFilter,currentQuery.sortBy.value);
				
				var token:QueryObject = new QueryObject();
				copySessionState(currentQuery,token);
				
				addAsyncResponder(wordCountQuery,handleWordCountResult,handleWordCountFault,token);
				if(currentView.value == WORD_CLOUD_VIEW)
				{
					status.text = "Loading Word Cloud...";
				}
				else if(currentView.value == TOPICS_VIEW)
				{
					status.text = "Loading Topics...";
				}
				else if(currentView.value == POINTS_VIEW)
				{
					status.text = "Loading Points...";
				}
					
				getEntityDistribution();
				getTopicsClassification();
				getClusters();
			}
			
			private function handleTotalResults(event:ResultEvent,token:Object=null):void
			{
				if(event.result as Number> 0)
				{
					status.text = "Documents found! Wait for next refresh...";
				}
				else
				{
					status.text = "No documents found."; 
				}
			}
			
			private function handleTotalResultsFault(event:FaultEvent,token:Object=null):void
			{
				WeaveAPI.ErrorManager.reportError(event.fault.message,"Error with Data Source query");
			}
			
			
			
			private function handleQueryWithRelatedKeywordsResults(event:ResultEvent,token:QueryObject=null):void
			{
				var diff:Boolean = QueryObject.isQueryDifferent(token as QueryObject, currentQuery)
									|| QueryObject.isSortByDifferent(token as QueryObject, currentQuery);
				
				if(diff)
				{
					return;
				}
				
				var docsArray:Array = event.result as Array;
				var docsToAdd:Array = [];
				var keys:Array = [];
				
				var urlCol:IAttributeColumn =_parentPanel.infoMapsDataSource.getColumnByName('url'); 
				
				for (var i:int = 0; i < docsArray.length; i++)
				{
					var link:String = docsArray[i][0];
					
					var key:IQualifiedKey = WeaveAPI.QKeyManager.getQKey("infoMapsDoc",link);
					
					/*if the key is already present in the column, then we only add it to the keys keyset
					we will not add the currentDoc to the docsArray, this way the rows are not repeated in the csvDataString */
					if(urlCol.containsKey(key))
					{
						keys.push(link);
						continue;
					}
					
					docsToAdd.push(docsArray[i]);
					
					keys.push(link);
				}
				
				_parentPanel.infoMapsDataSource.csvData.setSessionState(
					(_parentPanel.infoMapsDataSource.csvData.getSessionState() as Array).concat(docsToAdd));			
				VectorUtils.copy(keys,_nameOrder);
				docKeySet.replaceKeys(WeaveAPI.QKeyManager.getQKeys("infoMapsDoc",keys));
				
				/* we force to trigger callbacks so that if a empty keyset is replaced with empty keys the callbacks are still called */
				docKeySet.triggerCallbacks(); 
			}
			
			private function handleQueryWithRelatedKeywordsFault(event:FaultEvent, token:Object=null):void
			{
				reportError("Error making query");
			}
			
			
			/**
			 * @private
			 **/
			private function handleDocKeySetChange():void
			{
				var response:Array = docKeySet.keys;
				
				
				var diff:Boolean = QueryObject.isQueryDifferent(previousQuery, currentQuery);
				
				if(diff)
				{
					//its a new query
					thumbnails.removeAllObjects();
					highlightNewDocuments = false;
					/* We do this because we list to remain on the same page if it is the same query. 
					Only switch to first page if it is new query*/
					if(docListComponent)
						docListComponent.startIndex.value = 0;
					if(thumbnailListComponent)
						thumbnailListComponent.startIndex.value = 0;
				}else
				{
					//its an old query
					if(thumbnails.getObjects().length == 0)
					{
						highlightNewDocuments = false;
					}
					else
					{
						highlightNewDocuments = true;
					}
				}
				
				/* we test the text because htmlText has tags with '/' */
				if(nodeBase.keywordTextArea.text && nodeBase.keywordTextArea.text.indexOf("/") >-1)
					nodeBase.keywordTextArea.htmlText = nodeBase.keywordTextArea.htmlText.replace(/\/[0-9]*/g,"/" +
						numOfMatchedDocuments.value);
				else
					nodeBase.keywordTextArea.htmlText = nodeBase.keywordTextArea.htmlText.replace(/\([0-9]*/g,"(" +
						numOfMatchedDocuments.value);
				
				_reusableThumbnailsToPlotArray = [];
				_currentNewDocsCount = 0;
				_thumbnailCount = 0;
				WeaveAPI.StageUtils.startTask(this,_iterateEachThumbnail,WeaveAPI.TASK_PRIORITY_PARSING,_completeThumbnailsIteration);
			}
			
			private var _thumbnailCount:Number = 0;
			private var _nameOrder:Array = [];
			private function _iterateEachThumbnail():Number
			{
				if(_thumbnailCount >= docKeySet.keys.length)
					return 1;
				
				var link:String = (docKeySet.keys[_thumbnailCount] as IQualifiedKey).localName;					
				var thumbnail:DocThumbnailComponent = thumbnails.getObject(link) as DocThumbnailComponent;
				
				
				if(!thumbnail)//if thumbnail does not exist
				{
					thumbnail = thumbnails.requestObject(link,DocThumbnailComponent,false);
					
					thumbnail.docURL.value = link;
					if(highlightNewDocuments)
					{
						thumbnail.highlighted.value = true;
						_currentNewDocsCount++;
					}
				}else
				{
					if(thumbnail.highlighted.value)
						_currentNewDocsCount++;
				}
				
				thumbnail.setStyle("borderColor",thumbnailsDefaultColor.value);
				
				/* first check to see if the thumbnail is present in movedThumbnails */
				var position:MovedThumbnailPosition = movedThumbNails.getObject(thumbnail.docURL.value) as MovedThumbnailPosition;
				
				/* if the document exists in movedThumbnails then make sure to set the moved positions and set hasBeenMoved to true; */
				if(position)
				{
//					thumbnail.hasBeenMoved.value = true;
					
//					copySessionState(position.xPos,thumbnail.xPos);
//					copySessionState(position.yPos,thumbnail.yPos);
					
					thumbnail.pos.setSessionState({x:position.xPos.value,y:position.yPos.value});
				}
				
				var p:Object = thumbnail.pos.getSessionState();
				/* if thumbnail has been moved make sure to add it as a child to Panel else make sure to add it as child to node. */
				if(p && (!isNaN(p.x) && !isNaN(p.y)))
				{
					if(thumbnail.parent != _parentPanel.map)
					{
						_parentPanel.map.addChild(thumbnail);
						
					}
					//xPos and yPos are not linked
					thumbnail.move(thumbnail.pos.getSessionState().x,thumbnail.pos.getSessionState().y);
					
				}else
				{
					if(thumbnail.parent != this)
					{
						thumbnail.visible = false;
					}
				}
				
				var qKey:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,link);
				
				if(_subset.containsKey(qKey))
				{
					thumbnail.visible = true;
				}else{
					
					thumbnail.visible = false;
				}
				thumbnail.setStyle("borderColor",thumbnailsDefaultColor.value);
//				linkSessionState(_parentPanel.selectedThumbnailBorderColor,thumbnail.selectedBorderColor);
//				linkSessionState(_parentPanel.newThumbnailGlowColor,thumbnail.glowColor);
				
				_thumbnailCount++;
				
				return _thumbnailCount/docKeySet.keys.length;
			}
			
			private function _completeThumbnailsIteration():void
			{
				thumbnails.setNameOrder(_nameOrder);
				thumbnails.resumeCallbacks();
				prevNewDocsCount.value = _currentNewDocsCount;
				
				_subMenu.addSubSubMenuItems("Show / Hide",["List View","Thumbnails View"],[toggleView,toggleView],[[LIST_VIEW],[THUMBNAILS_VIEW]]);
				_subMenu.addSubMenuItem("Hide All Views",hideAllViews);
				_subMenu.addSubSubMenuItems("Sort By", QueryObject.sortByOptions.concat(["New Documents"]),[sortBy,sortBy,sortBy,toggleShowNewDocsOnTop],
					[[QueryObject.SORT_BY_RELEVANCE],[QueryObject.SORT_BY_DATE_PUBLISHED],[QueryObject.SORT_BY_DATE_ADDED]]);
				
				_subMenu.addSubSubMenuItems("Filter By",QueryObject.filterByOptions,[filterQueryBy,filterQueryBy,filterQueryBy],
					[[QueryObject.FILTER_BY_NONE],[QueryObject.FILTER_BY_BOOKS],[QueryObject.FILTER_BY_PAPERS]]);
				
				updateNodeTextOnNewDocuments();
				adjustNodeBase();
				addAllDocumentsToList();
				if(currentView.value == THUMBNAILS_VIEW || currentView.value == LIST_VIEW)
				{
					status.text = "";
				}
				filteredWords.addGroupedCallback(this,filterListByKeywords,true);
			}
			
			private function handleWordCountResult(event:ResultEvent,token:QueryObject=null):void
			{
				var diff:Boolean = QueryObject.isQueryDifferent(token as QueryObject, currentQuery);
				
				if(diff)
				{
					return;
				}
				
				wordCount = event.result as Array;
				
				var wordCloudImg:Bitmap = new WordCloudImgClass() as Bitmap;
//				_radialMenu.addMenuItem(wordCloudImg,_wordCloudText,toggleWordCloud);
				_subMenu.addSubSubMenuItems("Show / Hide",["Word Cloud"],[toggleView],[[WORD_CLOUD_VIEW]]);	
				if(currentView.value == WORD_CLOUD_VIEW)
				{
					showView(WORD_CLOUD_VIEW);
				}
			}
			
			private function handleWordCountFault(event:FaultEvent,token:Object=null):void
			{
				reportError("Error making query for word count");
			}
				
			
			private function handleNumOfDocsQueryFault(event:FaultEvent,token:Object=null):void
			{
				Alert.show("Error getting number of documents");
				status.text = "";
			}
			
			
			private var parser:CSVParser = new CSVParser();
			
			public const prevNewDocsCount:LinkableNumber = registerLinkableChild(this,new LinkableNumber(0)); 
			[Bindable]
			private var _currentNewDocsCount:int = 0;
			//			private var _firstLoad:Boolean = true;
			

			
			private function clearAllNewDocuments(event:Event=null):void
			{
				_currentNewDocsCount = 0;
				
				for each(var t:DocThumbnailComponent in thumbnails.getObjects())
				{
					t.highlighted.value = false;
				}
				stopGlow();
				prevNewDocsCount.value = 0;
				_currentNewDocsCount = 0;
			}
			
			private function getRequiredKeywords():Array
			{
				var selectedKeys:Array = _selection.keys;
				
				var entityColumns:Array = _parentPanel.entityColumnsHashmap.getObjects();
				
				var requriedKeywords:Array = getKeywordsFromEntityColumns(selectedKeys);
				
				return requriedKeywords;
			}
			
			private function getUniqueKeywordsFromArray(keywords:Array):Array
			{
				//get unique keywords from extracted values 
				var dict:Dictionary = new Dictionary();
				
				for each(var word:String in keywords)
				{
					if(dict[word] == undefined)
						dict[word] = word;
				}
				
				var uniqueEntityValues:Array = []
				for each(var prop:String in dict)
				{
					uniqueEntityValues.push('"'+prop+'"');	
				}
				
				return uniqueEntityValues;
			}
			
			private var glowFilter:GlowFilter = new GlowFilter();
			private var glowTimer:Timer = new Timer(125);
			private function startGlow():void
			{
					nodeBase.keywordTextArea.filters = [glowFilter];
					glowTimer.addEventListener(TimerEvent.TIMER,changeGlow);
					glowTimer.start();
			}
			
			private function changeGlow(event:TimerEvent):void
			{
				glowFilter.alpha = 0.125 + (event.target.currentCount % 8) *0.125;
				glowFilter.color = thumbnailsDefaultColor.value;
				nodeBase.keywordTextArea.filters=[glowFilter];
			}
			
			private function stopGlow():void
			{
				glowTimer.stop();
				nodeBase.keywordTextArea.filters = [];
				nodeBase.keywordTextArea.alpha = 1;//restore alpha value to 1 incase timer stops at lesser alpha value
			}
			
			private function adjustNodeBase():void
			{
				nodeBase.keywordTextArea.validateNow();
				var widthOffset:int = 50;
				
				nodeBase.width = nodeBase.keywordTextArea.textWidth + widthOffset;
				if(nodeBase.width < 220)
					nodeBase.width = 220;
				nodeBase.keywordTextArea.width = nodeBase.width;
				nodeBase.keywordTextArea.height= nodeBase.keywordTextArea.mx_internal::getTextField().numLines * 20;
				nodeBase.height = nodeBase.keywordTextArea.height + _menuButton.height;
				nodeBase.keywordTextArea.y = _menuButton.height;
//				_radialMenu.y = 0;
				_menuButton.y = 0
				if(docListComponent)
					docListComponent.y = nodeBase.height;
				if(thumbnailListComponent)
					thumbnailListComponent.y = nodeBase.height;
				if(_pinImg)
				{
					_pinImg.x = nodeBase.width; 
					_pinImg.y = 0;
				}
				/*set pushpin image if required*/
				
			}
			
			override public function validateDisplayList():void
			{
				super.validateDisplayList();
				//				if(detectLinkableObjectChange(invalidateDisplayList,thumbnails,movedThumbNails))
				//					positionThumbnails();
			}
			
			public var _reusableThumbnailsToPlotArray:Array = [];
			
			
			
			private var _entitiesToKeysHashMap:Dictionary = new Dictionary();
			public var entityDistributionDataSource:CSVDataSource = new CSVDataSource(); 
			
			private const ENTITY_DISTRIBUTION_ENTITY_COLUMN:String =  "Entities";
			private const ENTITY_DISTRIBUTION_NUMBER_COLUMN:String =  "Number of Documents";
			private const ENTITY_DISTRIBUTION_KEYTYPE:String =  "entityDistribution";
			
			private function getEntityDistribution():void
			{
				var entityColumns:Array = _parentPanel.entityColumnsHashmap.getObjects();
				
				if(entityColumns.length == 0)
					return;
				
				if(!currentQuery.keywords.value)
					return;
				
				var requiredKeywords:Array = _currentQueryTerms;
				
				if(requiredKeywords.length == 0)
				{
					return;
				}
				
				var keys:Array = [];
				for each(var col:IAttributeColumn in entityColumns)
				{
					keys = keys.concat((col as IAttributeColumn).keys);
				}
				
				if(keys.length ==0)
				{
					return;
				}
				
				
				/* if there more than 1000 entities we will only show entity distribution for selected entities */
//				if(keys.length > 1000)
//				{
//				 return;					
//				}
				
				//mapping entities to keys. It maybe possible that each entity is associated with more than one key
				for each(var attrCol:IAttributeColumn in entityColumns)
				{
					for each(var qKey:IQualifiedKey in keys)
					{
						var value:String = ColumnUtils.getString(attrCol,qKey);
						if(value)
						{
							//if the entity is encountered for the first time, create an array containing the key
							//else push the key to the already existing array
							if(_entitiesToKeysHashMap[value] == undefined)
							{
								var a:Array = [qKey];
								_entitiesToKeysHashMap[value] = a;
								
							}else
							{
								(_entitiesToKeysHashMap[value] as Array).push(qKey);
							}
						}
					}
				}
				
				var entities:Array = [];
				for (var key:Object in _entitiesToKeysHashMap)
				{
					entities.push(key);
				}
				
				var entityQuery:AsyncToken = _parentPanel.infoMapsDataSource.getEntityDistributionForQuery(_currentQueryTerms,
															_currentRelatedKeywords,entities,currentQuery.operator.value,currentQuery.sources.value,
															currentQuery.dateFilter,2000,currentQuery.sortBy.value);
				
				var token:QueryObject = new QueryObject();
				copySessionState(currentQuery,token);
				addAsyncResponder(entityQuery,handleEntityQueryResults,handleEntityQueryFault,token);
			}
			
			
			//TODO: clear/invalidate them when the attirbute column changes.
			private var _entitiesToURLsHashMap:Dictionary = new Dictionary();
			private var _URLToEntitiesHashMap:Dictionary = new Dictionary();
			private function handleEntityQueryResults(event:ResultEvent,token:QueryObject=null):void
			{
				var diff:Boolean = QueryObject.isQueryDifferent(token as QueryObject, currentQuery);
				
				if(diff)
				{
					return;
				}
				
				var entities:Array = event.result.entities;
				var urls:Array = event.result.urls;
				
				var entityCSVData:Array = [];
				
				entityCSVData.push([ENTITY_DISTRIBUTION_ENTITY_COLUMN,ENTITY_DISTRIBUTION_NUMBER_COLUMN]);
				
				entityDistributionDataSource.keyType.value = ENTITY_DISTRIBUTION_KEYTYPE;
				
				for(var i:int = 0; i<entities.length; i++)
				{
					_entitiesToURLsHashMap[entities[i]] = urls[i];
					if(urls[i] != null)
						entityCSVData.push([entities[i],(urls[i] as Array).length]);

				}
				
				entityDistributionDataSource.csvData.setSessionState(entityCSVData);
				
				
				for(var j:int =0; j<urls.length; j++)
				{
					if(urls[j] == null)
						continue;
					
					for(var k:int = 0; k<urls[j].length; k++)
					{
						if(_URLToEntitiesHashMap[urls[j][k]] == undefined)
						{
							_URLToEntitiesHashMap[urls[j][k]] = [entities[j]]; 
						}else
						{
							(_URLToEntitiesHashMap[urls[j][k]] as Array).push(entities[j]);
						}
					}
				}
				
				var entityDistributionImg:Bitmap = new EntityDistributionImgClass() as Bitmap;
//				_radialMenu.addMenuItem(entityDistributionImg,_entityDistributionImgText,showDistributionChart);
				_subMenu.addSubSubMenuItems("Show / Hide",["Entity Distribution"],[showDistributionChart]);

			}
			
			private function handleEntityQueryFault(event:FaultEvent,token:Object=null):void
			{
				reportError("Error making query for entities");
				return;
			}
			
			private var _entityChartName:String = "entityDistributionChart";
			private function showDistributionChart(event:Event=null):void
			{
				//clear any selection so that bars don't appear faded out
				_selection.replaceKeys([]);
//				var className:String = getQualifiedClassName(CompoundBarChartTool).split("::")[1];
//				
//				_entityChartName = Weave.root.generateUniqueName(className);

				var object:CompoundBarChartTool = Weave.root.requestObject(_entityChartName, CompoundBarChartTool, false);
				object.showAllLabels.value = false;
				object.plotter.colorColumn.defaultValue.value = "0x0FDF801";
				
				if (object is DraggablePanel)
					(object as DraggablePanel).restorePanel();
				// put panel in front
				
				//				dispatchEvent(new CloseEvent(CloseEvent.CLOSE));
				
				object.heightColumns.removeAllObjects();
				
				entityDistributionDataSource.putColumnInHashMap(ENTITY_DISTRIBUTION_NUMBER_COLUMN,object.heightColumns);
				
				entityDistributionDataSource.putColumn(ENTITY_DISTRIBUTION_ENTITY_COLUMN,object.plotter.labelColumn);
				entityDistributionDataSource.putColumn(ENTITY_DISTRIBUTION_ENTITY_COLUMN,object.plotter.sortColumn);
				
				object.panelTitle.value = 'Entity Distribution for Query "' + currentQuery.keywords.value + '"';
			}
			
			
			private var _sortedByNewDocsArray:Array;
			private function sortNewDocumentsToTop():void
			{
				if(_nameOrder.length == 0)
					return;
				if(_currentNewDocsCount == 0)
					return;
				
				var newDocs:Array= [];
				var oldDocs:Array = [];
				
				for(var i:int=0; i <_nameOrder.length; i++)
				{
					var  d:DocThumbnailComponent = thumbnails.getObject(_nameOrder[i]) as DocThumbnailComponent;
					if(d.highlighted.value)
					{
						newDocs.push(WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,d.docURL.value));
					}
					else
					{
						oldDocs.push(WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,d.docURL.value));
					}
				}
				
				_sortedByNewDocsArray = newDocs.concat(oldDocs);
				docListComponent.keys = _sortedByNewDocsArray;
				thumbnailListComponent.keys = _sortedByNewDocsArray;
			}
			
			private function sortByNameOrder():void
			{
				var keys:Array = [];
				for(var i:int=0; i<_nameOrder.length; i++)
				{
					keys.push(WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,_nameOrder[i]));
				}
				docListComponent.keys = keys;
				thumbnailListComponent.keys = keys;
			}
			
			private function handleCurrentViewChange():void
			{
				hideAllViews();
				if(enablePinView.value)
				{
					showCurrentView();
				}
			}
			
			private function showCurrentView():void
			{
				showView(currentView.value);
			}
			
			private function hideCurrentView():void
			{
				hideView(currentView.value);
			}
			private function showView(view:String):void
			{
				if(view != currentView.value)
				{
					currentView.value = view;
					return;
				}
				
				if(view == LIST_VIEW) //Initialize List Canvas
				{
					docListComponent.y = nodeBase.height;
				}
				else if(view == THUMBNAILS_VIEW)
				{
					//if the list is not added yet
					if(!contains(thumbnailListComponent))
					{
						thumbnailListComponent.alpha = 0;
						addChild(thumbnailListComponent);
						
						thumbnailListComponent.y = nodeBase.height;
					}
					thumbnailListComponent.y = nodeBase.height;
					
				}
				else if(view == TOPICS_VIEW) //Initialize Topics Component
				{
					status.text = "Loading Topics...";
					
					/* if topicResult is null but number of matched documents is greater than 0 
					then we are still waiting to get back topic results*/
					if(_topicsResult == null && numOfMatchedDocuments.value > 0)
					{
						return;
					}
					if(flag_init){
						
						// ToDo This will not update automatically when new documents come in.
						//var colorRamp:Array = [0x808080, 0xFF0000, 0xFFFF00, 0x808000, 0x008000, 0x800080, 0xFF00FF, 0x0000FF]; // ToDo
						topicComponent.removeAllChildren();
						var urls:Array = _topicsResult.urls;
						var keywords:Array = _topicsResult.keywords;
						
						//store all the urls of the uncategoried documents, it is an 1D.
						var uncategoried:Array = _topicsResult.uncategoried; 
						
						//var topicComponent:TopicNodeComponent = new TopicNodeComponent();
						var parentComponent:UIComponent = new UIComponent();
						parentComponent.width = 400;
						parentComponent.height = 230; // ToDo Add extra 20 for displaying spot label
						parentComponent.y= nodeBase.height;
						
						topicComponent.drawTreeMap(urls, keywords, parentComponent, spaceBetwwenTopicRect.value);
						topicComponents.push(topicComponent);
						topicComponent.includeInLayout = false;
						
						//addChild(topicComponent);
						
						flag_init = false;
						topicComponent.alpha = 0;
					}
				}
				else if(view == WORD_CLOUD_VIEW)//Initialize Word Clould Canvas
				{
					status.text = "Loading Word Cloud...";
					
					/* if wordcount is zero but number of matched documents is greater than 0 
					then we are still waiting to get back word count results*/
					if(wordCount.length == 0 && numOfMatchedDocuments.value > 0)
					{
						return;
					}
					/*Add wordCloud as a child if not added yet*/
					if(wordCloud == null || !contains(wordCloud))
					{
						wordCloud = new TagCloud();
						wordCloud.addEventListener(MouseEvent.CLICK,handleTagCloudClick);
						wordCloud.visible = false;
						wordCloud.includeInLayout = false;
						addChild(wordCloud);
						wordCloud.alpha = 0;
						_viewToObjectMapping[WORD_CLOUD_VIEW] = wordCloud;
					}
					wordCloud.y= nodeBase.height;
					if(StandardLib.arrayCompare(wordCloud.dataProvider,wordCount) != 0)
					{
						wordCloud.dataProvider = wordCount;
						wordCloud.draw(numOfWordsInCloud.value);
					}
				}
				else if(view == POINTS_VIEW)
				{
					status.text = "Drawing points...";
					/* if topicResult is null but number of matched documents is greater than 0 
					then we are still waiting to get back topic results*/
					if(_topicsResult == null && numOfMatchedDocuments.value > 0)
					{
						return;
					}
					var topicURLS:Array = [];
					VectorUtils.copy(_topicsResult.urls,topicURLS);
					if(!contains(_pointCanvas))
					{
						addChild(_pointCanvas);
						_pointCanvas.alpha = 0; //initializing so that toggle will show the points
						_pointCanvas.visible = false;
					}
					_pointCanvas.y = nodeBase.height;
					_pointCanvas.drawPoints(topicURLS, _topicsResult.keywords, this);
					
				}

				adjustNodeBase();
				status.text = "";
				var viewUI:DisplayObject = _viewToObjectMapping[view] as DisplayObject;
				trace(viewUI.visible,viewUI.alpha);
				if(viewUI.visible && viewUI.alpha == 1)
					return;
				trace("fading in");
				fadeIn.play([viewUI]);
			}
			
			private function hideView(view:String):void
			{
				var viewUI:DisplayObject = _viewToObjectMapping[view] as DisplayObject;
				
				if(!viewUI.visible && viewUI.alpha == 0)
					return;
				trace("fading out");
				fadeOut.play([viewUI]);
			}
			
			private function hideAllViews():void
			{
				for each(var value:* in _viewToObjectMapping)
				{
					if(!value)
						continue;
					if(value.alpha !=0)
					{
						fadeOut.play([value]);
					}
				}
			}
			
			private function addAllDocumentsToList():void
			{
				var tNails:Array = thumbnails.getObjects();
				_reusableThumbnailsToPlotArray = [];	
				for (var i:int = 0; i<tNails.length; i++)
				{
					var t:DocThumbnailComponent = tNails[i];
					
					var docURL:String = thumbnails.getName(t);
					var qKey:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,docURL);
					
					if(_subset.containsKey(qKey))
					{
						_reusableThumbnailsToPlotArray.push(qKey);
					}
				}
				docListComponent.keys = _reusableThumbnailsToPlotArray;
				thumbnailListComponent.keys = _reusableThumbnailsToPlotArray;
			}
			
			public function showRelatedRecords():void
			{
				var selectedKeys:Array = _selection.keys;
				
				var requiredURLS:Array = [];
				
				for each(var key:IQualifiedKey in selectedKeys)
				{
					if(key.keyType == InfoMapsDataSource.DOC_KEYTYPE)
					{
						requiredURLS.push(key.localName);		
					}
				}
				
				handleDocumentSelection(requiredURLS);				
			}
			
			public function showRelatedDocuments():void
			{
				var requiredKeys:Array = _selection.keys;
				var entityColumns:Array = parentPanel.entityColumnsHashmap.getObjects();
				
				var entities:Array = [];
				
				for each (var key:IQualifiedKey in requiredKeys)
				{
					for each(var c:IAttributeColumn in entityColumns)
					{
						if(c.containsKey(key))
						{
							entities.push(c.getValueFromKey(key));				
						}
					}
				}
				
				var docs:Array = [];
				for each (var entity:String in entities)
				{
					docs = docs.concat(_entitiesToURLsHashMap[entity]);
				}
				
				var requiredDocKeys:Array = WeaveAPI.QKeyManager.getQKeys(InfoMapsDataSource.DOC_KEYTYPE,docs);
				
				_selection.addKeys(requiredDocKeys);
			}
			
			
			private function handleDocumentSelection(urls:Array):void
			{
				var keys:Array = [];
				//get all keys for selected documents
				for each (var url:String in urls)
				{
					var entities:Array = _URLToEntitiesHashMap[url];
					
					for each(var entity:String in entities)
					{
						if(_entitiesToKeysHashMap[entity])
							keys = keys.concat(_entitiesToKeysHashMap[entity]);
					}
				}
				_selection.addKeys(keys);
			}
			
			private function handleDocumentSelectedFromList(event:ListEvent):void
			{
				var items:Array = (event.currentTarget as List).selectedItems;
				
				var urls:Array = [];
				for each (var doc:IQualifiedKey in items)
				{
					urls.push(doc.localName);
				}
				handleDocumentSelection(urls);
			}
			
			
			private function getKeywordsFromEntityColumns(keys:Array=null):Array
			{
				var entityColumns:Array = _parentPanel.entityColumnsHashmap.getObjects();
				
				var requriedKeywords:Array = [];
				
				if(keys==null)
				{
					keys = (entityColumns[0] as IAttributeColumn).keys;
				}
				
				for each(var attrCol:IAttributeColumn in entityColumns)
				{
					for each(var key:IQualifiedKey in keys)
					{
						var value:String = ColumnUtils.getString(attrCol,key);
						if(value)
						{
							requriedKeywords.push(value);
						}
					}
				}
				
				requriedKeywords = getUniqueKeywordsFromArray(requriedKeywords);
				
				return requriedKeywords;
			}
			
			private var _selection:KeySet = Weave.root.getObject(Weave.DEFAULT_SELECTION_KEYSET) as KeySet;
			/**
			 * Highlights selected documents
			 **/
			private function handleSelectionKeySetChange():void
			{
				if(parentPanel == DraggablePanel.activePanel)
				{
					showRelatedRecords();	
				}
				else
				{
					showRelatedDocuments();
				}
				
				var keys:Array = _selection.keys;
				var docs:Array = thumbnails.getNames();
				
				
				var selectedDocs:Array = getSelectedDocumentKeys();
				
				//if none are selected set all to default mode
				if(selectedDocs.length == 0)
				{
					for each(var doc1:String in docs)
					{
						var t1:DocThumbnailComponent = thumbnails.getObject(doc1) as DocThumbnailComponent;
						t1.setMode(DocThumbnailComponent.DEFAULT_MODE);
					}
					handleSelectionChangeInViews();
					return;
				}
				
				
				for each(var doc:String in docs)
				{
					var qKey:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,doc);
					var t:DocThumbnailComponent = thumbnails.getObject(doc) as DocThumbnailComponent;
					var selected:Boolean =_selection.containsKey(qKey) 
					if(selected)
						t.setMode(DocThumbnailComponent.SELECTED_MODE);
					else
						t.setMode(DocThumbnailComponent.UNSELECTED_MODE);
				}
				
				handleSelectionChangeInViews();
			}
			
			private function handleSelectionChangeInViews():void
			{
				if(parentPanel == DraggablePanel.activePanel)
				{
					return;
				}
				var view:String = currentView.value;
				
				if( view == THUMBNAILS_VIEW || view == LIST_VIEW)
				{
					
					var listView:AbstractListView = _viewToObjectMapping[view];
					var keys:Array = _selection.keys;
					if(keys.length == 0)
					{
						listView.removeFilter(AbstractListView.SELECTION_TEXT);
					}
					else
					{
						var filterByKeys:Array = [];
						for each(var key:IQualifiedKey in keys)
						{
							if(key.keyType == InfoMapsDataSource.DOC_KEYTYPE)
							{
								filterByKeys.push(key);
							}
						}
						
						listView.applyFilter(AbstractListView.SELECTION_TEXT,filterByKeys);
					}
				}
			}
			
			/* If there is a change in the moved thumbnails then we redraw the list incase a document was added back to the node. */
			private function handleMovedThumbnailsChangesInViews():void
			{
				if(currentView.value == LIST_VIEW)
				{
					docListComponent.redrawList();
				}
				else if(currentView.value == THUMBNAILS_VIEW)
				{
					thumbnailListComponent.redrawList();
				}
			}
			private function getSelectedDocumentKeys():Array
			{
				var selectedKeys:Array = _selection.keys;
				var selectedDocs:Array = [];
				
				for each(var key:IQualifiedKey in selectedKeys)
				{
					if(key.keyType == InfoMapsDataSource.DOC_KEYTYPE)
						selectedDocs.push(key);
				}
				
				return selectedDocs;
			}
			
//			private var _searchKeySet:KeySet = new KeySet();
			//sends a query to solr for the search keywords filtrered by document links belonging to this node
			private function handleGlobalSearch():void
			{
				
//				if(!_parentPanel.globalSearchKeyword.value)
//				{
////					_searchKeySet.clearKeys();
////					_searchKeySet.triggerCallbacks();
//					return;
//				}
//				
//				var fieldNames:Array = ['link'];
//				
//				var fieldValues:Array = [];
//				
//				fieldValues.push(thumbnails.getNames());
//				
//				if(!query.sources.value == '')
//				{
//					var sourceNames:Array = parser.parseCSV(query.sources.value)[0]; //we send only the first row since this is a one-line CSV String
//				}
//				
//				_parentPanel.infoMapsDataSource.getDocumentsForQueryWithFieldValues(_searchKeySet,_parentPanel.globalSearchKeyword.value,fieldNames,fieldValues,null,"OR",null,2000,false);
				
				
//				filteredWords.value = 
			}
			
			public function filterBy(keywords:String):void
			{
				filteredWords.value = keywords;
			}
			
			//this function is called when the _searchKeySet is set. 
			//This sets the thumbnail's visiblity based if its link is included or excluded in the _searchKeySet
			private function handleSearchKeySetChange():void
			{
				//				var tnails:Array = thumbnails.getObjects();
				//				
				//				var searchMatchedKeys:Array =_searchKeySet.keys; 
				//				
				//				if(searchMatchedKeys.length == 0)
				//				{
				//					//if searchKeys length is zero and if there is search keyword then none of the documents matched. So we set all visiblity to false
				//					//else set all to true;
				//					var visiblity:Boolean =  (_parentPanel.globalSearchKeyword.value != "");
				//					for each(var t1:DocThumbnailComponent in tnails)
				//					{
				//						var qKey1:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,t1.docURL.value);
				//						if(_subset.containsKey(qKey1))
				//						{
				//							
				//							t1.visible = !visiblity;
				//						}
				//					}
				//				}else
				//				{
				//					for each(var t2:DocThumbnailComponent in tnails)
				//					{
				//						var qKey2:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,t2.docURL.value);
				//						if(_subset.containsKey(qKey2))
				//						{
				//							
				//							t2.visible = false;
				//						}
				//					}
				//				}
				//				
				//				for each(var k:IQualifiedKey in searchMatchedKeys)
				//				{
				//					var t3:DocThumbnailComponent = thumbnails.getObject(k.localName) as DocThumbnailComponent;
				//					
				//					if(!t3)
				//						continue;
				//					
				//					var qKey3:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,t3.docURL.value);
				//								
				//					
				//					if(t3 && qKey3 && _subset.containsKey(qKey3))
				//					{
				//						
				//						t3.visible = true;
				//					}
				//				}
				
			}
			
			// ToDo dateFilter should be previousQuery.dateFilter
			private function handleGlobalDateChange():void
			{
//				getCallbackCollection(currentQuery).delayCallbacks();
//				dateFilter.startDate.value = _parentPanel.globalDateFilter.startDate.value;
//				dateFilter.endDate.value = _parentPanel.globalDateFilter.endDate.value;
//				getCallbackCollection(currentQuery).resumeCallbacks();
			}
			private function removeEmptyStringElementsFromArray(arg:Array):Array
			{
				var result:Array = [];
				for each(var item:String in arg)
				{
					if(item != "")
						result.push(item);
				}
				
				return result;
			}
			
			
			private var _wasClicked:Boolean = false;
			//toggle node selection on click
			private function handleClick(event:Event):void
			{
				//if running to blink node.
				stopGlow();
				
				_wasClicked = true;
				
				if(wasDragged)
				{
					wasDragged = false;
					return;
				}
				//				if(node.selected.value)
				//					node.selected.value = false;
				//				else
				//					node.selected.value = true;
			}
			
			//highlight node based on node.selected.value
			private function highlightNode():void
			{
				//				unselectedBorder.color = _parentPanel.defaultNodeBorderColor.value;
				//				selectedBorder.color = _parentPanel.selectedNodeBorderColor.value;
				//				
				//				if(node.selected.value)
				//					selectedBorder.play();
				//				else
				//					unselectedBorder.play();
			}
			
			//this variable will be  used to avoid selection/unselection when the node is dragged
			private var wasDragged:Boolean = false;
			private var _lastX:Number = 0;
			private var _lastY:Number = 0;
			private var sbroot:DisplayObject = Application.application.systemManager.getSandboxRoot();
			private var handCursorID:int = -1;
			protected function canvas1_mouseDownHandler(event:MouseEvent):void
			{
				event.stopImmediatePropagation();
				nodeBase.keywordTextArea.setStyle("fontWeight","bold");
				handCursorID = CustomCursorManager.showCursor(InteractiveVisualization.CURSOR_HAND_GRAB);
				_lastX = x;
				_lastY = y;
				this.addEventListener(MouseEvent.MOUSE_MOVE,handleMouseMove);
				// solution for handling mous_up outside of stage : http://stackoverflow.com/questions/2944122/flash-correctly-handling-click-and-drag-outside-the-browser
				sbroot.addEventListener(SandboxMouseEvent.MOUSE_UP_SOMEWHERE, handleMouseUpSomewhere);
				this.startDrag();
			}
			
			private function handleMouseMove(event:Event):void
			{
				wasDragged = true;
			}
			
			private var stageUtils:StageUtils = new StageUtils();
			protected function canvas1_mouseUpHandler(event:Event):void
			{
				nodeBase.keywordTextArea.setStyle("fontWeight","normal");
				CustomCursorManager.removeCursor(handCursorID);
				this.removeEventListener(MouseEvent.MOUSE_MOVE,handleMouseMove);
				sbroot.removeEventListener(SandboxMouseEvent.MOUSE_UP_SOMEWHERE, handleMouseUpSomewhere);
				this.stopDrag();
			}
			
			private function handleMouseUpSomewhere(event:Event):void
			{
				this.x = _lastX;
				this.y = _lastY;
				canvas1_mouseUpHandler(event);
			}
			
			private function keywordTextAreaKeyDownHandler(event:KeyboardEvent):void
			{
				if(event.keyCode == Keyboard.ENTER || event.keyCode == Keyboard.ESCAPE)
				{
					event.preventDefault();
					nodeBase.keywordTextArea.editable = false;
					nodeBase.keywordTextArea.selectable = false;
					if(event.keyCode == Keyboard.ENTER)
					{
						previousQuery.keywords.value = nodeBase.keywordTextArea.text;
					}
					else
					{
						updateTextArea();
						updateNodeTextOnNewDocuments();
					}
				}
			}
			
			private function handleViewOnRollOver(event:Event):void
			{
				if(!enablePinView.value)
				{
					fadeOut.stop();
					showCurrentView();
					trace("ROlled Over");
				}
			}
			
			private function handleViewOnRollOut(event:Event):void
			{
				if(!enablePinView.value)
				{
					fadeIn.stop();
					hideCurrentView();
					trace("rolled out");
				}
			}
			
			// ToDo ???
//			private function filter(event:Event):void
//			{
//				DateFilterComponent.openInstance(this,dateFilter);
//			}
			
//			private var _instance:NodeSettingsComponent = null;
//			private function settings(event:Event):void
//			{
//				
//				if(_instance)
//				{
//					PopUpManager.addPopUp(_instance,this);
//				}
//				else
//				{
//					_instance = new NodeSettingsComponent();
//					_instance.query = this.currentQuery;
//					_instance.nodeHandler = this;
//					_instance.dateFilter = dateFilter;
//					PopUpManager.addPopUp(_instance,this);
//				}
//			}
			
			[Embed( source="/weave/resources/images/pushpinback.png")]
			private var _pinBackImgClass:Class;
			
			[Embed( source="/weave/resources/images/pushpin.png")]
			private var _pinImgClass:Class;
			
			private var _pinImgText:String ="Pin Views";
			private var _pinImg:Image = null;
			private function togglePinViews(event:Event=null):void
			{
				enablePinView.value = !enablePinView.value;
			}
			
			private function handlePinViewChange():void
			{
				if(enablePinView.value)
				{
					_pinImg.source = _pinBackImgClass;
					showCurrentView();
				}
				else
				{
					_pinImg.source = _pinImgClass;
					hideCurrentView();
				}
			}
			
			private var _instance:ControlPanel = null;
			protected var basicSettingComponent:BasicSettingsComponent;
			protected var tagCloudSettingComponent:TagCloudSettingComponent;
			protected var topicModelSettingComponent:TopicNodeSettingComponent
			private function settings(event:Event=null):void
			{
				
				if(_instance)
				{
					PopUpManager.addPopUp(_instance,this);
				}
				else
				{
					_instance = new ControlPanel();
					
					basicSettingComponent = new BasicSettingsComponent();
					basicSettingComponent.query = this.previousQuery;
					basicSettingComponent.dateFilter = previousQuery.dateFilter;
					basicSettingComponent.nodeHandler = this;
					
					tagCloudSettingComponent = new TagCloudSettingComponent();
					tagCloudSettingComponent.nodeHandler = this;
					
					topicModelSettingComponent = new TopicNodeSettingComponent();
					topicModelSettingComponent.nodeHandler = this;
					
				_instance.targets = [basicSettingComponent.query.keywords,basicSettingComponent.query.sources, basicSettingComponent.dateFilter.startDate, basicSettingComponent.dateFilter.endDate, numOfWordsInCloud, numOfTopics, numOfKeywordsInEachTopic, spaceBetwwenTopicRect, topicNodeComponent.rectColors]
					_instance.children = [basicSettingComponent, tagCloudSettingComponent, topicModelSettingComponent];
					
					PopUpManager.addPopUp(_instance,this);
				}
			}
			
			private function close(event:Event=null):void
			{
				Alert.show("Are you sure you want to remove this node?",
					"Remove Node?",
					Alert.YES | Alert.NO,
					null,
					handleCloseEvent
				);
			}
			
			
			
			/* TODO: if _subset and _tagWordSubset is empty just plot all */
			private function includedThumbnails():Array
			{
				var thumbs:Array = thumbnails.getObjects();
				var requiredThumbs:Array = []
				for (var i:int = 0; i < thumbs.length; i++)
				{
					var docURL:String = (thumbs[i] as DocThumbnailComponent).docURL.value;
					var qKey:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,docURL);
					
					if(_subset.containsKey(qKey))
					{
						requiredThumbs.push(thumbs[i]);
					}
				}
				return requiredThumbs;
			}
			
			private var _pointCanvas:PointsLayout = new PointsLayout();
			
			private var wordCloud:TagCloud = new TagCloud();
			private var colorRamp:ColorRamp = new ColorRamp();
			private var wordCount:Array = [];
						
			private function redrawWordCloud():void
			{
				if(wordCloud != null)
				{
					removeWordCloud();
					toggleView(WORD_CLOUD_VIEW);
				}
			}
			
			private function toggleView(view:String):void
			{
				/* if current view is not List then we change it to current view and leave it to handleCurrentViewChange */
				if(currentView.value != view)
				{
					currentView.value = view
				}
				/* if current view is already List view then toggle it*/
				else
				{
					var v:String = currentView.value;
					var viewUI:DisplayObject = _viewToObjectMapping[v] as DisplayObject;
					if(viewUI.visible && viewUI.alpha != 0)
					{
						hideView(v);
					}
					else
					{
						showView(v);
					}
				}
				
			}
			
			public const docListComponent:DocumentListView = registerLinkableChild(this, new DocumentListView());
			public const thumbnailListComponent:ThumbnailsListView = registerLinkableChild(this,new ThumbnailsListView());
			
			private var _showListFlag:Boolean = false;
//			private var clickedWordKeySet:KeySet = new KeySet();
			public const filteredWords:LinkableString = registerLinkableChild(this,new LinkableString("",null,false));
			private function handleTagCloudClick(event:MouseEvent):void
			{
				//we don't use the event.target for getting the text because this is based on the bounding box clicked and not necessarily the 
				//probed word. So we used the last recorded probed word
				if(event.target is CustomLabel)
					filteredWords.value= ((event.target as CustomLabel).parent as TagCloud).lastProbedWord.value;
				else
					return;
			}
			
			private function filterListByKeywords():void
			{
				if(!filteredWords.value)
				{
//					_tagWordSubset.replaceKeys(false,true,[]);					
					return;
				}
				
				var filterQuery:AsyncToken = _parentPanel.infoMapsDataSource.getLinksForFilteredQuery(_currentQueryTerms,_currentRelatedKeywords,
					currentQuery.dateFilter,filteredWords.value.split(','),2000,currentQuery.operator.value,
					currentQuery.sources.value,currentQuery.sortBy.value);
				
				addAsyncResponder(filterQuery,handleFilterQueryResult,handleFilterQueryFault);
			}
			
			private function handleFilterQueryResult(event:ResultEvent,token:Object=null):void
			{
				var urls:Array = event.result as Array;
				filterDocumentsByURLS(urls,"'" + filteredWords.value + "'");
			}
				
			private function handleFilterQueryFault(event:FaultEvent,token:Object=null):void
			{
				reportError("Error making query for filtering");
				
			}
			
			public function filterDocumentsByURLS(urls:Array,filterMessage:String=""):void
			{
				var keys:Array = [];
				for (var i:int = 0; i < urls.length; i++)
				{
					var key:IQualifiedKey = WeaveAPI.QKeyManager.getQKey("infoMapsDoc",urls[i]);
					keys.push(key);
				}
				
				docListComponent.applyFilter(filterMessage,keys);
				
				status.text = "";
				currentView.value = LIST_VIEW;
			}
			
			private function getTopicsClassification():void
			{
				var topicsQuery:AsyncToken = null
				if(numOfMatchedDocuments.value <= 20 && numOfTopics.value > 3)
				{
					topicsQuery = _parentPanel.infoMapsDataSource.classifyDocumentsForQuery(_currentQueryTerms,_currentRelatedKeywords,
						currentQuery.operator.value,currentQuery.sources.value,currentQuery.sortBy.value,currentQuery.dateFilter,2000, 3,
						numOfKeywordsInEachTopic.value);
				}
				else
				{
					topicsQuery = _parentPanel.infoMapsDataSource.classifyDocumentsForQuery(_currentQueryTerms,
						_currentRelatedKeywords,currentQuery.operator.value,currentQuery.sources.value,currentQuery.sortBy.value,currentQuery.dateFilter,2000, numOfTopics.value,
						numOfKeywordsInEachTopic.value);
				//trace("Number of Topics and number of keywords in each topic: " + numOfTopics.value + numOfKeywordsInEachTopic.value);
				}
				
				var token:QueryObject = new QueryObject();
				copySessionState(currentQuery,token);
				addAsyncResponder(topicsQuery,handleTopicsQueryResult,handleTopicsQueryFault,token);
			}
			
			private function handleTopicsPropertiesChange():void
			{
				if(currentQuery.keywords.value != null)
				{
					getTopicsClassification();
					
					flag_init = true;
					 if(!flag_click){
						flag_click = true;
					}  
				}
			}
			
			private var _clusterRadVizName:String;
			private function getClusters():void
			{
				clusterCSVDataSource.url.value = "/InfoMapServices/AdminService";
				var servletParam:Object = new Object();
				servletParam.method = "getClustersForQueryWithRelatedKeywords";
				servletParam.params = [_currentQueryTerms,_currentRelatedKeywords,DateUtils.getDateFilterStringForSolr(currentQuery.dateFilter),2000,
					currentQuery.operator.value,currentQuery.sources.value,currentQuery.sortBy.value];
				clusterCSVDataSource.servletParams.value = servletParam;
				clusterCSVDataSource.keyColName.value = "document";
				clusterCSVDataSource.keyType.value = InfoMapsDataSource.DOC_KEYTYPE;
				var clusterImg:Bitmap = new ClusterImgClass() as Bitmap;
//				_radialMenu.addMenuItem(clusterImg,_clusterImgText,showClusters);
				_subMenu.addSubSubMenuItems("Show / Hide",["Clusters"],[showClusters]);
			}
			
			public var clusterCSVDataSource:CSVDataSource = new CSVDataSource();
			private function showClusters(event:Event=null):void
			{
				var columnNames:Array = clusterCSVDataSource.getColumnNames();
				
				var object:RadVizTool = Weave.root.requestObject(_clusterRadVizName, RadVizTool, false);
				object._plotter.columns.removeAllObjects();
//				object._anchorPlotter.anchors.removeAllObjects();
				var count:int = 0;
				for each(var columnName:String in columnNames)
				{
					if(count >30)
						break;
					if(columnName != "document" && columnName != "Other Topics")
					{
						clusterCSVDataSource.putColumnInHashMap(columnName,object._plotter.columns);
					}
					count++;
				}
				object.panelTitle.value = 'Document Clustered by Labels';
				object.enableProbeLines.value = true;
				_parentPanel.infoMapsDataSource.putColumnInHashMap("title",Weave.root.getObject("Probed Columns") as LinkableHashMap);
				if (object is DraggablePanel)
					(object as DraggablePanel).restorePanel();
			}

			private var topicComponents:Array = new Array();
			private var flag_click:Boolean = true;
			private var flag_init:Boolean =true;
			private var _topicsResult:Object = null;
			public const topicComponent:TopicNodeComponent = registerLinkableChild(this, new TopicNodeComponent());
			public function get topicNodeComponent():TopicNodeComponent // ToDo TopicModelSettingComponent
			{
				return topicComponent;
			}
			private function showClassificationResults(event:Event=null, forceShow:Boolean=false,forceHide:Boolean=false):void
			{   
				if(_topicsResult == null)
					return;
				toggleView(TOPICS_VIEW);
			}
			
			private function handleTopicsQueryResult(event:ResultEvent, token:QueryObject = null):void
			{
				status.text = "";
				var diff:Boolean = QueryObject.isQueryDifferent(token as QueryObject, currentQuery);
				
				if(diff)
				{
					return;
				}
				
				_topicsResult = event.result;

				if (_topicsResult.keywords == null || _topicsResult.urls == null)
				{
					reportError(lang("Topic Models did not return an Array of results as expected."));
					return;
					
				}
				
				var topicsImg:Bitmap = new TopicsImgClass() as Bitmap;
//				_radialMenu.addMenuItem(topicsImg,_topicsImgText,showClassificationResults);
				_subMenu.addSubSubMenuItems("Show / Hide",["Topics View"],[showClassificationResults]);
				
				var pointsImg:Bitmap = new PointsImgClass() as Bitmap;
//				_radialMenu.addMenuItem(pointsImg,_pointsImgText,showPoints);
				_subMenu.addSubSubMenuItems("Show / Hide",["Points View"],[toggleView],[[POINTS_VIEW]]);
				if(currentView.value == TOPICS_VIEW || currentView.value == POINTS_VIEW)
				{
					showView(currentView.value);
				}
			}
			
			private function handleTopicsQueryFault(event:FaultEvent, token:Object = null):void
			{
				trace(["fault", token, event.message].join('\n'));
				reportError(event);
			}
			
			//this variable is false when the user loads the map for the first time. 			
			private var highlightNewDocuments:Boolean = true;
//			private function checkForNewDocuments(event:TimerEvent):void
//			{
//				if(!previousQuery.sources.value == '')
//				{
//					var sourceNames:Array = parser.parseCSV(previousQuery.sources.value)[0]; //we send only the first row since this is a one-line CSV String
//				}
//				//emptying wordCount before sending it. I am using concat in the InfoMapDataSource.
//				wordCount = [];
//				status.text = "Searching...";
//				_parentPanel.infoMapsDataSource.getDocumentsForQuery(docKeySet,wordCount,numOfMatchedDocuments,currentQuery.keywords.value,currentQuery.operator.value,sourceNames,currentQuery.dateFilter);
//			}
			
			private function editQuery():void
			{
				makeKeywordTextAreaEditable();
				nodeBase.keywordTextArea.setSelection(0,nodeBase.keywordTextArea.length);
			}
			private function makeKeywordTextAreaEditable():void
			{
				nodeBase.keywordTextArea.editable = true;
				nodeBase.keywordTextArea.selectable = true;
				nodeBase.keywordTextArea.setFocus();
			}
			
			private function handleChangeToPrevQuery():void
			{
				var diff:Boolean = QueryObject.isQueryDifferent(previousQuery, currentQuery) || 
										QueryObject.isSortByDifferent(previousQuery, currentQuery);
				
				if(!previousQuery.keywords.value)
				{
					makeKeywordTextAreaEditable();
					nodeBase.keywordTextArea.setSelection(0,0);
					nodeBase.keywordTextArea.htmlText = "";
					newDocumentHighlight.stop();//in case node is blinking
					stopGlow();
					hideAllViews();
					if(contains(docListComponent))
					{
						docListComponent.keys = [];//clearing items in list
					}
					if(contains(thumbnailListComponent))
					{
						thumbnailListComponent.keys = [];
					}
					if(wordCloud)
					{
						removeWordCloud();
					}
					if(diff)
						copySessionState(previousQuery,currentQuery);
					
					adjustNodeBase();
					filteredWords.removeCallback(filterListByKeywords);
					return;
				}
				
				updateTextArea();
				
				if(QueryObject.isQueryDifferent(previousQuery,currentQuery))
				{
					copySessionState(previousQuery,currentQuery);
					if(!_firstLoad)
					{
						/* remove all documents */
						handleEmptyResultSet();
						
						/* Hide any views */
						hideAllViews();
						
						hideIcons();
					}
					createAndSendQuery();
				}
				else if(QueryObject.isSortByDifferent(previousQuery,currentQuery))
				{
					status.text = "Sorting...";
					copySessionState(previousQuery,currentQuery);
					var token:QueryObject = new QueryObject();
					copySessionState(currentQuery,token);
					var docSetQuery:AsyncToken = _parentPanel.infoMapsDataSource.getDocumentsForQueryWithRelatedKeywords(
						_currentQueryTerms,_currentRelatedKeywords,currentQuery.operator.value,currentQuery.sources.value,
						currentQuery.dateFilter,2000,currentQuery.sortBy.value);
					
					addAsyncResponder(docSetQuery,handleQueryWithRelatedKeywordsResults,handleQueryWithRelatedKeywordsFault,token);
				}

				updateNodeTextOnNewDocuments();
				adjustNodeBase();
			}
			
			private function updateTextArea():void
			{
				//we restrict node length to 200.
				if(previousQuery.keywords.value.length >200)
				{
					nodeBase.keywordTextArea.htmlText = previousQuery.keywords.value.substr(0,200) + " ... ("+numOfMatchedDocuments.value +")";
				}else
				{
					nodeBase.keywordTextArea.htmlText = previousQuery.keywords.value + "("+ numOfMatchedDocuments.value +")";
				}
				nodeBase.keywordTextArea.editable = false;
				nodeBase.keywordTextArea.selectable = false;
			}
			private function removeWordCloud():void
			{
				wordCloud.clearCloud();
				wordCloud.dataProvider = [];//clearing word cloud
				if(contains(wordCloud))
					removeChild(wordCloud);
				wordCloud = null;
			}
			
			private function updateNodeTextOnNewDocuments():void
			{
				if((prevNewDocsCount.value>0) || (highlightNewDocuments && _currentNewDocsCount>0 && _currentNewDocsCount != prevNewDocsCount.value))
				{
					
					/* htmlText sometimes just has the text and sometimes the text with the HTML tags.
						I haven't tested to see when each case specifically occirs. For now, I test it with text and if text is null
						test it with htmlText.
					*/
					var nodeText:String;
					if(nodeBase.keywordTextArea.text)
					{
						nodeText = nodeBase.keywordTextArea.text;
					}
					else
					{
						nodeText = nodeBase.keywordTextArea.htmlText;	
					}
					
					if(nodeText.indexOf("/") >-1)
						nodeBase.keywordTextArea.htmlText = nodeBase.keywordTextArea.htmlText.replace(/\([0-9]*\//g,"(" + _currentNewDocsCount + "/");
					else
						nodeBase.keywordTextArea.htmlText = nodeBase.keywordTextArea.htmlText.replace(/\(/g,"(" + _currentNewDocsCount + "/");
				}
			}
			
			/* Since we use a private query object we define a public function to set variable */
			public function applyKeywords(keywords:String):void
			{
				previousQuery.keywords.value = keywords;
				if(_parentPanel.relatedKeywords.value)
					_currentRelatedKeywords = _parentPanel.relatedKeywords.value.indexOf(',') != -1? _parentPanel.relatedKeywords.value.split(','):
						_parentPanel.relatedKeywords.value.split(' ');
			}
			
			private var _currentRelatedKeywords:Array = null;
			public function applyKeywordsFromSelection():void
			{
				if(!_parentPanel)
				{
					var hashmap:LinkableHashMap = WeaveAPI.SessionManager.getLinkableOwner(this) as LinkableHashMap;					
					_parentPanel = WeaveAPI.SessionManager.getLinkableOwner(hashmap) as InfoMapPanel;
				}
				
				previousQuery.keywords.value = getRequiredKeywords().join(',');
				previousQuery.operator.value = "OR";
				if(_parentPanel.relatedKeywords.value)
					_currentRelatedKeywords = _parentPanel.relatedKeywords.value.indexOf(',') != -1? _parentPanel.relatedKeywords.value.split(','):
						_parentPanel.relatedKeywords.value.split(' ');
				_selection.clearKeys();
			}
			
			private function toggleShowNewDocsOnTop():void
			{
				showNewDocumentsOnTop.value = !showNewDocumentsOnTop.value
			}
			
			private function handleSortNewDocsChange():void
			{
				if(showNewDocumentsOnTop.value)
				{
					sortNewDocumentsToTop();
				}
				else
				{
					sortByNameOrder();
				}
			}
			private function sortBy(option:String):void
			{
				if(previousQuery.sortBy.value == option)
				{
					sortByNameOrder();		
				}
				else
				{
					previousQuery.sortBy.value = option;
				}
			}
			
			private function filterQueryBy(option:String):void
			{
				if(option == QueryObject.FILTER_BY_NONE)
					option = "";

				if(previousQuery.sources.value != option)
					status.text = "Filtering...";
				
				previousQuery.sources.value = option;
			}
			
			private function handleDateFilterChange():void
			{
//								createAndSendQuery(); // ToDo
			}
			
			
			private function handleDragEnter(event:DragEvent):void 
			{
				if(event.dragInitiator is DocThumbnailComponent)
				{
					if(thumbnails.getObject((event.dragInitiator as DocThumbnailComponent).docURL.value))
						DragManager.acceptDragDrop(event.currentTarget as NodeBaseComponent);
				}
			}
			
//			private var _currentView:UIComponent = null;
			private function handleEffectsStart(event:EffectEvent):void
			{
				var displayObj:UIComponent= event.effectInstance.target as UIComponent;
				if(!displayObj)
					return;
				
				displayObj.mouseChildren = false;
				if(event.currentTarget == fadeIn)
				{
					displayObj.visible = true;
				}
			}
			
			private function handleEffectsEnd(event:EffectEvent):void
			{
				var displayObj:UIComponent= event.effectInstance.target as UIComponent;
				
				if(!displayObj)
					return;
				
				displayObj.mouseChildren = true;
				if(event.currentTarget == fadeOut)
				{
					displayObj.visible = false;
					if(displayObj == _pointCanvas)
					{
						_pointCanvas.removeAllChildren();
					}
				}
			}
			
			private function handleBorderColor():void
			{
				nodeBase.keywordTextArea.setStyle("borderColor",thumbnailsDefaultColor.value);
			}
			
			private function handleCloseEvent(e:CloseEvent):void
			{
				if(e.detail == Alert.YES)
				{
					thumbnails.removeAllObjects();
					var parent:ILinkableHashMap = (WeaveAPI.SessionManager.getLinkableOwner(this) as ILinkableHashMap);
					var nodeName:String  = parent.getName(this);
					parent.removeObject(nodeName);
				}
				else if(e.detail == Alert.NO)
				{
					return;
				}
			}			
			
			private function hideIcons():void
			{
//				_radialMenu.removeAllMenuItems();
				_subMenu.removeAllSubMenuItems();
			}
			
			private function handleEmptyResultSet():void
			{
				thumbnails.removeAllObjects();
				numOfMatchedDocuments.value = 0;
				_currentNewDocsCount = 0;
				prevNewDocsCount.value = 0;
				updateTextArea();
				docKeySet.replaceKeys([]);
				/* emptying wordCount before sending it. I am using concat in the InfoMapDataSource. */
				wordCount = [];
				
			}
			
			public function dispose():void
			{
				refreshTimer.stop();
			}
		]]>
	</mx:Script>
	
</mx:Canvas>
