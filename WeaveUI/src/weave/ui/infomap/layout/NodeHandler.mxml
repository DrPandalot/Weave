<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas xmlns:mx="http://www.adobe.com/2006/mxml" horizontalScrollPolicy="off" verticalScrollPolicy="off"
		   implements="weave.api.core.ILinkableObject"
		   cacheAsBitmap="false"
		   clipContent="false"
		   autoLayout="false"
		   dragDrop ="dragDropHandler(event)"
		   dragEnter="dragEnterHandler(event)"
		>
	<mx:Glow id="selectedBorder" 
			 alphaFrom="1.0" alphaTo="1.0"   
			 blurXFrom="10.0" blurYFrom="10.0" 
			 blurXTo="10.0" blurYTo="10.0"
			 duration="0" target="{nodeBase}"/>
	<mx:Glow id="unselectedBorder" 
			 alphaFrom="0.0" alphaTo="1.0"   
			 blurXFrom="10.0" blurYFrom="10.0" 
			 blurXTo="10.0" blurYTo="10.0"
			 duration="0" target="{nodeBase}"/>	
	<mx:Script>
		<![CDATA[
			import flash.events.MouseEvent;
			import flash.geom.Point;
			import flash.net.URLRequest;
			import flash.net.navigateToURL;
			import flash.utils.Dictionary;
			
			import mx.collections.ArrayCollection;
			import mx.controls.Alert;
			import mx.controls.Image;
			import mx.controls.Label;
			import mx.controls.Text;
			import mx.controls.TextArea;
			import mx.core.IUIComponent;
			import mx.events.CloseEvent;
			import mx.events.DragEvent;
			import mx.events.FlexEvent;
			import mx.managers.CursorManager;
			import mx.managers.DragManager;
			import mx.managers.PopUpManager;
			import mx.managers.PopUpManagerChildList;
			import mx.rpc.events.FaultEvent;
			import mx.rpc.events.ResultEvent;
			
			import weave.Weave;
			import weave.api.WeaveAPI;
			import weave.api.core.ILinkableHashMap;
			import weave.api.core.ILinkableObject;
			import weave.api.data.IAttributeColumn;
			import weave.api.data.IQualifiedKey;
			import weave.api.detectLinkableObjectChange;
			import weave.api.disposeObjects;
			import weave.api.getCallbackCollection;
			import weave.api.getLinkableOwner;
			import weave.api.linkBindableProperty;
			import weave.api.linkSessionState;
			import weave.api.newLinkableChild;
			import weave.api.registerLinkableChild;
			import weave.core.LinkableDynamicObject;
			import weave.core.LinkableHashMap;
			import weave.core.LinkableNumber;
			import weave.core.LinkableString;
			import weave.core.SessionStateLog;
			import weave.core.StageUtils;
			import weave.core.UIUtils;
			import weave.core.weave_internal;
			import weave.data.AttributeColumns.ReferencedColumn;
			import weave.data.CSVParser;
			import weave.data.ColumnReferences.HierarchyColumnReference;
			import weave.data.DataSources.InfoMapsDataSource;
			import weave.data.KeySets.KeyFilter;
			import weave.data.KeySets.KeySet;
			import weave.data.QKeyManager;
			import weave.primitives.DateRangeFilter;
			import weave.ui.infomap.core.FilterableInfoMapNode;
			import weave.ui.infomap.core.InfoMapDocument;
			import weave.ui.infomap.core.InfoMapNode;
			import weave.ui.infomap.ui.DateFilterComponent;
			import weave.ui.infomap.ui.DocThumbnailComponent;
			import weave.ui.infomap.ui.InfoMapPanel;
			import weave.ui.infomap.ui.NodeBaseComponent;
			import weave.ui.infomap.ui.NodeSettingsComponent;
			import weave.utils.BitmapUtils;
			import weave.utils.ColumnUtils;
			import weave.utils.CustomCursorManager;
			import weave.utils.DateUtils;
			
			public const node:FilterableInfoMapNode = newLinkableChild(this,FilterableInfoMapNode);
			
			public const xPos:LinkableNumber = newLinkableChild(this,LinkableNumber);
			public const yPos:LinkableNumber = newLinkableChild(this,LinkableNumber);
			
			public const layout:LinkableDynamicObject = newLinkableChild(this,LinkableDynamicObject,handleLayoutChange,true);
			
			public const thumbnails:LinkableHashMap = newLinkableChild(this,LinkableHashMap);
			
			public const defaultBorderColor:LinkableNumber = registerLinkableChild(this,new LinkableNumber(13421772),highlightNode,true);
			
			public const selectedBorderColor:LinkableNumber = registerLinkableChild(this,new LinkableNumber(39168),highlightNode,true);
			
			public const defaultThumbnailBorderColor:LinkableNumber = registerLinkableChild(this,new LinkableNumber(000000));
			
			public const selectedThumbnailBorderColor:LinkableNumber = registerLinkableChild(this,new LinkableNumber(16711680));
			
			public const newThumbnailGlowColor:LinkableNumber = registerLinkableChild(this,new LinkableNumber(3407820));
			
			private var loader:URLLoader = null;
			
			//we override the x,y value because we are binding the values to LinkableNumber 
			//which could be NaN when component loads for the first time
			override public function set x(value:Number):void
			{
				if(parent)
					super.x = isNaN(value)?parent.width/2:value;
				else
					super.x=value
			}
			
			override public function set y(value:Number):void
			{
				if(parent)
					super.y = isNaN(value)?parent.height/2:value;
				else
					super.y=value
						
			}
			
			private var _parentPanel:InfoMapPanel;
			private var _subset:KeyFilter = Weave.root.getObject(Weave.DEFAULT_SUBSET_KEYFILTER) as KeyFilter;
			
			
			
			override protected function createChildren():void
			{

				super.createChildren();
				this.addChild(nodeBase);
			}
			
//			private var log:SessionStateLog = new SessionStateLog(thumbnails);
			
			override protected function childrenCreated():void
			{
				
								
				super.childrenCreated();
								
				node.keywords.addGroupedCallback(this,createAndSendQuery);
				node.operator.addGroupedCallback(this,createAndSendQuery);
				node.numberOfDocs.addGroupedCallback(this,createAndSendQuery);
				node.dateFilter.startDate.addGroupedCallback(this,createAndSendQuery);
				node.dateFilter.endDate.addGroupedCallback(this,createAndSendQuery);
				node.sources.addGroupedCallback(this,createAndSendQuery);
				
				//if node is selected we highlight the nodeBase
				node.selected.addGroupedCallback(this,highlightNode);
				
				//for now defaulting to Grid Layout
				if(layout.internalObject == null)
					layout.requestLocalObject(GridLayout,false);
				(layout.internalObject as IInfoMapNodeLayout).parentNodeHandler = this;
				
				//opens the settings panel
				nodeBase.settingsImg.addEventListener(MouseEvent.CLICK,settings);
				
				//removes the node from the panel after confirmation
				nodeBase.closeImg.addEventListener(MouseEvent.CLICK,close);
				
				//drag and drop of the node will be use the text area as the handler/anchor point
				nodeBase.keywordTextArea.addEventListener(MouseEvent.MOUSE_DOWN,canvas1_mouseDownHandler);
				nodeBase.keywordTextArea.addEventListener(MouseEvent.MOUSE_UP,canvas1_mouseUpHandler);
				
				//drawing the base which is the node with keywords and icons
				(layout.internalObject as IInfoMapNodeLayout).drawBaseLayout(graphics);
				
				//sessioning the x and y positions of this node
				linkBindableProperty(xPos,this,"x");
				linkBindableProperty(yPos,this,"y");
				
				//sets a pointer to the node's parent which is an InfoMapPanel
				var hashmap:LinkableHashMap = WeaveAPI.SessionManager.getLinkableOwner(this) as LinkableHashMap;
				_parentPanel = WeaveAPI.SessionManager.getLinkableOwner(hashmap) as InfoMapPanel;
				
				//adding a callback to the Global Search keyword. This will set the visibility of the thumbnails to true or false
				//based on keyword match
				_parentPanel.globalSearchKeyword.addImmediateCallback(this,handleGlobalSearch);
				
				//adding a callback to the Global Date Filter
				//TODO: needs to be tested
				_parentPanel.globalDateFilter.startDate.addGroupedCallback(this,handleGlobalDateChange);
				_parentPanel.globalDateFilter.endDate.addGroupedCallback(this,handleGlobalDateChange);
				
				//adding listener to Click event to toggle node selection
				nodeBase.keywordTextArea.addEventListener(MouseEvent.CLICK,handleClick);
				
				//adding callback to subset. Thumbnails will be re-drawn to plot only included thumbnails
				getCallbackCollection(_subset).addGroupedCallback(this,drawThumbnails);
				
				//calling function to highlight the node based on node.selected.value
				highlightNode();
				
				//we want to trigger the callback for thumbnails at each frame and check the trigger counter
				getCallbackCollection(this).addImmediateCallback(this,invalidateDisplayList);
				
				createAndSendQuery(false);
				
				//the set of keys matching the query is stored in docKeyset. 
				//when the results are stored in this keySet a callback is triggered for parsing the results
				docKeySet.addGroupedCallback(this,handleQueryResultKeySet,true);
				
				//this keySet stores the keys matching the search query.
				//when the results are stored in this keySet a callback is triggered for setting the thumbnails' visible to true/false
				_searchKeySet.addGroupedCallback(this,handleSearchKeySetChange,true);
				
				//adding a callback to the selection KeySet to highlight/unhighlight documents
				_selection.addGroupedCallback(this,handleSelectionKeySetChange,true);
				
			}
			
			private function dragEnterHandler(event:DragEvent):void
			{
				 
				if(event.dragInitiator is DocThumbnailComponent)
				{
					DragManager.acceptDragDrop(this);
				}
			}
			
			private function dragDropHandler(event:DragEvent):void
			{
				var t:DocThumbnailComponent = event.dragInitiator as DocThumbnailComponent;
				
				if(!(t.parent == this))
				{
					addChild(t);
					
					//setting the X and Y with reference to the map
//					var tGlobalPoint2:Point = _parentPanel.map.contentToGlobal(new Point(event.stageX,event.stageY));
					var localPoint2:Point =  this.globalToLocal(new Point(event.stageX,event.stageY));
					
					t.move(localPoint2.x,localPoint2.y);
				}
			}
			
			/**
			 * This function adds the thumbnail as a child to the map and resets its position values with respect to the panel
			 * The thumbnail won't move when the node is moved.
			 * @param t The Thumbnail to add to the map
			 **/
//			private function addThumbnailToMap(t:DocThumbnailComponent):void
//			{
//				if(t.hasBeenMoved.value)
//				{
//					if(t.parent == _parentPanel.map)
//						return;
//					
//					_parentPanel.map.addChild(t);
//					
//					//setting the X and Y with reference to the map
//					var tGlobalPoint:Point = this.contentToGlobal(new Point(t.xPos.value,t.yPos.value));
//					var localPoint:Point = _parentPanel.map.globalToLocal(tGlobalPoint);
//					
//					t.move(localPoint.x,localPoint.y);
//					
//				}else{
//					
//					if(t.parent == this)
//						return;
//					
//					addChild(t);
//					
//					//setting the X and Y with reference to the map
//					var tGlobalPoint2:Point = _parentPanel.map.contentToGlobal(new Point(t.xPos.value,t.yPos.value));
//					var localPoint2:Point =  this.globalToLocal(tGlobalPoint2);
//					
//					t.move(localPoint2.x,localPoint2.y);
//					
//				}
//			}
			
			//this variable is false when the user loads the map for the first time. 			
			private var highlightNewDocuments:Boolean = false;
			public function checkForNewDocuments():void
			{
//				highlightNewDocuments = true;
				createAndSendQuery(false);
			}
		
				
			[Bindable]
			public var nodeBase:NodeBaseComponent = new NodeBaseComponent();
			
			private var docKeySet:KeySet = new KeySet();
			
			/**
			 * @private
			 * This functions creates a query based on the keywords,operator and filters applied and sends a request to the Solr server
			 **/
			private function createAndSendQuery(clearDocuments:Boolean=true):void
			{
				if(!node.keywords.value)
					return;
				
				if(clearDocuments)
					thumbnails.removeAllObjects();
				
				nodeBase.keywordTextArea.text = node.keywords.value;
				nodeBase.keywordTextArea.toolTip = node.keywords.value;
				
				if (this.parent == null)
				{
					WeaveAPI.StageUtils.callLater(this,createAndSendQuery,[clearDocuments]);
					return;
				}
				
				if(!node.sources.value == '')
				{
					var sourceNames:Array = parser.parseCSV(node.sources.value)[0]; //we send only the first row since this is a one-line CSV String
				}
				
				_parentPanel.infoMapsDataSource.getDocumentsForQuery(docKeySet,node.keywords.value,node.operator.value,sourceNames,node.dateFilter);
				
			}
			
			private var parser:CSVParser = new CSVParser();
			
			/**
			 * @private
			 * This function takes an array collection of links and requests a thumbnail object to display the document object
			 * for each of the corresponding links.
			 * If the thumbnail object is already there then we use the replace its doc object with the latest doc object. 
			 **/
			private function handleQueryResultKeySet():void
			{
				if(thumbnails.getObjects().length == 0)
				{
					highlightNewDocuments = false;
				}else{
					highlightNewDocuments = true;
				}
				thumbnails.delayCallbacks();
				var response:Array = docKeySet.keys;
				var nameOrder:Array = [];
				for(var i:int; i<response.length ;i++)
				{
					
					var link:String = (response[i] as IQualifiedKey).localName;					
					nameOrder.push(link);
					var thumbnail:DocThumbnailComponent = new DocThumbnailComponent();
					
					
					//if the thumbnail already exists use that
					if(thumbnails.getObject(link))
					{
						thumbnail = thumbnails.requestObject(link,DocThumbnailComponent,false);
						
						linkSessionState(defaultThumbnailBorderColor,thumbnail.defaultBorderColor);
						linkSessionState(selectedThumbnailBorderColor,thumbnail.selectedBorderColor);
						linkSessionState(newThumbnailGlowColor,thumbnail.glowColor);
//						thumbnail.hasBeenMoved.addImmediateCallback(this,function ():void{addThumbnailToMap(thumbnail);});
						addChild(thumbnail);
						continue;
					}
					
					thumbnail = thumbnails.requestObject(link,DocThumbnailComponent,false);
										
					thumbnail.docURL.value = link;
					
					linkSessionState(defaultThumbnailBorderColor,thumbnail.defaultBorderColor);
					linkSessionState(selectedThumbnailBorderColor,thumbnail.selectedBorderColor);
					linkSessionState(newThumbnailGlowColor,thumbnail.glowColor);
//					thumbnail.hasBeenMoved.addImmediateCallback(this,function ():void{addThumbnailToMap(thumbnail);});
					addChild(thumbnail);
					
					if(highlightNewDocuments)
					{
						thumbnail.startGlow();
					}
					
				}
				thumbnails.setNameOrder(nameOrder);
				thumbnails.resumeCallbacks();			
				drawThumbnails();
			}
			
			override public function validateDisplayList():void
			{
				super.validateDisplayList();
//				This was added before using InfoMapsDataSource. This might not be needed
//				TODO: delete later if not required
				if(detectLinkableObjectChange(validateDisplayList,thumbnails))
					drawThumbnails();
				
			}
			
			private var thumbnailsToPlotArray:Array = [];
			
			/**
			 * This function goes through the list of thumbnails and adds the ones included in the subset to an array.
			 * This array is then sent to a Layout Algorithm to plot the thumbnails. 
			 * After the thumbnails are plotted we call the functions to highlight selected documents and set visiblity based on search keywords.
			 **/
			private function drawThumbnails():void
			{
				thumbnailsToPlotArray = [];
				var tNails:Array = thumbnails.getObjects()

				for (var i:int = 0; i<tNails.length; i++)
				{
					var t:DocThumbnailComponent = tNails[i];
					var docURL:String = thumbnails.getName(t);
					var qKey:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,docURL);
					if(_subset.containsKey(qKey))
					{
						thumbnailsToPlotArray.push(t);
						t.visible = true;
					}else{
						
						t.visible = false;
					}
					
				}
				(layout.internalObject as IInfoMapNodeLayout).plotThumbnails(thumbnailsToPlotArray);
				handleSelectionKeySetChange();
				handleGlobalSearch();
			}
			
			private var _selection:KeySet = Weave.root.getObject(Weave.DEFAULT_SELECTION_KEYSET) as KeySet;
			/**
			 * Highlights selected documents
			 **/
			private function handleSelectionKeySetChange():void
			{
				var docs:Array = thumbnails.getNames();
				
				for each(var doc:String in docs)
				{
					var qKey:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,doc);
					var t:DocThumbnailComponent = thumbnails.getObject(doc) as DocThumbnailComponent;
					var selected:Boolean =_selection.containsKey(qKey) 
					t.highlight(selected);
				}
			}
			
			/**
			 * redraw thumbnails to handle new layout selection
			 **/
			private function handleLayoutChange():void
			{
				if(layout.internalObject == null)
					return;
				(layout.internalObject as IInfoMapNodeLayout).parentNodeHandler = this;
				(layout.internalObject as IInfoMapNodeLayout).drawBaseLayout(graphics);
				(layout.internalObject as IInfoMapNodeLayout).plotThumbnails(thumbnailsToPlotArray,true);
			}
			
			
			private var _searchKeySet:KeySet = new KeySet();
			//sends a query to solr for the search keywords filtrered by document links belonging to this node
			private function handleGlobalSearch():void
			{
				
				if(!_parentPanel.globalSearchKeyword.value)
				{
					_searchKeySet.clearKeys();
					return;
				}
				
				var fieldNames:Array = ['link'];
				
				var fieldValues:Array = [];
				
				fieldValues.push(thumbnails.getNames());
				
				if(!node.sources.value == '')
				{
					var sourceNames:Array = parser.parseCSV(node.sources.value)[0]; //we send only the first row since this is a one-line CSV String
				}
				
				
				_parentPanel.infoMapsDataSource.getDocumentsForQueryWithFieldValues(_searchKeySet,_parentPanel.globalSearchKeyword.value,fieldNames,fieldValues,sourceNames,"OR",node.dateFilter);
				
			}
			
			//this function is called when the _searchKeySet is set. 
			//This sets the thumbnail's visiblity based if its link is included or excluded in the _searchKeySet
			private function handleSearchKeySetChange():void
			{
				var tnails:Array = thumbnails.getObjects();
				
				var searchMatchedKeys:Array =_searchKeySet.keys; 
				
				if(searchMatchedKeys.length == 0)
				{
					for each(var t1:DocThumbnailComponent in tnails)
					{
						t1.visible = true;
					}
				}else
				{
					for each(var t2:DocThumbnailComponent in tnails)
					{
						t2.visible = false;
					}
				}
				
				for each(var k:IQualifiedKey in searchMatchedKeys)
				{
					var t3:DocThumbnailComponent = thumbnails.getObject(k.localName) as DocThumbnailComponent;
					
					if(t3)
						t3.visible = true;
				}
				
			}
			
			private function handleGlobalDateChange():void
			{
				if(node.selected.value)
				{
					node.dateFilter.startDate.value = _parentPanel.globalDateFilter.startDate.value;
					node.dateFilter.endDate.value = _parentPanel.globalDateFilter.endDate.value;
				}
			}
			private function removeEmptyStringElementsFromArray(arg:Array):Array
			{
				var result:Array = [];
				for each(var item:String in arg)
				{
					if(item != "")
						result.push(item);
				}
				
				return result;
			}
			
			//toggle node selection on click
			private function handleClick(event:Event):void
			{
				if(wasDragged)
				{
					wasDragged = false;
					return;
				}
				if(node.selected.value)
					node.selected.value = false;
				else
					node.selected.value = true;
			}
			
			//highlight node based on node.selected.value
			private function highlightNode():void
			{
				unselectedBorder.color = defaultBorderColor.value;
				selectedBorder.color = selectedBorderColor.value;
				
				if(node.selected.value)
					selectedBorder.play();
				else
					unselectedBorder.play();
			}
			
			//this variable will be  used to avoid selection/unselection when the node is dragged
			private var wasDragged:Boolean = false;
			protected function canvas1_mouseDownHandler(event:MouseEvent):void
			{
				event.stopImmediatePropagation();
				nodeBase.keywordTextArea.setStyle("fontWeight","bold");
				CustomCursorManager.showCursor(CustomCursorManager.HAND_GRAB_CURSOR);
				this.startDrag();
				this.addEventListener(MouseEvent.MOUSE_MOVE,handleMouseMove);
			}
			
			private function handleMouseMove(event:Event):void
			{
				wasDragged = true;
			}
			
			protected function canvas1_mouseUpHandler(event:MouseEvent):void
			{
				nodeBase.keywordTextArea.setStyle("fontWeight","normal");
				CustomCursorManager.removeCurrentCursor();
				this.stopDrag();
				this.removeEventListener(MouseEvent.MOUSE_MOVE,handleMouseMove);
			}
			
			private function filter(event:Event):void
			{
				DateFilterComponent.openInstance(this,node.dateFilter);
			}
			
			private var _instance:NodeSettingsComponent = null;
			private function settings(event:Event):void
			{
				
				if(_instance)
				{
					PopUpManager.addPopUp(_instance,this);
				}
				else
				{
					_instance = new NodeSettingsComponent();
					_instance.nodeHandler = this;
					PopUpManager.addPopUp(_instance,this);
				}
			}
			
			private function close(event:Event):void
			{
				Alert.show("Are you sure you want to remove this node?",
					"Remove Node?",
					Alert.YES | Alert.NO,
					null,
					handleCloseEvent
				);
			}
			
			private function handleCloseEvent(e:CloseEvent):void
			{
				if(e.detail == Alert.YES)
				{
					thumbnails.removeAllObjects();
					var parent:ILinkableHashMap = (WeaveAPI.SessionManager.getLinkableOwner(this) as ILinkableHashMap);
					var nodeName:String  = parent.getName(this);
					parent.removeObject(nodeName);
				}
				else if(e.detail == Alert.NO)
				{
					return;
				}
			}			
			
			
		]]>
	</mx:Script>
	
</mx:Canvas>
