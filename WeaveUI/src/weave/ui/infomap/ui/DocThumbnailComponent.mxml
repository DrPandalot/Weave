<?xml version="1.0" encoding="utf-8"?>
<!--This is a Flex Image component modified to adjust to act as a thumbnail for infomap
so that it can be moved, selected, handle filters.
-->
<mx:HBox xmlns:mx="http://www.adobe.com/2006/mxml"
	   			paddingBottom="2"
				paddingLeft="2"
				paddingRight="2"
				paddingTop="2"
				implements="weave.api.core.ILinkableObject"
				doubleClickEnabled="true"
				doubleClick="handleDoubleClick(event)"
				mouseDown="handleMouseDown()"
				mouseUp="handleMouseUp(event)"
				mouseOver="handleMouseOver(event)"
				mouseOut="handleMouseOut()"
				borderStyle="solid"
				borderThickness="0.5"
				cornerRadius="5"
				borderColor="black"
				>
	<mx:Image id="img" width="100%" height="100%"/>
	<mx:Script>
		<![CDATA[
			import flash.text.engine.GroupElement;
			
			import mx.events.DragEvent;
			import mx.events.MoveEvent;
			import mx.managers.IFocusManagerComponent;
			import mx.managers.PopUpManager;
			import mx.rpc.events.FaultEvent;
			import mx.rpc.events.ResultEvent;
			
			import weave.Weave;
			import weave.api.WeaveAPI;
			import weave.api.core.ILinkableHashMap;
			import weave.api.core.ILinkableObject;
			import weave.api.data.IQualifiedKey;
			import weave.api.getCallbackCollection;
			import weave.api.linkBindableProperty;
			import weave.api.newLinkableChild;
			import weave.api.registerLinkableChild;
			import weave.api.reportError;
			import weave.api.services.IURLRequestToken;
			import weave.core.LinkableBoolean;
			import weave.core.LinkableDisplayObject;
			import weave.core.LinkableHashMap;
			import weave.core.LinkableNumber;
			import weave.core.LinkableString;
			import weave.core.SessionManager;
			import weave.data.KeySets.KeySet;
			import weave.services.URLRequestUtils;
			import weave.ui.infomap.core.DateRangeFilter;
			import weave.ui.infomap.core.FilterableInfoMapNode;
			import weave.ui.infomap.core.IInfoMapNode;
			import weave.ui.infomap.core.SelectableInfoMapDocument;
			import weave.ui.infomap.layout.IInfoMapNodeLayout;
			import weave.ui.infomap.layout.NodeHandler;
			import weave.ui.infomap.utils.DateUtils;
			import weave.utils.BitmapUtils;
			import weave.utils.CustomCursorManager;
			
			/**
			 * @public
			 * This variable sets the width of this image.
			 * */
			public const imageWidth:LinkableNumber = registerLinkableChild(this,new LinkableNumber(),handleImage,true);
			/**
			 * @public
			 * This variable sets the height of this image.
			 * */
			public const imageHeight:LinkableNumber = registerLinkableChild(this,new LinkableNumber(),handleImage,true);
			/**
			 * @public
			 * This variable sets the alpha/transparency of this image.
			 * */
			public const imageAlpha:LinkableNumber = registerLinkableChild(this,new LinkableNumber(1.0));
			/**
			 * @public
			 * This variable sets default border color of this image when it is not selected. Not currently Used.
			 * */
			public const defaultBorderColor:LinkableNumber = registerLinkableChild(this,new LinkableNumber(00000000));
			/**
			 * @public
			 * This variable sets the color of the border of this image when the document is selected.
			 * */
			public const selectedBorderColor:LinkableNumber = registerLinkableChild(this,new LinkableNumber(16711680));
			/**
			 * @public
			 * This variable sets the color of the glow filter for highlighting new documents.
			 * */
			public const glowColor:LinkableNumber = registerLinkableChild(this,new LinkableNumber());
			/**
			 * @public
			 * This variable sets the thickness of the border of this image.
			 * */
			public const borderThickness:LinkableNumber = newLinkableChild(this,LinkableNumber);
			/**
			 * @public
			 * This variable sets the x position of this image.
			 * */
			public const xPos:LinkableNumber = newLinkableChild(this,LinkableNumber);
			/**
			 * @public
			 * This variable sets the y position of this image.
			 * */
			public const yPos:LinkableNumber = newLinkableChild(this,LinkableNumber);
			
			/**
			 * @public
			 * This variable is set when the thumbnail is moved.
			 * This helps an IInfoMapNodeLayout to decide if it 
			 * needs to re-compute the position of this image.
			 * */
			public const hasBeenMoved:LinkableBoolean = registerLinkableChild(this,new LinkableBoolean(false));
			
			/**
			 * @private
			 * The document object whose imageURL is used as the source for this image.
			 * */
			private var _doc:SelectableInfoMapDocument;
			private var _key:IQualifiedKey;
			public function set doc(value:SelectableInfoMapDocument):void
			{
				_doc = value;
				_doc.selected.addImmediateCallback(this,highlight);
				_key = WeaveAPI.QKeyManager.getQKey("infomapDocURL",_doc.url.value);
				handleImage();
			}
			
			public function get doc():SelectableInfoMapDocument
			{
				return _doc;
			}
			
			override protected function childrenCreated():void
			{
				super.childrenCreated();
				linkBindableProperty(imageWidth,this,"width");
				linkBindableProperty(imageHeight,this,"height");	
				linkBindableProperty(imageAlpha,this,"alpha");
				
				linkBindableProperty(xPos,this,"x");
				linkBindableProperty(yPos,this,"y");
				
				selectedBorderColor.addGroupedCallback(this,highlight);
				defaultBorderColor.addGroupedCallback(this,highlight);
				
				var filterableNode:FilterableInfoMapNode = (this.parent as NodeHandler).node as FilterableInfoMapNode;
				//adding callback for a search query made in the node handler this belongs to
				(this.parent as NodeHandler).searchFilter.addImmediateCallback(this,handleLocalSearchFilter,null,true);
//				(this.parent as NodeHandler).defaultThumbnailBorderColor.addImmediateCallback(this,handleDefaultBorderColorChange,null,true);
//				(this.parent as NodeHandler).selectedThumbnailBorderColor.addImmediateCallback(this,handleSelectedBorderColorChange,null,true);
//				getCallbackCollection(_selection).addImmediateCallback(this, highlight);
				
			}
			
			
			//this function is called when a local search is made in the node handler this belongs to.
			//if a match for the search query is not found in the doc object, it makes the image invisible
			private function handleLocalSearchFilter():void
			{
				if(_doc == null)
					return;
				
				var searchKey:String = (this.parent as NodeHandler).searchFilter.value;
				if(searchKey == "" || searchKey == null)
				{
					_selection.removeKeys([_key]);
					doc.selected.value = false;
					return;
				}
				
				if(_doc.title.value.toLowerCase().search(searchKey.toLowerCase()) == -1)
					if(_doc.summary.value.toLowerCase().search(searchKey.toLowerCase()) == -1)
					{
						_selection.removeKeys([_key]);
						doc.selected.value = false;
						return;
					}
				
				_selection.addKeys([_key]);
				doc.selected.value = true;
				
			}
			
			private var _dateFilterObject:DateRangeFilter;
			private function handleDateFilter():void
			{
				
				if(_dateFilterObject.startDate == null || _dateFilterObject.endDate == null)
				{
					this.visible = true;
					return;
				}
				
				
				//if date is empty we do nothing. May change later
				if(_doc.date.value == "")
				{
					this.visible = true;
					return;	
				}
				
				var s:String = _dateFilterObject.startDate.value;
				var e:String = _dateFilterObject.endDate.value;
				var d:String =_doc.date.value;
				
				//if either the start date or the end date is not set, do nothing. Sets the image back to visible
				if(s == '' || s == null || e =='' || e == null)
				{
					this.visible = true;					
					return;
				}
				
				//if date of doc object is within the range set visibility to true else to false
				this.visible = DateUtils.isDateStringWithinRange(d,s,e);
				
				
			}
			
			private var token:IURLRequestToken;
			
			private function handleImage():void
			{
				//temporary fix. Fault event is not called when thumbnail is not found.
				if(!parent)
				{
					return callLater(handleImage);
				}
				
				img.source = _noImage;
				token = WeaveAPI.URLRequestUtils.getContent(new URLRequest(_doc.imageURL.value),handleImageRequest,handleImageFaultRequest);
			}
			
			public function dispose():void
			{
				//if this image is disposed, then we cancel the image content request
				if(token)
					token.cancelRequest();
			}
			
			//There is no option to add borders to a Flex Image Component. As a workaround, we override the updateDisplayList,
			//so if the doc object is selected we draw a rectangle around the image to act as border.
			//Solution from :http://www.flexer.info/2008/06/10/how-to-make-an-image-with-border/
			override protected function updateDisplayList(unscaledWidth:Number, unscaledHeight:Number):void
			{
				super.updateDisplayList(unscaledWidth,unscaledHeight);
			}
			
			private function handleImageRequest(event:ResultEvent,token:Object=null):void
			{
				if((WeaveAPI.SessionManager as SessionManager).objectWasDisposed(this))
					return;
				try{
					if(isFinite(imageHeight.value) && isFinite(imageWidth.value))
						img.source = new Bitmap(BitmapUtils.resizeBitmapData((event.result as Bitmap).bitmapData,imageWidth.value,imageHeight.value));
				}catch(e:Error){
					reportError(e);
				}
			}
			
			[Embed(source='/weave/resources/images/no-image.gif')]
			private var _noImage:Class;
			private function handleImageFaultRequest(event:FaultEvent,token:Object=null):void
			{
				if((WeaveAPI.SessionManager as SessionManager).objectWasDisposed(this))
					return;
				img.source = _noImage;
			}
			
			private var _mouseOver:Boolean = false;
			private function handleMouseOver(event:MouseEvent):void
			{
				_mouseOver = true;
				if(!event.buttonDown)
				{
					setStyle("borderStyle","none");
//					this.invalidateDisplayList();
					showDocSummary(event);
				}
			}
			
			
			
			private function handleDoubleClick(event:Event):void
			{
				if(_doc.url.value == "")
					return;
				var link:String = _doc.url.value;
				var linkLen:int = link.length;
				var linkExtension:String = link.substring(linkLen-3,linkLen);
				if(linkExtension == "pdf")
				{
					link = "http://129.63.8.219:8080/"+link.substring(link.indexOf("infomap"),linkLen);
				}
				else{
					link = _doc.url.value;
				}
				navigateToURL(new URLRequest(link));
			}
			
			private var dragged:Boolean = false;
			private var _mouseDown:Boolean = false;
			private function handleMouseDown():void
			{
				filters = [];
				timer.stop();
				this.startDrag();
				removeDocSummary();
				_mouseDown = true;
				this.addEventListener(MouseEvent.MOUSE_MOVE,handleMouseMove);
			}
			
			private function handleMouseMove(event:MouseEvent):void
			{
				dragged = true;	
				hasBeenMoved.value = true;
				stage.addEventListener(MouseEvent.MOUSE_UP,handleStageMouseUp);
			}
			
			private function handleStageMouseUp(event:MouseEvent):void
			{
				if(_mouseDown)
				{
					stage.removeEventListener(MouseEvent.MOUSE_UP,handleStageMouseUp);
					handleMouseUp();
				}
			}
			private var _selection:KeySet = Weave.root.getObject(Weave.DEFAULT_SELECTION_KEYSET) as KeySet;
			private function handleMouseUp(event:MouseEvent=null):void
			{
				//if the mouse is not down on this do nothing
				if(!_mouseDown)
					return;
				
				_mouseDown = false;
				this.stopDrag();
				this.removeEventListener(MouseEvent.MOUSE_MOVE,handleMouseMove);
				
//				this.invalidateDisplayList();
				//if it is drag move then we do nothing, else the mouseUp is a selection
				if(dragged)
				{
					dragged = false;
					return;
				}

				toggleSelection();
				
				setStyle("borderStyle","solid");
				
				removeDocSummary();
				
			}
			
			private function toggleSelection():void
			{
				
				//toggling selection
				if(_doc.selected.value)
				{
					_selection.removeKeys([_key]);
					_doc.selected.value = false;
				}
				else
				{
					_selection.addKeys([_key]);
					_doc.selected.value = true;
				}
			}
			
			
			private function handleMouseOut():void
			{
				_mouseOver = false;
				
				//fix for buggy drag-drop
				this.removeEventListener(MouseEvent.MOUSE_MOVE,handleMouseMove);
				
				setStyle("borderStyle","solid");
//				this.invalidateDisplayList();
				
				removeDocSummary();
			}

			private	var docPreview:DocumentSummaryComponent;
			private function showDocSummary(event:MouseEvent):void
			{
				DocumentSummaryComponent.show(event.stageX,event.stageY,_doc,this);
				
			}
			
			private function removeDocSummary(event:Event=null):void
			{
				DocumentSummaryComponent.hide();
			}
			
			private function highlight():void
			{
				if(_doc == null)
					return;
				if(_selection.keys.length == 0)
				{
					imageAlpha.value = 1.0;
					setStyle("borderColor",defaultBorderColor.value);
				} else if(_doc.selected.value)
				{
					imageAlpha.value = 1.0;
					setStyle("borderColor",selectedBorderColor.value);
				}
				else
				{
					imageAlpha.value = 0.3;
					setStyle("borderColor",defaultBorderColor.value);
				}
				//this will force a call to the updateDisplayList which will draw a border around this image
				this.invalidateDisplayList();
			}
			
			private var glowFilter:GlowFilter = new GlowFilter(glowColor.value);
			private var timer:Timer = new Timer(125);
			public function startGlow():void
			{
				filters = [glowFilter];
				timer.addEventListener(TimerEvent.TIMER,changeGlow);
				timer.start();
			}
			
			
			private function changeGlow(event:TimerEvent):void
			{
				glowFilter.alpha = 0.125 + (event.target.currentCount % 8) *0.125;
				glowFilter.color = glowColor.value;
				filters=[glowFilter];
			}
		]]>
	</mx:Script>
	
	<!--<mx:Image id="img"/>-->
</mx:HBox>

				