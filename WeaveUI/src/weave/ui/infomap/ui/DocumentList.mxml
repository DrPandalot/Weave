<?xml version="1.0" encoding="utf-8"?>
<!--This component is used for handling node operations.
It has a text area which diplays the keywords.
It has 4 icons to:
Close/Delete the node
Edit the keyword
Search within the node.
Filter by Date
Info to provide a tooltip describing the node (like number of documents found)

-->
<mx:VBox implements="weave.api.core.ILinkableObject" xmlns:mx="http://www.adobe.com/2006/mxml"
		 horizontalScrollPolicy="off" verticalScrollPolicy="off"
		width="100%" xmlns:ui="weave.ui.infomap.ui.*" clipContent="false" >
	<mx:HBox id="filterStatus" width="100%"/>
	<mx:Canvas id="view" width="100%" height="100%">
		<mx:List allowMultipleSelection="true"
			doubleClickEnabled="true" mouseDown="handleMouseDown(event)" mouseMove="handleMouseMove(event)" toolTip="" 
			dragEnabled="true" id="docList" width="100%" dragComplete="handleItemDragComplete(event)">
			<mx:itemRenderer>
				<mx:Component>
					<!--Setting the tool tip to empty so that you can only see the Document Summary Component on mouse over.
					Setting it to null does not work.-->
					<ui:CustomLabelTextField doubleClick="handleItemDoubleClick(event)" rollOut="handleItemRollOut(event)" rollOver="handleItemRollOver(event)" 
											 toolTip="" width="100%"> 
						<mx:Script>
							<![CDATA[
								import com.modestmaps.core.Coordinate;
								
								import mx.controls.ColorPicker;
								import mx.core.UITextField;
								import mx.core.mx_internal;
								import mx.events.DragEvent;
								import mx.managers.CursorManager;
								
								import weave.api.WeaveAPI;
								import weave.core.StageUtils;
								import weave.data.DataSources.InfoMapsDataSource;
								import weave.ui.infomap.layout.NodeHandler;
								import weave.utils.CustomCursorManager;
								import weave.visualization.layers.InteractiveVisualization;
								
								private var infomapDataSource:InfoMapsDataSource = WeaveAPI.globalHashMap.getObject(InfoMapsDataSource.SOURCE_NAME) as InfoMapsDataSource;
								
								override protected function childrenCreated():void
								{
									infomapDataSource.getColumnByName("title").addImmediateCallback(outerDocument,updateLabelText);
								}
								
								private var _mouseDown:Boolean = false;
								
								private var stageUtils:StageUtils = new StageUtils();
								
								
								
								override public function set data(value:Object):void
								{
									super.data = value;
									if(value == null || outerDocument.parentNode == null)
										return;
									
									var t:DocThumbnailComponent = (outerDocument.parentNode).thumbnails.getObject(value.localName) as DocThumbnailComponent;
									
									//changing background color if document is new/highlighted
									t.highlighted.addImmediateCallback(this,changeBackgroundColor,true);
									
									//removing highlighted background color if any when user clicks on the list item
									this.addEventListener(MouseEvent.CLICK,handleMouseClick);
									
									this.text = infomapDataSource.getTitleForURL(t.docURL.value);
								}
								
								private function changeBackgroundColor():void
								{
									var t:DocThumbnailComponent = (outerDocument.parentNode).thumbnails.getObject(data.localName) as DocThumbnailComponent;
									if((t as DocThumbnailComponent).highlighted.value && (outerDocument.parent.parent) is NodeHandler)
									{
										(this as CustomLabelTextField).getTextField().background = true;
										(this as CustomLabelTextField).getTextField().backgroundColor = 10092492;
											//TODO:Change this to use sessioned color
	//										(outerDocument.parent.parent.parent.parent as InfoMapPanel).newThumbnailGlowColor.value;
	//									(this as CustomLabelTextField).validateDisplayList();
									}else{
										//the item renderer will retain the background and only replace the content for the rows. 
										//So it is necessary to clear the background color 
										(this as CustomLabelTextField).getTextField().background = false;		
									}
								}
								
								private var cursorID:int = -1;
								private function handleItemRollOver(event:MouseEvent):void
								{
									cursorID = CustomCursorManager.showCursor(InteractiveVisualization.CURSOR_LINK);
									
									if(!stageUtils.mouseButtonDown)
										DocumentSummaryComponent.show(stage.mouseX,stage.mouseY,data.localName,event.currentTarget as DisplayObject,(outerDocument.parentNode));
								}
								private function handleItemRollOut(event:MouseEvent):void
								{
									CustomCursorManager.removeCursor(cursorID);
									DocumentSummaryComponent.hide();
								}
								private function handleItemDoubleClick(event:MouseEvent):void
								{
									var link:String = data.localName;
									navigateToURL(new URLRequest(link));
								}
								
								//remove background color if any because of new document highlighting
								private function handleMouseClick(event:MouseEvent):void
								{
									(this as CustomLabelTextField).getTextField().background = false;
								}
								
								private function updateLabelText():void
								{
									//the list was blinking because the label used to be set from empty to the text again because
									//the column is busy still getting the data
									//so we test it to only update the labels when it has the data. 
									if(WeaveAPI.SessionManager.linkableObjectIsBusy(infomapDataSource.getColumnByName("title")))
										return;
									if(data != null)
										this.text = infomapDataSource.getTitleForURL(data.localName);
								}
							]]>
						</mx:Script>
					</ui:CustomLabelTextField>
				</mx:Component>
			</mx:itemRenderer>
		</mx:List>
	</mx:Canvas>
	<mx:HBox id="navBox" horizontalScrollPolicy="off" clipContent="false" horizontalAlign="center" verticalAlign="middle">
		<mx:Image buttonMode="true" source="@Embed(source='/weave/resources/images/arrowLeft.png')"  id="prevButton" toolTip="Prev" click="prev()"/>
		<mx:Label id="indexText" textAlign="center"/>
		<mx:Image buttonMode="true" source="@Embed(source='/weave/resources/images/arrowRight.png')"  id="nextButton" toolTip="Next" click="next()"/>
	</mx:HBox>
	
	<mx:Script>
		<![CDATA[
			import flash.utils.getTimer;
			import weave.data.KeySets.KeySet;
			import weave.data.KeySets.FilteredKeySet;
			import mx.controls.listClasses.IListItemRenderer;
			import mx.core.mx_internal;
			import weave.visualization.layers.InteractiveVisualization;
			import weave.utils.CustomCursorManager;
			import weave.core.StageUtils;
			import mx.events.ListEvent;
			import weave.compiler.StandardLib;
			import mx.collections.ArrayCollection;
			import weave.ui.infomap.layout.NodeHandler;
			import weave.data.DataSources.InfoMapsDataSource;
			import weave.api.WeaveAPI;
			import weave.api.data.IQualifiedKey;
			import weave.api.getCallbackCollection;
			import weave.Weave;
			import weave.data.KeySets.KeyFilter;
			import mx.core.DragSource;
			import mx.managers.DragManager;
			import mx.events.DragEvent;
			import weave.utils.VectorUtils;
			import org.igniterealtime.xiff.events.OutgoingDataEvent;
			import weave.api.newLinkableChild;
			import weave.core.LinkableNumber;
			import weave.core.LinkableString;
			
			override protected function childrenCreated():void
			{
				super.childrenCreated();
				startIndex.addGroupedCallback(this,updateList,true);
			}
			
			public static var SELECTION_TEXT:String = "SELECTION";
			public var parentNode:NodeHandler = null;
			
			private var _filters:KeyFilter = new KeyFilter();
			private var _filteredKeySet:FilteredKeySet = new FilteredKeySet();
			
			public function set keys(value:Array):void
			{
				var k:KeySet = new KeySet();
				k.replaceKeys(value);
				_filteredKeySet.setSingleKeySource(k);
				_filters = (_filteredKeySet.keyFilter).requestLocalObject(KeyFilter,false);
				startIndex.value = 0;
				startIndex.triggerCallbacks();
			}
			
			public function applyFilter(name:String,keys:Array):void
			{
				var f:KeyFilter = _filters.filters.getObject(name) as KeyFilter;
				if(f)
				{
					f.replaceKeys(false,true,keys);
				}
				else
				{
					f= _filters.filters.requestObject(name,KeyFilter,false) as KeyFilter;
					f.replaceKeys(false,true,keys);
					var filterLabel:FilterLabelUI = filterStatus.addChild(new FilterLabelUI()) as FilterLabelUI;
					filterLabel.filterName.text = name;
					filterLabel.deleteButton.addEventListener(MouseEvent.CLICK,function(event:Event):void{
						removeFilter(name);
						filterStatus.removeChild(filterLabel);
						startIndex.value = 0;
						startIndex.triggerCallbacks();
					});
				}
				startIndex.value = 0;
				startIndex.triggerCallbacks();
			}
			
			public function removeFilter(name:String):void
			{
				_filters.filters.removeObject(name);
				var filterLabels:Array = filterStatus.getChildren();
				for each(var d:FilterLabelUI in filterLabels)
				{
					if(d.filterName.text == name)
					{
						filterStatus.removeChild(d);
						return;
					}
				}
			}
			
			public var enableList:Boolean = true;
			public function showList():void
			{
				enableList = true;
				updateList();
			}
			
			public function showThumbnails():void
			{
				enableList = false;
				updateList();
			}
			
			public var startIndex:LinkableNumber = new LinkableNumber(0);
			
			private var resultsRowCount:int = 10;
			private var _gridSize:int = 3;
			private var _spacing:int = 2;
			private var _imageSize:int = 50;
			
			private function updateList():void
			{
				if(_filteredKeySet.keys.length == 0)
				{
					docList.dataProvider = [];
					updateIndexText(); 
					return;
				}
				var includedKeys:Array = _filteredKeySet.keys;
				
				var listMaxLength:int = 10;
				
				var temp:Array = [];
				
				
				
				
				if(enableList)
				{
					if(includedKeys.length < startIndex.value + listMaxLength)
						listMaxLength = includedKeys.length - startIndex.value;
					
					for(var idx:int=0+startIndex.value; idx<startIndex.value+listMaxLength; idx++)
					{
						temp.push(includedKeys[idx]);
					}
					if(!view.contains(docList))
					{
						view.removeAllChildren();
						view.addChild(docList);
					}
					if(docList.dataProvider == null || (StandardLib.arrayCompare(temp,(docList.dataProvider as ArrayCollection).source) != 0))
					{
						docList.dataProvider = temp;
					}
					navBox.percentWidth = 100;
				}
				else
				{
					view.removeAllChildren();
					var nextX:Number = 0;
					var nextY:Number = 0;
					var count:int = startIndex.value;
					var doc:DocThumbnailComponent = null;
					for (var i:int = 0; i<_gridSize; i++)
					{
						if(count >= includedKeys.length)
							break;
						
						for(var j:int = 0; j< _gridSize; j++)
						{
							if(count >= includedKeys.length)
								break;
							doc = parentNode.thumbnails.getObject((includedKeys[count] as IQualifiedKey).localName) as DocThumbnailComponent;
							//						trace(debugId(doc));
							var pos:Object = doc.pos.getSessionState();
							if(!pos || isNaN(pos.x) || isNaN(pos.y))
							{
								view.addChild(doc);
								doc.positionThumbnail(nextX,nextY);
								nextX += doc.width;
							}
							
							count++;
						}
						nextX = 0;
						nextY += doc.height;
					}
					
//					if(doc)
//						_imageSize = doc.width;
					navBox.width = _imageSize * (_gridSize);
				}
				
				navBox.y = view.y + view.height + filterStatus.y + filterStatus.height;
				if(!nextButton || !prevButton)
				{
					return;
				}
				
				updateIndexText(); 
			}
			
			
			private function prev():void
			{
				//if startIndex is less than row count we don't want index to go below 0
				if(startIndex.value <resultsRowCount)
				{
					startIndex.value = 0;
					return;
				}
				startIndex.value -= resultsRowCount;
				
			}
			
			private function next():void
			{
				if(startIndex.value + resultsRowCount > _filteredKeySet.keys.length)
				{
					return;//nothing more to show
				}
				
				startIndex.value += resultsRowCount;
			}
			
			private var _listMaxLength:int = 10;
			
			
			private function updateIndexText():void
			{
				var includedKeys:Array = _filteredKeySet.keys;
				if(includedKeys.length == 0)
				{
					indexText.text = "No documents found.";
					return;
				}
				var st:int = startIndex.value+1;
				
				indexText.text = "Showing " + st.toString()  + " to "; //+1 to avoid showing 0
				
				if((startIndex.value + resultsRowCount) < includedKeys.length)
				{
					var et:int = startIndex.value + resultsRowCount; 					
					indexText.text += et.toString();
				}
				else
					indexText.text += includedKeys.length;
				
				indexText.text += " of " + includedKeys.length;
			}
			
			private function handleMouseDown(event:MouseEvent):void
			{
				//we don't want selection rectangle to be drawn when mouse is down on list.
				event.stopPropagation();
			}
			
			private function handleMouseMove(event:MouseEvent):void
			{
				//we don't want selection rectangle to be drawn when mouse is down on list.
				event.stopImmediatePropagation();
			}
			
			private function handleItemDragComplete(event:DragEvent):void
			{
				var t:DocThumbnailComponent = ((event.currentTarget as List).selectedItem as DocThumbnailComponent);
				
				if(t)
					t.handleMove();
			}
			
		]]>
	</mx:Script>
</mx:VBox>