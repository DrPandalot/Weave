<?xml version="1.0" encoding="utf-8"?>
<!--This component is used for handling node operations.
It has a text area which diplays the keywords.
It has 4 icons to:
Close/Delete the node
Edit the keyword
Search within the node.
Filter by Date
Info to provide a tooltip describing the node (like number of documents found)

-->
<mx:VBox implements="weave.api.core.ILinkableObject" xmlns:mx="http://www.adobe.com/2006/mxml" horizontalScrollPolicy="off" verticalScrollPolicy="off"
width="200" xmlns:ui="weave.ui.infomap.ui.*" clipContent="false">
	<mx:List mouseMove="handleMouseMove(event)" toolTip="" dragEnabled="true" id="docList" width="100%">
		<mx:itemRenderer>
			<mx:Component>
				<!--Setting the tool tip to empty so that you can only see the Document Summary Component on mouse over.
				Setting it to null does not work.-->
				<ui:CustomLabelTextField toolTip="" width="100%"> 
					<mx:Script>
						<![CDATA[
							import com.modestmaps.core.Coordinate;
							
							import mx.controls.ColorPicker;
							import mx.core.UITextField;
							import mx.core.mx_internal;
							import mx.events.DragEvent;
							import mx.managers.CursorManager;
							
							import weave.api.WeaveAPI;
							import weave.core.StageUtils;
							import weave.data.DataSources.InfoMapsDataSource;
							import weave.ui.infomap.layout.NodeHandler;
							import weave.utils.CustomCursorManager;
							
							private var infomapDataSource:InfoMapsDataSource = WeaveAPI.globalHashMap.getObject(InfoMapsDataSource.SOURCE_NAME) as InfoMapsDataSource;
							
							override protected function childrenCreated():void
							{
								infomapDataSource.getColumnByName("title").addImmediateCallback(outerDocument.docList,updateLabelText);
								
								//Hide DocumentSummaryComponent on mouse out and hide link cursor
								this.addEventListener(MouseEvent.MOUSE_OUT, function(event:MouseEvent):void {
									CustomCursorManager.removeCurrentCursor();
									DocumentSummaryComponent.hide();
								});
							}
							
							private var _mouseDown:Boolean = false;
							
							private var stageUtils:StageUtils = new StageUtils();
							
							override public function set data(value:Object):void
							{
								if(value == null)
									return;
								super.data = value;
								
								var t:DocThumbnailComponent = (value as DocThumbnailComponent);
								
								//changing background color if document is new/highlighted
								t.highlighted.addImmediateCallback(this,changeBackgroundColor,true);
								
								//removing highlighted background color if any when user clicks on the list item
								this.addEventListener(MouseEvent.CLICK,handleMouseClick);
								
								this.text = infomapDataSource.getTitleForURL(t.docURL.value);
								
								//Show DocumentSummaryComponent on mouse over and show link cursor
								this.addEventListener(MouseEvent.MOUSE_OVER, function(event:MouseEvent):void {
									CustomCursorManager.showCursor(CustomCursorManager.LINK_CURSOR);
//									trace("in MOUSE OVER" + _mouseDown + name);
									if(!stageUtils.mouseButtonDown)
										DocumentSummaryComponent.show(event.stageX,event.stageY,t.docURL.value,event.target as DisplayObject);
								});
								
								//go to document link on double click
								this.addEventListener(MouseEvent.DOUBLE_CLICK, function (event:MouseEvent):void {
									var link:String = t.docURL.value;
									var linkLen:int = link.length;
									var linkExtension:String = link.substring(linkLen-3,linkLen);
									if(linkExtension == "pdf")
									{
										link = "http://129.63.8.219:8080/"+link.substring(link.indexOf("infomap"),linkLen);
									}
									navigateToURL(new URLRequest(link));
								});
							}
							
							private function changeBackgroundColor():void
							{
								if((data as DocThumbnailComponent).highlighted.value && (outerDocument.parent.parent) is NodeHandler)
								{
									(this as CustomLabelTextField).getTextField().background = true;
									(this as CustomLabelTextField).getTextField().backgroundColor = 10092492;
										//TODO:Change this to use sessioned color
//										(outerDocument.parent.parent.parent.parent as InfoMapPanel).newThumbnailGlowColor.value;
//									(this as CustomLabelTextField).validateDisplayList();
								}else{
									//the item renderer will retain the background and only replace the content for the rows. 
									//So it is necessary to clear the background color 
									(this as CustomLabelTextField).getTextField().background = false;		
								}
							}
							
							//remove background color if any
							private function handleMouseClick(event:MouseEvent):void
							{
								(this as CustomLabelTextField).getTextField().background = false;
//								(this as CustomLabelTextField).getTextField().backgroundColor = undefined;
							}
							
							private function updateLabelText():void
							{
								//the list was blinking because the label used to be set from empty to the text again because
								//the column is busy still getting the data
								//so we test it to only update the labels when it has the data. 
								if(WeaveAPI.SessionManager.linkableObjectIsBusy(infomapDataSource.getColumnByName("title")))
									return;
								if(data != null)
									this.text = infomapDataSource.getTitleForURL((data as DocThumbnailComponent).docURL.value);
							}
						]]>
					</mx:Script>
				</ui:CustomLabelTextField>
			</mx:Component>
		</mx:itemRenderer>
		
	</mx:List>
	<mx:HBox width="{docList.width}" clipContent="false">
		<mx:Button id="prevButton" width="10%" label="Prev" click="prev()"/>
		<mx:Label id="indexText" textAlign="center" width="80%"/>
		<mx:Button id="nextButton" width="10%" label="Next" click="next()"/>
	</mx:HBox>
	
	<mx:Script>
		<![CDATA[
			import mx.collections.ArrayCollection;
			import weave.ui.infomap.layout.NodeHandler;
			import weave.data.DataSources.InfoMapsDataSource;
			import weave.api.WeaveAPI;
			import weave.api.data.IQualifiedKey;
			import weave.api.getCallbackCollection;
			import weave.Weave;
			import weave.data.KeySets.KeyFilter;
			import mx.core.DragSource;
			import mx.managers.DragManager;
			import mx.events.DragEvent;
			import weave.utils.VectorUtils;
			import org.igniterealtime.xiff.events.OutgoingDataEvent;
			import weave.api.newLinkableChild;
			import weave.core.LinkableNumber;
			import weave.core.LinkableString;
			
			private var _docKeys:Array = new Array();
			public function set docKeys(value:Array):void
			{
				_docKeys = [];
				VectorUtils.copy(value,_docKeys);
				handleKeysChange();
			}
			
			private var _subset:KeyFilter = Weave.root.getObject(Weave.DEFAULT_SUBSET_KEYFILTER) as KeyFilter;
			
			public var startIndex:LinkableNumber = new LinkableNumber(0);
			
			private var rowCount:int = 10;
			override protected function childrenCreated():void
			{
				startIndex.addImmediateCallback(this,updateDocumentList,true);
				getCallbackCollection(_subset).addGroupedCallback(this,updateDocumentList);
			}
			
			private function handleKeysChange():void
			{
				startIndex.value = 0;
				
				startIndex.triggerCallbacks();
			}
			
			private function prev():void
			{
				//if startIndex is less than row count we don't want index to go below 0
				if(startIndex.value <rowCount)
				{
					startIndex.value = 0;
					return;
				}
				startIndex.value -= rowCount;
				
			}
			
			private function next():void
			{
				if(startIndex.value + rowCount > _docKeys.length)
				{
					return;//nothing more to show
				}
				
				startIndex.value += rowCount;
			}
			
			//updates the list of documents to show based on the starting index
			//checks to see if data is less than rows to display and updates list's dataprovider accordingly
			private function updateDocumentList():void
			{
				if(!_docKeys || _docKeys.length == 0)
				{
					docList.dataProvider = [];					
					return;
				}
				
				var includedKeys:Array = [];
				
				for (var i:int = 0; i < _docKeys.length; i++)
				{
					var k:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,(_docKeys[i] as DocThumbnailComponent).docURL.value);
					
					if(_subset.containsKey(k))
						includedKeys.push((this.parent.parent as NodeHandler).thumbnails.getObject(k.localName)); 
				}
				
				var listMaxLength:int = 10;
				
				var temp:Array = [];
				
				
				
				if(includedKeys.length < startIndex.value + listMaxLength)
					listMaxLength = includedKeys.length - startIndex.value;
				
				for(var j:int=0+startIndex.value; j<startIndex.value+listMaxLength; j++)
				{
					temp.push(includedKeys[j]);
				}
				
				if(docList.dataProvider == null || !VectorUtils.compare(temp,(docList.dataProvider as ArrayCollection).source))
					docList.dataProvider = temp;
				
				//disable nextButton if showing the last set of documents
				if(startIndex.value + rowCount >= includedKeys.length)
				{
					nextButton.enabled = false;
				}else
				{
					nextButton.enabled = true;	
				}
				
				//disable prevButton if showing the first set of documents
				if(startIndex.value < rowCount)
				{
					prevButton.enabled = false;
				}
				else
				{
					prevButton.enabled = true;
				}
				
				updateIndexText(includedKeys); 
			}
			
			private function updateIndexText(keysToShow:Array):void
			{
				var st:int = startIndex.value+1;
				
				indexText.text = "Showing " + st.toString()  + " to "; //+1 to avoid showing 0
				
				if((startIndex.value + rowCount) < keysToShow.length)
				{
					var et:int = startIndex.value + rowCount; 					
					indexText.text += et.toString();
				}
				else
					indexText.text += keysToShow.length;
				
				indexText.text += " of " + keysToShow.length;
					
			}
			
			private function handleMouseMove(event:MouseEvent):void
			{
				//we don't want selection rectangle to be drawn when mouse is down on list.
				event.stopImmediatePropagation();
			}
		]]>
	</mx:Script>
</mx:VBox>