<?xml version="1.0" encoding="utf-8"?>
<!--This component is used for handling node operations.
It has a text area which diplays the keywords.
It has 4 icons to:
Close/Delete the node
Edit the keyword
Search within the node.
Filter by Date
Info to provide a tooltip describing the node (like number of documents found)

-->
<mx:VBox implements="weave.api.core.ILinkableObject" xmlns:mx="http://www.adobe.com/2006/mxml" horizontalScrollPolicy="off" verticalScrollPolicy="off"
width="100%" xmlns:ui="weave.ui.infomap.ui.*" clipContent="false">
	<mx:List allowMultipleSelection="true"
		doubleClickEnabled="true" mouseMove="handleMouseMove(event)" toolTip="" dragEnabled="true" id="docList" width="100%" dragComplete="handleItemDragComplete(event)">
		<mx:itemRenderer>
			<mx:Component>
				<!--Setting the tool tip to empty so that you can only see the Document Summary Component on mouse over.
				Setting it to null does not work.-->
				<ui:CustomLabelTextField doubleClick="handleItemDoubleClick(event)" rollOut="handleItemRollOut(event)" rollOver="handleItemRollOver(event)" 
										 toolTip="" width="100%"> 
					<mx:Script>
						<![CDATA[
							import com.modestmaps.core.Coordinate;
							
							import mx.controls.ColorPicker;
							import mx.core.UITextField;
							import mx.core.mx_internal;
							import mx.events.DragEvent;
							import mx.managers.CursorManager;
							
							import weave.api.WeaveAPI;
							import weave.core.StageUtils;
							import weave.data.DataSources.InfoMapsDataSource;
							import weave.ui.infomap.layout.NodeHandler;
							import weave.utils.CustomCursorManager;
							import weave.visualization.layers.InteractiveVisualization;
							
							private var infomapDataSource:InfoMapsDataSource = WeaveAPI.globalHashMap.getObject(InfoMapsDataSource.SOURCE_NAME) as InfoMapsDataSource;
							
							override protected function childrenCreated():void
							{
								infomapDataSource.getColumnByName("title").addImmediateCallback(outerDocument,updateLabelText);
							}
							
							private var _mouseDown:Boolean = false;
							
							private var stageUtils:StageUtils = new StageUtils();
							
							
							
							override public function set data(value:Object):void
							{
								super.data = value;
								if(value == null)
									return;
								
								var t:DocThumbnailComponent = (value as DocThumbnailComponent);
								
								//changing background color if document is new/highlighted
								t.highlighted.addImmediateCallback(this,changeBackgroundColor,true);
								
								//removing highlighted background color if any when user clicks on the list item
								this.addEventListener(MouseEvent.CLICK,handleMouseClick);
								
								this.text = infomapDataSource.getTitleForURL(t.docURL.value);
							}
							
							private function changeBackgroundColor():void
							{
								if((data as DocThumbnailComponent).highlighted.value && (outerDocument.parent.parent) is NodeHandler)
								{
									(this as CustomLabelTextField).getTextField().background = true;
									(this as CustomLabelTextField).getTextField().backgroundColor = 10092492;
										//TODO:Change this to use sessioned color
//										(outerDocument.parent.parent.parent.parent as InfoMapPanel).newThumbnailGlowColor.value;
//									(this as CustomLabelTextField).validateDisplayList();
								}else{
									//the item renderer will retain the background and only replace the content for the rows. 
									//So it is necessary to clear the background color 
									(this as CustomLabelTextField).getTextField().background = false;		
								}
							}
							
							private var cursorID:int = -1;
							private function handleItemRollOver(event:MouseEvent):void
							{
								cursorID = CustomCursorManager.showCursor(InteractiveVisualization.CURSOR_LINK);
								
								var d:DocThumbnailComponent = data as DocThumbnailComponent;
								
								if(d == null)
									return;
								if(!stageUtils.mouseButtonDown)
									DocumentSummaryComponent.show(stage.mouseX,stage.mouseY,d.docURL.value,event.currentTarget as DisplayObject,(outerDocument.parent.parent as NodeHandler));
							}
							private function handleItemRollOut(event:MouseEvent):void
							{
								var d:DocThumbnailComponent = data as DocThumbnailComponent;
								CustomCursorManager.removeCursor(cursorID);
								DocumentSummaryComponent.hide();
							}
							private function handleItemDoubleClick(event:MouseEvent):void
							{
								var t:DocThumbnailComponent = data as DocThumbnailComponent;
								
								var link:String = t.docURL.value;
								navigateToURL(new URLRequest(link));
							}
							
							//remove background color if any because of new document highlighting
							private function handleMouseClick(event:MouseEvent):void
							{
								(this as CustomLabelTextField).getTextField().background = false;
							}
							
							private function updateLabelText():void
							{
								//the list was blinking because the label used to be set from empty to the text again because
								//the column is busy still getting the data
								//so we test it to only update the labels when it has the data. 
								if(WeaveAPI.SessionManager.linkableObjectIsBusy(infomapDataSource.getColumnByName("title")))
									return;
								if(data != null)
									this.text = infomapDataSource.getTitleForURL((data as DocThumbnailComponent).docURL.value);
							}
						]]>
					</mx:Script>
				</ui:CustomLabelTextField>
			</mx:Component>
		</mx:itemRenderer>
	</mx:List>
	<mx:HBox id="navBox" width="{this.width}" clipContent="false">
		<mx:Button id="prevButton" width="10%" label="Prev" click="prev()"/>
		<mx:Label id="indexText" textAlign="center" width="80%"/>
		<mx:Button id="nextButton" width="10%" label="Next" click="next()"/>
	</mx:HBox>
	
	<mx:Script>
		<![CDATA[
			import mx.controls.listClasses.IListItemRenderer;
			import mx.core.mx_internal;
			import weave.visualization.layers.InteractiveVisualization;
			import weave.utils.CustomCursorManager;
			import weave.core.StageUtils;
			import mx.events.ListEvent;
			import weave.compiler.StandardLib;
			import mx.collections.ArrayCollection;
			import weave.ui.infomap.layout.NodeHandler;
			import weave.data.DataSources.InfoMapsDataSource;
			import weave.api.WeaveAPI;
			import weave.api.data.IQualifiedKey;
			import weave.api.getCallbackCollection;
			import weave.Weave;
			import weave.data.KeySets.KeyFilter;
			import mx.core.DragSource;
			import mx.managers.DragManager;
			import mx.events.DragEvent;
			import weave.utils.VectorUtils;
			import org.igniterealtime.xiff.events.OutgoingDataEvent;
			import weave.api.newLinkableChild;
			import weave.core.LinkableNumber;
			import weave.core.LinkableString;
			
			private var _docKeys:Array = new Array();
			public function set docKeys(value:Array):void
			{
				_docKeys = [];
				VectorUtils.copy(value,_docKeys);
				handleKeysChange();
			}
			
			private var _subset:KeyFilter = Weave.root.getObject(Weave.DEFAULT_SUBSET_KEYFILTER) as KeyFilter;
			
			public var startIndex:LinkableNumber = new LinkableNumber(0);
			
			private var resultsRowCount:int = 10;
			override protected function childrenCreated():void
			{
				startIndex.addGroupedCallback(this,updateDocumentList,true);
				getCallbackCollection(_subset).addGroupedCallback(this,updateDocumentList);
			}
			
			private function handleKeysChange():void
			{
				startIndex.value = 0;
				
				startIndex.triggerCallbacks();
			}
			
			private function prev():void
			{
				//if startIndex is less than row count we don't want index to go below 0
				if(startIndex.value <resultsRowCount)
				{
					startIndex.value = 0;
					return;
				}
				startIndex.value -= resultsRowCount;
				
			}
			
			private function next():void
			{
				if(startIndex.value + resultsRowCount > _docKeys.length)
				{
					return;//nothing more to show
				}
				
				startIndex.value += resultsRowCount;
			}
			
			//updates the list of documents to show based on the starting index
			//checks to see if data is less than rows to display and updates list's dataprovider accordingly
			private function updateDocumentList():void
			{
				if(!_docKeys || _docKeys.length == 0)
				{
					docList.dataProvider = [];
					updateIndexText([]); 
					return;
				}
				
				var includedKeys:Array = [];
				
				for (var i:int = 0; i < _docKeys.length; i++)
				{
//					var k:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,(_docKeys[i] as DocThumbnailComponent).docURL.value);
					
					if(_subset.containsKey(_docKeys[i]))
						includedKeys.push((this.parent.parent as NodeHandler).thumbnails.getObject(_docKeys[i].localName)); 
				}
				
				var listMaxLength:int = 10;
				
				var temp:Array = [];
				
				
				
				if(includedKeys.length < startIndex.value + listMaxLength)
					listMaxLength = includedKeys.length - startIndex.value;
				
				for(var j:int=0+startIndex.value; j<startIndex.value+listMaxLength; j++)
				{
					temp.push(includedKeys[j]);
				}
				
				if(docList.dataProvider == null || (StandardLib.arrayCompare(temp,(docList.dataProvider as ArrayCollection).source) != 0))
					docList.dataProvider = temp;
				
				if(!nextButton || !prevButton)
				{
					return;
				}
				//disable nextButton if showing the last set of documents
				if(startIndex.value + resultsRowCount >= includedKeys.length)
				{
					nextButton.enabled = false;
				}else
				{
					nextButton.enabled = true;	
				}
				
				//disable prevButton if showing the first set of documents
				if(startIndex.value < resultsRowCount)
				{
					prevButton.enabled = false;
				}
				else
				{
					prevButton.enabled = true;
				}
				
				updateIndexText(includedKeys); 
			}
			
			private function updateIndexText(keysToShow:Array):void
			{
				if(keysToShow.length == 0)
				{
					indexText.text = "No documents found.";
					return;
				}
				var st:int = startIndex.value+1;
				
				indexText.text = "Showing " + st.toString()  + " to "; //+1 to avoid showing 0
				
				if((startIndex.value + resultsRowCount) < keysToShow.length)
				{
					var et:int = startIndex.value + resultsRowCount; 					
					indexText.text += et.toString();
				}
				else
					indexText.text += keysToShow.length;
				
				indexText.text += " of " + keysToShow.length;
					
			}
			
			private function handleMouseMove(event:MouseEvent):void
			{
				//we don't want selection rectangle to be drawn when mouse is down on list.
				event.stopImmediatePropagation();
			}
			
			private function handleItemDragComplete(event:DragEvent):void
			{
				var t:DocThumbnailComponent = ((event.currentTarget as List).selectedItem as DocThumbnailComponent);
				
				if(t)
					t.handleMove();
			}
			
		]]>
	</mx:Script>
</mx:VBox>