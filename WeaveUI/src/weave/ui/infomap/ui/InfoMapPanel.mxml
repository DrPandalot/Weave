<?xml version="1.0" encoding="utf-8"?>
<!--
/*
Weave (Web-based Analysis and Visualization Environment)
Copyright (C) 2008-2011 University of Massachusetts Lowell

This file is a part of Weave.

Weave is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License, Version 3,
as published by the Free Software Foundation.

Weave is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Weave.  If not, see <http://www.gnu.org/licenses/>.
*/
-->
<ui:DraggablePanel
	xmlns="weave.ui.infomap.*" xmlns:mx="http://www.adobe.com/2006/mxml" 
	xmlns:ui="weave.ui.*"
	horizontalScrollPolicy="off" verticalScrollPolicy="off"
	borderThickness="0"
	title="InfoMap Prototype"
	clipContent="true"
	autoLayout="true"
	paddingLeft="5"
	paddingTop="5"
	backgroundSize="100%"
	dragDrop="dragDropHandler(event)"
	dragEnter="dragEnterHandler(event)"
	>
	
	<mx:Script>
		<![CDATA[
			import com.as3xls.cdf.Directory;
			import com.cartogrammar.drawing.DashedLine;
			
			import mx.binding.utils.BindingUtils;
			import mx.collections.ArrayCollection;
			import mx.collections.Sort;
			import mx.collections.SortField;
			import mx.controls.Alert;
			import mx.controls.Image;
			import mx.controls.List;
			import mx.controls.dataGridClasses.DataGridColumn;
			import mx.core.Application;
			import mx.core.IUIComponent;
			import mx.core.UITextField;
			import mx.core.mx_internal;
			import mx.events.CloseEvent;
			import mx.events.CollectionEvent;
			import mx.events.DragEvent;
			import mx.managers.DragManager;
			import mx.managers.PopUpManager;
			import mx.rpc.AsyncToken;
			import mx.rpc.IResponder;
			import mx.rpc.Responder;
			import mx.rpc.events.FaultEvent;
			import mx.rpc.events.ResultEvent;
			import mx.utils.Base64Encoder;
			import mx.utils.StringUtil;
			import mx.utils.XMLUtil;
			
			import weave.Weave;
			import weave.api.WeaveAPI;
			import weave.api.data.IAttributeColumn;
			import weave.api.data.IQualifiedKey;
			import weave.api.detectLinkableObjectChange;
			import weave.api.getCallbackCollection;
			import weave.api.getLinkableDescendants;
			import weave.api.linkBindableProperty;
			import weave.api.linkSessionState;
			import weave.api.newLinkableChild;
			import weave.api.registerDisposableChild;
			import weave.api.registerLinkableChild;
			import weave.api.unlinkBindableProperty;
			import weave.compiler.StandardLib;
			import weave.core.ErrorManager;
			import weave.core.LinkableBoolean;
			import weave.core.LinkableHashMap;
			import weave.core.LinkableNumber;
			import weave.core.LinkableString;
			import weave.core.StageUtils;
			import weave.core.UIUtils;
			import weave.data.DataSources.CSVDataSource;
			import weave.data.DataSources.InfoMapsDataSource;
			import weave.data.KeySets.KeyFilter;
			import weave.data.KeySets.KeySet;
			import weave.data.QKeyManager;
			import weave.primitives.ColorRamp;
			import weave.primitives.DateRangeFilter;
			import weave.services.DelayedAsyncInvocation;
			import weave.services.DelayedAsyncResponder;
			import weave.services.InfoMapAdminInterface;
			import weave.services.jquery.JQueryCaller;
			import weave.ui.CustomContextMenuManager;
			import weave.ui.SubMenu;
			import weave.ui.infomap.InfoMapLoader;
			import weave.ui.infomap.core.FilterableInfoMapNode;
			import weave.ui.infomap.core.MovedThumbnailPosition;
			import weave.ui.infomap.core.SelectableInfoMapDocument;
			import weave.ui.infomap.layout.NodeHandler;
			import weave.utils.BitmapUtils;
			import weave.utils.ColumnUtils;
			import weave.utils.DateUtils;
			import weave.utils.PopUpUtils;
			import weave.utils.ProbeTextUtils;
			
			/**
			 * @public
			 * This is mapping of a link to a node where each node is a defined by a query of keywords,operator and filters
			 * */
			public const nodes:LinkableHashMap = newLinkableChild(this, LinkableHashMap);
			
			public const infoMapsDataSource:InfoMapsDataSource = Weave.root.requestObject(InfoMapsDataSource.SOURCE_NAME,InfoMapsDataSource, true);
			
			public const defaultNodeBorderColor:LinkableNumber = registerLinkableChild(this,new LinkableNumber(13421772),null,true);
			
			public const selectedNodeBorderColor:LinkableNumber = registerLinkableChild(this,new LinkableNumber(39168),null,true);
			
			public const defaultThumbnailBorderColor:LinkableNumber = registerLinkableChild(this,new LinkableNumber(000000));
			
			public const selectedThumbnailBorderColor:LinkableNumber = registerLinkableChild(this,new LinkableNumber(16711680));
			
			public const newThumbnailGlowColor:LinkableNumber = registerLinkableChild(this,new LinkableNumber(10092492));
			
			
			/**
			 * @public
			 * This is mapping of a link to a document object. 
			 * All the nodes within this panel will point to document objects in this map only.
			 * When a query is made by each node, the documents retrieved are stored in this map.
			 * */
//			public const docs:LinkableHashMap = newLinkableChild(this,LinkableHashMap);
//			public const docsCSVDataSource:CSVDataSource = newLinkableChild(this,CSVDataSource);
//			public static const DOC_KEYTYPE:String = "infomapDocURL";
			
			/**
			 * @public
			 * this search keyword will apply to all the nodes within the panel
			 * This is not a query keyword. This is used only to search within the documents
			 * of each node.
			 * */
			public const globalSearchKeyword:LinkableString = new LinkableString('');
			
			public const globalDateFilter:DateRangeFilter = new DateRangeFilter();
			
			public const backgroundImageName:LinkableString = registerLinkableChild(this,new LinkableString(''),handleBackgroundImageChange);
			
			override protected function constructor():void
			{
				super.constructor();
			}
			
			
						
			private static var _selectedKeySet:KeySet = Weave.root.getObject(Weave.DEFAULT_SELECTION_KEYSET) as KeySet;
			
			override protected function childrenCreated():void
			{
				super.childrenCreated();
				UIUtils.linkDisplayObjects(map,nodes,false);
				sortByTitle();
				linkBindableProperty(globalSearchKeyword,globalSearchTextInput,"text",500);
				
				registerDisposableChild(this,globalSearchKeyword);
				registerDisposableChild(this,globalDateFilter);
				
				_subset = Weave.root.getObject(Weave.DEFAULT_SUBSET_KEYFILTER) as KeyFilter;
				
				Weave.properties.dashedSelectionBox.addImmediateCallback(this, validateDashedLine, true);
				
				stage.addEventListener(MouseEvent.MOUSE_UP,handleMouseUp);
				
				selectionKeywords.addGroupedCallback(this,handleRecordsSelection,false);
				
				_entityKeySet.addGroupedCallback(this,parseRecordsSelectionQueryResponse,false);
				
				getCallbackCollection(this).addImmediateCallback(this,invalidateDisplayList);
				
				map.addEventListener(MouseEvent.MOUSE_DOWN,handleMouseDown);
				
				internalColorRamp.value = '<colorRamp name="Dark2" tags="ColorBrewer,basic,qualitative,printer-friendly">0x04E9E7,0x009DF4,0x0201F4,0x01FC01,0x00C400,0x008C00,0x0FDF801,0xF99200,0xFD0000,0xBC0000,0xF800FD,0x9854C6</colorRamp>';
				
//				linkBindableProperty(defaultNodeBorderColor,defaultNodeColorPicker,"selectedColor");
//				linkBindableProperty(selectedNodeBorderColor,selectedNodeColorPicker,"selectedColor");
				linkBindableProperty(defaultThumbnailBorderColor,defaultThumbnailBorderPicker,"selectedColor");
				linkBindableProperty(selectedThumbnailBorderColor,selectedThumbnailBorderPicker,"selectedColor");
				linkBindableProperty(newThumbnailGlowColor,thumbnailGlowColorPicker,"selectedColor");
				
				_infomapSubMenu = new SubMenu(subMenuButton,[MouseEvent.CLICK]);
				
				_infomapSubMenu.addSubMenuItem("Add Query Node",addInfoMapNode);
				_infomapSubMenu.addSubMenuItem("Add Map Node",addInfoMapLink);
				_infomapSubMenu.addSubMenuItem("Show all Tag Clouds",showAllTagClouds);
				_infomapSubMenu.addSubMenuItem("Hide all Tag Clouds",hideAllTagClouds);
				_infomapSubMenu.addSubMenuItem("Remove Selected Documents",removeSelectedDocuments);
				_infomapSubMenu.addSubMenuItem("Show All Documents",showAllDocuments);
				
				_fileReference.addEventListener(Event.SELECT, folderSelectHanlder);
//				_fileReference.addEventListener(Event.COMPLETE,fileLoadCompleteHandler);
				_fileReference.addEventListener(IOErrorEvent.IO_ERROR, folderErrorHandler)
			}
			
			private var _infomapSubMenu:SubMenu = null;
			private function dragEnterHandler(event:DragEvent):void
			{
				if(event.dragInitiator is DocThumbnailComponent || event.dragInitiator is List)
				{
					DragManager.acceptDragDrop(this);
				}
			}
			
			private function dragDropHandler(event:DragEvent):void
			{
				
				var t:DocThumbnailComponent;
				
				if(event.dragInitiator is List)
				{
					t = (event.dragInitiator as List).selectedItem as DocThumbnailComponent; 
				}
				else{
					t =	event.dragInitiator as DocThumbnailComponent; 
				}
				
				//if the parent is a NodeHandler set hasBeenMoved to true and add it as a child to the InfoMapPanel
				if(!(t.parent == this.map))
				{
					map.addChild(t);
					t.hasBeenMoved.value = true;	
				}
				
				//move the thumbnail to the new location
				var localPoint:Point = map.globalToLocal(new Point(event.stageX,event.stageY));
				t.move(localPoint.x,localPoint.y);
				
				t.imageHeight.value = 50;
				t.imageWidth.value = 50;
				
			}
			
			private var _subset:KeyFilter;
			private function removeSelectedDocuments():void
			{
				var selectedDocs:Array = getSelectedDocumentKeys();
				
				_subset.excludeKeys(selectedDocs);
				
				_selectedKeySet.clearKeys();
			}
			
			
			
			private function showAllDocuments():void
			{
//				var excludedKeys:Array =  _subset.excluded.keys;
//				var dockeys:Array = [];
//				
//				for each(var key:IQualifiedKey in excludedKeys)
//				{
//					if(key.keyType == InfoMapsDataSource.DOC_KEYTYPE)
//						dockeys.push(key);
//				}
//				_subset.excluded.removeKeys(dockeys);
				
				//clearing all keys for now
				_subset.replaceKeys(true,true);
			}
			
			private function getSelectedDocumentURLs():Array
			{
				var selectedKeys:Array = _selectedKeySet.keys;
				var selectedDocs:Array = [];
				
				for each(var key:IQualifiedKey in selectedKeys)
				{
					if(key.keyType == InfoMapsDataSource.DOC_KEYTYPE)
						selectedDocs.push(key.localName);
				}
				
				return selectedDocs;
			}
			
			private function getSelectedDocumentKeys():Array
			{
				var selectedKeys:Array = _selectedKeySet.keys;
				var selectedDocs:Array = [];
				
				for each(var key:IQualifiedKey in selectedKeys)
				{
					if(key.keyType == InfoMapsDataSource.DOC_KEYTYPE)
						selectedDocs.push(key);
				}
				
				return selectedDocs;
			}
			
			override protected function updateDisplayList(unscaledWidth:Number, unscaledHeight:Number):void
			{
				super.updateDisplayList(unscaledWidth, unscaledHeight);
				
				//detect any changes in selectionKeySet and make query for matched entity values
				if(detectLinkableObjectChange(updateDisplayList,_selectedKeySet))
				{
					//selection happened outside of the panel then return
					if(!(DraggablePanel.getTopPanel() is InfoMapPanel))
						return;
					
					var selectedDocs:Array = getSelectedDocumentURLs();
					
					if(selectedDocs.length == 0)
					{
						_selectedKeySet.clearKeys();
						return;
					}
					
					var entities:Array = extractAllEntitiyValues();
					
					var query:DelayedAsyncInvocation = InfoMapAdminInterface.instance.searchInDocuments(entities,selectedDocs);
					query.addAsyncResponder(handleMatchedEntities,handleMatchedEntitiesFault);
				}
			}
			
			private function handleMatchedEntities(event:ResultEvent,token:Object=null):void
			{
				var entities:Array = event.result as Array;
				var keys:Array = [];
				for each(var entity:String in entities)
				{
					//get all entity attribute columns of selected keytype
					var attrCols:Array = getLinkableDescendants(Weave.root,IAttributeColumn);
					
					for each (var attrCol:IAttributeColumn in attrCols)
					{
						var entityValue:String = attrCol.getMetadata("isEntity");
						if(entityValue == "true")
						{
							for each (var key:IQualifiedKey in attrCol.keys)
							{
								var value:String = ColumnUtils.getString(attrCol,key);
								if(value.toLowerCase() == entity.toLowerCase())
								{
									keys.push(key);
									break; //assuming that there will be only one such entity value in a column. This assumption could be wrong.
								}
							}
						}
					}
				}
				
				if(!keys.length == 0)
					_selectedKeySet.addKeys(keys);
//				else
//					_selectedKeySet.clearKeys();
				
//				Alert.show((event.result as Array).toString());
			}
			
			private function handleMatchedEntitiesFault(event:FaultEvent,token:Object=null):void
			{
				WeaveAPI.ErrorManager.reportError(event.type);
			}
			
			
			private var selectionKeywords:LinkableString = new LinkableString("",null,false);
			private function handleMouseUp(event:MouseEvent):void
			{
				//we should set the selection keywords only if the mouseup happened from outside of InfoMap panel
				//This is still not the right way to do it. Need to find a more efficient solution
				
				removeEventListener(MouseEvent.MOUSE_MOVE,handleMouseDrag);
				
				//clear any selection rectangle created on mouse drag
				if(sprite)
				{
					sprite.graphics.clear();
					if(map.rawChildren.contains(sprite))
						map.rawChildren.removeChild(sprite);
				}
				
				if((DraggablePanel.getTopPanel() is InfoMapPanel))
					return;
				
				
				var keywords:Array = InfoMapLoader.extractKeywordsFromSelection();
				selectionKeywords.value = keywords.join(" ");
				
			}
			
			private const _dashedLine:DashedLine = new DashedLine(0, 0, null);
			private function validateDashedLine():void
			{
				_dashedLine.lengthsString = Weave.properties.dashedSelectionBox.value;
			}
			
//			private var _selectionRectangleGraphicsCleared:Boolean = true;
			private var dragStartX:Number;
			private var dragStartY:Number;
			private function handleMouseDown(event:MouseEvent):void
			{
				//if the mouse is down on an item in the list don't listen for selection
				if(event.target is UITextField)
					return;
				
				var localPoint:Point = map.globalToLocal(new Point(event.stageX,event.stageY));
				
				dragStartX = localPoint.x;
				dragStartY = localPoint.y;
				
				addEventListener(MouseEvent.MOUSE_MOVE,handleMouseDrag);
			}
			
			private var sprite:Sprite =  new Sprite();
			private function handleMouseDrag(event:MouseEvent):void
			{
				if(sprite)
					sprite.graphics.clear();
				
				map.rawChildren.addChild(sprite);
				
				var g:Graphics = sprite.graphics;
				
				_dashedLine.graphics = g; 
				
				_dashedLine.lineStyle(2, 0x00ff00, .75);
				
				var localPoint:Point = map.globalToLocal(new Point(event.stageX,event.stageY));
								
				var w:Number = localPoint.x - dragStartX;
				var h:Number = localPoint.y - dragStartY;
				
				var startCorner:int;
				// if height < 0, then the box is dragged upward
				// if width < 0, then the box is dragged leftward
				if (h < 0)
				{
					if (w < 0)
						startCorner = DashedLine.BOTTOM_RIGHT;
					else
						startCorner = DashedLine.BOTTOM_LEFT;
				}
				else 
				{
					if (w < 0)
						startCorner = DashedLine.TOP_RIGHT;
					else
						startCorner = DashedLine.TOP_LEFT;
				}
				
				_dashedLine.drawRect(dragStartX, dragStartY, Math.abs(w), Math.abs(h),startCorner);
				
				var selectionRect:Rectangle = sprite.getRect(map);
				
				map.graphics.clear();
				
				var currentNodes:Array = nodes.getObjects();
				
				var selectedKeys:Array = [];
				
				for (var i:int = 0; i<currentNodes.length; i++)
				{
					if(currentNodes[i] is LinkToInfoMapComponent)
						continue;
					var node:NodeHandler = currentNodes[i];
					var currentDocs:Array = node.thumbnails.getObjects();
					
					
					for each (var t:DocThumbnailComponent in currentDocs)
					{
						var r:Rectangle = t.getRect(map);
						var key:IQualifiedKey = WeaveAPI.QKeyManager.getQKey(InfoMapsDataSource.DOC_KEYTYPE,t.docURL.value);
						if(selectionRect.intersects(r))
						{
//							map.graphics.lineStyle(1,0);
//							map.graphics.drawRect(r.x,r.y,r.width,r.height);
							selectedKeys.push(key);
						}
					}
				}
				
				_selectedKeySet.replaceKeys(selectedKeys);
				
				
			}
			
			private function extractAllEntitiyValues():Array
			{
				//get all entity attribute columns of selected keytype
				var attrCols:Array = getLinkableDescendants(Weave.root,IAttributeColumn);
				var temp:Array = [];
				
				for each (var attrCol:IAttributeColumn in attrCols)
				{
					var entityValue:String = attrCol.getMetadata("isEntity");
					if(entityValue == "true")
					{
						for each (var key:IQualifiedKey in attrCol.keys)
						{
							var value:String = ColumnUtils.getString(attrCol,key);
							if(value)
							{
								temp.push(value);
							}
						}
					}
				}
				
				
				//get unique keywords from extracted values 
				var dict:Dictionary = new Dictionary();
				
				for each(var word:String in temp)
				{
					if(dict[word] == undefined)
						dict[word] = word;
				}
				
				var uniqueEntityValues:Array = []
				for each(var prop:String in dict)
				{
					uniqueEntityValues.push(prop);	
				}
				
				return uniqueEntityValues;
			}
			
			
			private var _selectionLoader:URLLoader = null;
			private var _entityKeySet:KeySet = new KeySet();
			private function handleRecordsSelection():void
			{
				if(!selectionKeywords.value)
					return;
				
				var solrURL:String =  "http://129.63.8.219:8080/solr/select/?version=2.2&start=0&rows=2000&sort=date_published%20desc&indent=on&fl=link&q=" + 
					selectionKeywords.value;
				
//				infoMapsDataSource.getDocumentsForQuery(_entityKeySet,selectionKeywords.value,"OR");
				
			}
			
			private function parseRecordsSelectionQueryResponse():void
			{
				var selectedDocs:Array = _entityKeySet.keys;
				for each (var key:IQualifiedKey in selectedDocs)
				{
					if(infoMapsDataSource.containsDoc(key))
						_selectedKeySet.addKeys(selectedDocs);
				}
			}
			
			
			private function handleRequestError(event:IOErrorEvent):void
			{
				WeaveAPI.ErrorManager.reportError(event.text);
			}
			
		
			
//			private function refreshNodes(event:TimerEvent):void
//			{
//				var handlers:Array = nodes.getObjects();
//				
//				for (var i:int = 0;i<handlers.length;i++)
//				{
//					if(handlers[i] is NodeHandler)
//						(handlers[i] as NodeHandler).checkForNewDocuments();
//					
//				}
//			}
			
			
			private function handlePanelResize():void
			{
				map.validateNow();
			}
			
			private function addInfoMapLink(mapName:String=null):void
			{
				var className:String = getQualifiedClassName(LinkToInfoMapComponent).split("::")[1];
				var linkNodeName:String = nodes.generateUniqueName(className);
				var linkNode:LinkToInfoMapComponent = new LinkToInfoMapComponent();
				linkNode = nodes.requestObject(linkNodeName,LinkToInfoMapComponent,false);
				linkNode.mapNameTextArea.text = mapName;
				
			}
			
			private function showAllTagClouds():void
			{
				for each(var n:NodeHandler in nodes.getObjects())
				{
					n.showTagCloud();
				}
			}
			
			private function hideAllTagClouds():void
			{
				for each(var n:NodeHandler in nodes.getObjects())
				{
					n.hideTagCloud();
				}
			}
			
			private var internalColorRamp:ColorRamp = new ColorRamp();
			private var internalMin:Number = 0;
			private var internalMax:Number = 13;
			public function addInfoMapNode(query:String=null,op:String=null):void
			{
				var className:String = getQualifiedClassName(NodeHandler).split("::")[1];
				var nodeName:String = nodes.generateUniqueName(className);
				var nodeHandler:NodeHandler= new NodeHandler();
				nodeHandler = nodes.requestObject(nodeName,NodeHandler,false);
				
				nodeHandler.nodeBase.width = 200;//starting off with wide text area
				
				nodeHandler.query.keywords.value = query;
				if(op ==null)
				{
					//TODO: should take value from RadioButton. Value was null when last tried.
					nodeHandler.query.operator.value = "AND";	
				}
				else{
					
					nodeHandler.query.operator.value = op;
				}
				
				nodeHandler.thumbnailsDefaultColor.value = internalColorRamp.getColorFromNorm(StandardLib.normalize(nodes.getNames().length-1, internalMin, internalMax));
				nodeHandler.nodeBase.keywordTextArea.setStyle("borderColor",nodeHandler.thumbnailsDefaultColor.value);
			}
			
			private var loader:URLLoader = null;
			private function addRssFeed():void
			{
				var url:String = feedURL.text;
				url = StringUtil.trim(url);
				if(url == "")
				{
					errorMsg.visible = true;
					return;	
				}
				
				var title:String = feedTitle.text;
				title = StringUtil.trim(title);
				if(title == "")
				{
					errorMsg.visible = true;	
					return;
				}	
								
				InfoMapAdminInterface.instance.addRssFeed(feedTitle.text,feedURL.text);
				sortByTitle();
				
				errorMsg.visible = false;
			}
			
			private function deleteRssFeed():void
			{
				if(grid.selectedItem == null)
					return;

				PopUpUtils.confirm(
					this,
					"Confirm delete",
					'Delete Feed entry:  "'+(grid.selectedItem as Array)[0]+'"?',
					del
				);
				
				function del():void{
					
					var url:String = (grid.selectedItem as Array)[1];
					
					if (url =="")
						return;
					
					InfoMapAdminInterface.instance.deleteRssFeed(url);
					sortByTitle();
				}
			}
			
			private function sortByTitle():void
			{
				var dp:ArrayCollection = grid.dataProvider as ArrayCollection;
				var sort:Sort = new Sort();
				var sortF:SortField = new SortField("Title",true,false);
				sort.fields = [sortF];
				dp.sort = sort;
			}
			
			
			
			private function handleDateFilter():void
			{
				DateFilterComponent.openInstance(this,globalDateFilter);
			}
			
			private var _fileLoader:FileReference = null;
			/**
			 * browseForfiles: opens up a file browser window to upload CSV files 
			 **/
			private function browse():void
			{
				if(_fileLoader == null)
				{
					_fileLoader = new FileReference();
					_fileLoader.addEventListener(Event.SELECT, handleDatasetSelected);
					_fileLoader.addEventListener(Event.COMPLETE, handleDatasetLoaded);
				}
				
				_fileLoader.browse();
			}
			
			
			private function handleDatasetSelected(event:Event):void
			{
				_fileLoader.load();
			}
			
			private function handleBackgroundImageChange():void
			{
				if(backgroundImageName.value)
					map.setStyle("backgroundImage","/infomap_images/"+ backgroundImageName.value+".png");
			}
			
			private var _mapImage:BitmapData
			private var imgLoader:Loader = new Loader();
			private function handleDatasetLoaded(event:Event):void
			{
				imageURL.text = _fileLoader.name.substr(0,_fileLoader.name.length-4);
				
				imgLoader.contentLoaderInfo.addEventListener(Event.COMPLETE,handleLoaderComplete);
				imgLoader.loadBytes(_fileLoader.data);
				
				
			}
			
			private function handleLoaderComplete(event:Event):void
			{
				var imgBitMap:Bitmap = Bitmap(imgLoader.content);
				
				BitmapUtils.drawCenteredIcon(map.graphics,map.x+map.width/2,map.y+map.height/2,imgBitMap.bitmapData);
			}
			
			private function saveImage(event:Event):void
			{
				
								
				var _byteArray:ByteArray = new ByteArray();
				_byteArray.writeBytes(_fileLoader.data as ByteArray);
				var encoder:Base64Encoder = new Base64Encoder();
				encoder.encodeBytes(_byteArray);
				
				var request:URLRequest = new URLRequest('/ImageService/Base64ImageService/'+imageURL.text);
				var encoderStr:String = encoder.drain();
				request.method = URLRequestMethod.POST;
				request.data = encoderStr;
				trace('sent byteArray:', encoderStr.length);
				WeaveAPI.URLRequestUtils.getURL(this,request, handleImageSave, handleImageSaveFault, null, URLLoaderDataFormat.BINARY);

			}
			
			private function handleImageSave(event:ResultEvent,token:Object=null):void
			{
				Alert.show("Image saved as " + event.result,"Saved");
				
				backgroundImageName.value = imageURL.text;
				
			}
			
			private function handleImageSaveFault(event:ResultEvent,token:Object=null):void
			{
				Alert.show("Image could not be saved" + event.message,"Error");	
			}
			
			
			private function clearImage():void
			{
				map.graphics.clear();
				backgroundImageName.value = "";				
			}
			
			private var _fileReference:FileReferenceList = new FileReferenceList();
//			private var _fileReferenceList:FileReferenceList = new FileReferenceList();
			
			private function browseAndUpload():void
			{
				var fileTypes:Array = [new FileFilter("Text Files", "*.doc; *.docx; *.txt; *.csv; *.pdf")];
				_fileReference.browse(fileTypes);
//				_fileReference.
			}
			
			private function popupLoader():void
			{
//				var loader:HTMLFileUploader = PopUpManager.createPopUp(this,HTMLFileUploader) as HTMLFileUploader;
//				PopUpManager.centerPopUp(loader);
//				loader.addEventListener(CloseEvent.CLOSE,function():void{PopUpManager.removePopUp(loader);});
				
				var q:DelayedAsyncInvocation = InfoMapAdminInterface.instance.testDropBox();
				q.addAsyncResponder(callDropBox,faultDropBox);
			}
			
			private function callDropBox(event:ResultEvent,token:Object = null):void
			{
				ExternalInterface.call(event.result as String);
			}
			
			private function faultDropBox(event:FaultEvent,token:Object = null):void
			{
				
			}
			
			[Bindable] private var fileUploadCount:int = 0;
			[Bindable] private var targetFileUploadCount:int = 0;
			private function folderSelectHanlder(event:Event):void
			{
				if(!username.text)
				{
					Alert.show("Please enter an username to associate with the files","Error");
					return;
				}
				
				var file:FileReference;
				var selectedFiles:Array = _fileReference.fileList;
				fileUploadCount = 0;
				targetFileUploadCount = selectedFiles.length;
				for (var i:int = 0; i < selectedFiles.length; i++)
				{
					file = selectedFiles[i] as FileReference;
					file.addEventListener(Event.COMPLETE,fileLoadCompleteHandler);
					if(file.size > 10000000)
					{
						WeaveAPI.ErrorManager.reportError("Error", "Cannot Upload file " + file.name + ". Maximum file size is 10 MB");
						return;
					}
					try{
						
						file.load();
					}
					catch(e:Error)
					{
						WeaveAPI.ErrorManager.reportError(e.message);
					}
				}
			}
			
			private function folderErrorHandler(event:IOErrorEvent):void
			{
				var fileRef:FileReference = event.target as FileReference;
				WeaveAPI.ErrorManager.reportError(
					"File upload failed",
					"File: " + fileRef.name + "\n" + "Size: " + fileRef.size + "\n" + event.text);
			}
			
			
			private function fileLoadCompleteHandler(event:Event):void
			{
				if ((event.target as FileReference).data == null)
					return;
				if(!username.text)
				{
					Alert.show("Please enter an username to associate with the files","Error");
					return;
				}
				InfoMapAdminInterface.instance.addDocumentToSolr(username.text,event.target as FileReference);
				fileUploadCount++; //TODO Check for file index status.
			}
			
			
		]]>
	</mx:Script>
	<!--the resize code is required so that the content is clipped by the canvas-->
	<mx:Canvas backgroundImage="" id="map" clipContent="true" width="100%" height="100%" autoLayout="false" 
			   verticalScrollPolicy="off" horizontalScrollPolicy="off" 
			   resize="map.scrollRect=new Rectangle(0,0,map.width,map.height);handlePanelResize();"><!--For clipping the content at the edges-->
				<mx:HBox width="100%" paddingLeft="5" paddingTop="5" horizontalAlign="right">
					<!--<mx:HBox>
						<mx:ComboBox id="nodeComboBox" dataProvider="{['Add a Query Node','Add a Map Node']}" fontWeight="bold" change="handleNodeComboBoxChange()"/>
						<mx:TextInput keyUp="handleKeyUp(event)" id="keywordsInput" enabled="true" cornerRadius="5" borderStyle="solid" toolTip="Separate your keywords by space to apply the operator correctly"/>
						<mx:Button label="Add" id="addNodeButton" click="handleAddNodeButtonClick()"/>
					</mx:HBox>-->
					<!--<mx:HBox>
						<mx:Label text="Operator: "/>
						<mx:RadioButtonGroup id="operatorButton" enabled="true"/>
						<mx:RadioButton groupName="operatorButton" value="OR" label="OR"/>
						<mx:RadioButton groupName="operatorButton" value="AND" label="AND" selected="true"/>
					</mx:HBox>
					<mx:HBox>
						<mx:Label text="Date Range: "/>
						<mx:TextInput  cornerRadius="5" borderStyle="solid" editable="false" id="startDateText" width="75" />
							<mx:Label text="TO"/>
						<mx:TextInput  cornerRadius="5" borderStyle="solid" editable="false" id="endDateText" width="75"/>
						<mx:LinkButton textDecoration="underline" color="blue" fontWeight="normal" label="Select" click="handleDateFilter()"/>
						<mx:LinkButton textDecoration="underline" color="blue" fontWeight="normal" label="Clear" click="clearDateFilter()"/>
					</mx:HBox>-->
					<mx:HBox>
							<mx:Label fontWeight="bold" text="Search in Nodes:"/>
							<mx:TextInput id="globalSearchTextInput" borderStyle="solid" cornerRadius="5" width="200" />
							<mx:LinkButton textDecoration="underline" color="blue" fontWeight="normal" label="Add Date Filter" click="handleDateFilter()"/>
							<mx:Spacer width="50"/>
						</mx:HBox>
				</mx:HBox>
				
		
		</mx:Canvas>
	<ui:ControlPanel id="ctrlPanel">
		<mx:VBox label="Basic Settings">
			<mx:HBox>
				<mx:Label text="Set Background Image: "/>
				<mx:TextInput editable="false" id="imageURL"/>
				<mx:Button label="Browse" click="browse()"/>
				<mx:Button label="Clear" click="clearImage()"/>
				<mx:Button label="Save" click="saveImage(event)"/>
			</mx:HBox>
			<!--<mx:CheckBox id="autoSaveCheckBox" label="Save session automatically"/>-->
			<mx:Spacer height="50"/>
			<mx:HBox>
				<mx:VBox>
					<mx:HBox>
						<mx:ColorPicker id="defaultNodeColorPicker"/>
						<mx:Label width="150" text="Default Node Color"/>				
					</mx:HBox>
					
					<mx:HBox>
						<mx:ColorPicker id="selectedNodeColorPicker"/>
						<mx:Label width="150" text="Selected Node Color"/>				
					</mx:HBox>
				</mx:VBox>
				<mx:VBox>
					<mx:HBox>
						<mx:ColorPicker id="defaultThumbnailBorderPicker"/>
						<mx:Label width="200" text="Default Thumbnail Border Color"/>				
					</mx:HBox>
					
					<mx:HBox>
						<mx:ColorPicker id="selectedThumbnailBorderPicker"/>
						<mx:Label width="200" text="Selected Thumbnail Border Color"/>				
					</mx:HBox>
					<mx:HBox>
						<mx:ColorPicker id="thumbnailGlowColorPicker"/>
						<mx:Label width="200" text="New Thumbnail Border Color"/>				
					</mx:HBox>
				</mx:VBox>
			</mx:HBox>
		</mx:VBox>
		<mx:VBox id="feedsControlPanel" label="Add/Remove Feeds">
		<mx:Label text="Enter RSS Feed: " />
		<mx:HBox>
			<mx:Label text="Title"/>
			<mx:TextInput width="100" id="feedTitle" borderStyle="solid" cornerRadius="5" />
			<mx:Label text="URL"/>
			<mx:TextInput width="300" id="feedURL" borderStyle="solid" cornerRadius="5" />
			<mx:Button label="Add" click="addRssFeed()" />
		</mx:HBox>	
		<mx:Label id="errorMsg" color="red" fontWeight="bold" text="Both fields are required." visible="false"/>
			<mx:DataGrid id="grid" dataProvider="{InfoMapAdminInterface.instance.rssFeeds}" width="100%">
				<mx:columns>
					<mx:DataGridColumn dataField="0" sortDescending="true" headerText="Title"/>
					<mx:DataGridColumn dataField="1" headerText="URL"/>
				</mx:columns>
			</mx:DataGrid>
		<mx:HBox width="100%">
			<mx:Button label="Index Now" click="infoMapsDataSource.startIndexing()" />
			<mx:Spacer width="100%"/>
			<mx:Button  label="Delete Selected Feed" click="deleteRssFeed()"/>
		</mx:HBox>
			<mx:TextArea backgroundColor="0xCCCCCC" borderThickness="0" editable="false" width="500" height="100%" fontWeight="bold" text="The indexing is scheduled to run every hour. You can hit the Index Now button if you want to index your feeds you added recently. Please allow 10 -15 minutes for the results to show up."/>
		</mx:VBox>
		<mx:VBox id="uploadFilesPanel" label="Index Local Files">
			<mx:HBox>
				<mx:Label text="Enter username: "/>
				<mx:TextInput width="200" id="username" />
			</mx:HBox>
			<mx:HBox>
				<ui:TextInputWithPrompt id="fileNameInput" prompt="Select files/folder."/>
				<mx:Button label="Upload File" click="browseAndUpload();"/>
				<mx:Label text="{fileUploadCount > 0 ? fileUploadCount + ' of ' + targetFileUploadCount + ' files indexed' : ''}"/>
			</mx:HBox>
			<mx:Button label="Open Loader" click="popupLoader()"/>
		</mx:VBox>
		<ui:UserWindowSettings targetTool="{this}"/>
	</ui:ControlPanel>
</ui:DraggablePanel>