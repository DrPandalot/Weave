<?xml version="1.0" encoding="utf-8"?>
<!--This component is used for handling node operations.
It has a text area which diplays the keywords.
It has 4 icons to:
Close/Delete the node
Edit the keyword
Search within the node.
Filter by Date
Info to provide a tooltip describing the node (like number of documents found)

-->
<ControlPanel
	xmlns="weave.ui.*"
	xmlns:mx="http://www.adobe.com/2006/mxml"
	title="Node Settings"
	layout="absolute"
	alpha="0.8"
	height="55%"
	removedFromStage="rangeComboBox.selectedItem = '--Quick Select--';" xmlns:ui="weave.ui.infomap.ui.*"
	addedToStage="if(sourcesGrid){sourcesGrid.refreshSourcesList();}if(feedTitle)feedTitle.text='';if(feedURL)feedURL.text='';"
	>
	<!--Non visual tags like Validator, Style,  etc should be added as the immediate children of the root mxml tag-->
	<mx:VBox paddingLeft="5" paddingTop="5" label="Basic">
		<mx:HBox>
			<mx:Label text="Edit Query: " fontWeight="bold" width="{_leftAlignWidth}"/>					
			<mx:TextInput id="keyword" keyDown="handleEnterKey(event)"/>
			<mx:Button label="Apply" click="applyKeyword()"/>
		</mx:HBox>
		<mx:HBox>
			<mx:Label text="Boolean Operator: " fontWeight="bold" width="{_leftAlignWidth}"/>					
			<mx:ComboBox id="operator"/>
		</mx:HBox>
		
		<!--<mx:HBox>
			<mx:Label text="Search in Node: " fontWeight="bold"  width="{_leftAlignWidth}"/>					
			<mx:TextInput id="searchTextInput" keyUp="handleEnterKeyOnSearch(event)"/>
		</mx:HBox>-->
		
		<!--<mx:HBox>
			<mx:Label fontWeight="bold" text="Change Layout: "  width="{_leftAlignWidth}"/>			
			<CustomComboBox id="layoutComboBox" change="handleLayoutChange()"/>
		</mx:HBox>-->
		<!--<mx:HBox>
			<mx:Label fontWeight="bold" text="Spacing: "  width="{_leftAlignWidth}"/>			
			<mx:HSlider tickLength="0" tickThickness="0" minimum="-50" maximum="200" id="spacingSlider"
						change="{(nodeHandler.layout.internalObject as IInfoMapNodeLayout).thumbnailSpacingValue = spacingSlider.value}" snapInterval="5" />
		</mx:HBox>-->
		
		<!--<mx:Label fontWeight="bold" text="Sources to Query*"/>
		<mx:List id="selectedSourcesList" selectable="true" allowMultipleSelection="true" width="50%"/>
		<mx:Text fontSize="9" text="*if list is empty all available sources are queried."/>
		<mx:Button label="Delete Selected Sources" click="removeSourceFromSelecedList()"/>-->
	</mx:VBox>

	<mx:VBox label="Add Date Filter">
		<mx:Label text="Set a Date Range" fontWeight="bold"  />
		<mx:HBox>
			<mx:VBox>
				<mx:Label fontWeight="normal" text="Start Date"/>				
				<mx:DateChooser id="startRange" change="handleStartDateChange()" showToday="false"/>
			</mx:VBox>
			<mx:VBox>
				<mx:Label fontWeight="normal" text="End Date"/>
				<mx:DateChooser id="endRange" change="handleEndDateChange()" showToday="false"/>
			</mx:VBox>
		</mx:HBox>
		
		<mx:HBox>
			<mx:ComboBox change="handleDateFilterComboBoxChange()" id="rangeComboBox"/> <!--The Combo Box is not linked to the filterObject-->
			<mx:Button label="Remove Date Filter" click="handleClearDates()"/>
		</mx:HBox>
	</mx:VBox>
	<mx:VBox label="Add Source Filter">
		<!--<mx:Te width="100%" text="By default, the query searches in all the available data sources. You can choose which sources you want the query to search.
				 Add a new source or make a selection from currently available sources."/>-->
		<mx:Label text="Add a new Source: " />
		<mx:HBox>
			<mx:Label text="Title"/>
			<mx:TextInput width="100" id="feedTitle" borderStyle="solid" cornerRadius="5" />
			<mx:Label text="URL"/>
			<mx:TextInput width="300" id="feedURL" borderStyle="solid" cornerRadius="5" />
			<mx:Button label="Add" click="addRssFeed()" />
		</mx:HBox>	
		<mx:Label id="errorMsg" color="red" fontWeight="bold" text="Both fields are required." visible="false"/>
		<!--<mx:Button id="sourcesListButton" label="Show Available Sources" click="handleSourceListClick()"/>-->
		<ui:SourcesListComponent parentNode="{query}" id="sourcesGrid" width="100%"/>
	</mx:VBox>
		 <mx:Script>
			 <![CDATA[
				 import mx.binding.utils.BindingUtils;
				 import mx.collections.ArrayCollection;
				 import mx.collections.Sort;
				 import mx.collections.SortField;
				 import mx.controls.Alert;
				 import mx.events.CloseEvent;
				 import mx.managers.PopUpManager;
				 import mx.utils.StringUtil;
				 
				 import weave.api.WeaveAPI;
				 import weave.api.core.ILinkableHashMap;
				 import weave.api.getCallbackCollection;
				 import weave.api.linkBindableProperty;
				 import weave.api.unlinkBindableProperty;
				 import weave.core.LinkableDynamicObject;
				 import weave.core.LinkableString;
				 import weave.data.CSVParser;
				 import weave.primitives.DateRangeFilter;
				 import weave.services.InfoMapAdminInterface;
				 import weave.ui.infomap.core.InfoMapNode;
				 import weave.ui.infomap.core.QueryObject;
				 import weave.ui.infomap.layout.CascadeLayout;
				 import weave.ui.infomap.layout.GridLayout;
				 import weave.ui.infomap.layout.HorizontalLayout;
				 import weave.ui.infomap.layout.IInfoMapNodeLayout;
				 import weave.ui.infomap.layout.NodeHandler;
				 import weave.ui.infomap.layout.RadialLayout;
				 import weave.ui.infomap.layout.VerticalLayout;
				 import weave.utils.DateUtils;
				 import weave.utils.EventUtils;
				 
				 [Inspectable]
				 public var query:QueryObject= null;
				 
				 [Bindable]
				 private var _leftAlignWidth:Number = 100;
				 
				 
				 private var startDateStr:LinkableString = new LinkableString('');
				 private var endDateStr:LinkableString = new LinkableString('');
				 
				 
				 override protected function childrenCreated():void
				 {
					super.childrenCreated();
					rangeComboBox.dataProvider = ['--Quick Select--','Since Last 1 Day','Since Last 3 Days','Since Last Week','Since Last Month','Since Last Year'];
					//setting the dataprovide here fixes the combo box bug where it still showed the first item one by default
					//even if it was not the selected item
//					layoutComboBox.dataProvider =  ['Radial','Grid'] ;
					 
					operator.dataProvider = ['OR','AND'];
					 
//					keyword.text = nodeHandler.node.keywords.value;
					keyword.text = query.keywords.value;
					 
//					linkBindableProperty(nodeHandler.searchFilter,searchTextInput,"text",500);
					
					operator.selectedItem = query.operator.value;
					linkBindableProperty(query.operator,operator,"selectedItem");
					
					query.dateFilter.startDate.addImmediateCallback(this,handleStartDateFilterChange,false);
					query.dateFilter.endDate.addImmediateCallback(this,handleEndDateFilterChange,false);
					 
					startDateStr.addGroupedCallback(this,handleDateChange);
					endDateStr.addGroupedCallback(this,handleDateChange);
					
					
					
//					nodeHandler.layout.addImmediateCallback(this,handleLayoutObjectChange,true);
					
					this.targets = [query.keywords,query.sources,query.dateFilter.startDate,query.dateFilter.endDate]
				 }
				 
//				 private function handleLayoutObjectChange():void
//				 {
//					 if(nodeHandler.layout.internalObject)
//					 {
//					 	layoutComboBox.selectedLabel = (nodeHandler.layout.internalObject as IInfoMapNodeLayout).name;
//						spacingSlider.value = (nodeHandler.layout.internalObject as IInfoMapNodeLayout).thumbnailSpacingValue;									 
//					 }
//				 }
				 
				 // we only want to make a query if both dates are set. 
				 private function handleDateChange():void
				 {
					 if(startDateStr.value == '' || endDateStr.value == '')
						 return;
					 getCallbackCollection(query.dateFilter).delayCallbacks();

					 query.dateFilter.startDate.value = startDateStr.value;
					 query.dateFilter.endDate.value = endDateStr.value;
					 
					 getCallbackCollection(query.dateFilter).resumeCallbacks();
					 getCallbackCollection(query.dateFilter).triggerCallbacks();				 
				 }
				 
				 private function handleStartDateFilterChange():void
				 {
					 if(query.dateFilter.startDate.value != null)
					 {
						 startDateStr.value = query.dateFilter.startDate.value;
					 	startRange.selectedDate = DateUtils.getDateFromString(query.dateFilter.startDate.value);
					 if(query.dateFilter.startDate.value.search('NOW') == -1)
					 	rangeComboBox.selectedItem = "--Quick Select--";
					 }
				 }
				 
				 private function handleEndDateFilterChange():void
				 {
					 if(query.dateFilter.endDate.value != null)
					 {
						endDateStr.value = query.dateFilter.endDate.value;
					 	endRange.selectedDate = DateUtils.getDateFromString(query.dateFilter.endDate.value);
					 }
					 if(query.dateFilter.endDate.value &&  query.dateFilter.startDate.value.search('NOW') == -1)
						 rangeComboBox.selectedItem = "--Quick Select--";
				 }
				 
				 private function applyKeyword():void
				 {
					 if(query && keyword)
						 query.keywords.value = keyword.text;
				 }
				 
//				 private function handleLayoutChange():void
//				 {
//					 var currentLayout:LinkableDynamicObject = nodeHandler.layout;
//					 if(layoutComboBox.selectedItem as String == 'Radial')
//					 {
//						 if(currentLayout.internalObject is RadialLayout)
//							 return;
//						 currentLayout.removeObject();
//						 currentLayout.requestLocalObject(RadialLayout,false);
//					 }else if(layoutComboBox.selectedItem as String == 'Cascade')
//					 {
//						 if(currentLayout.internalObject is CascadeLayout)
//							 return;
//						 currentLayout.removeObject();
//						 currentLayout.requestLocalObject(CascadeLayout,false);
//					 }else if(layoutComboBox.selectedItem as String == 'Grid')
//					 {
//						 if(currentLayout.internalObject is GridLayout)
//							 return;
//						 currentLayout.removeObject();
//						 currentLayout.requestLocalObject(GridLayout,false);
//					 }else if(layoutComboBox.selectedItem as String == 'Horizontal')
//					 {
//						 if(currentLayout.internalObject is HorizontalLayout)
//							 return;
//						 currentLayout.removeObject();
//						 currentLayout.requestLocalObject(HorizontalLayout,false);
//					 }else if(layoutComboBox.selectedItem as String == 'Vertical')
//					 {
//						 if(currentLayout.internalObject is VerticalLayout)
//							 return;
//						 currentLayout.removeObject();
//						 currentLayout.requestLocalObject(VerticalLayout,false);
//					 }
//					 
//				 }
				 
				 
				 
				 private function handleEnterKey(event:KeyboardEvent):void
				 {
					 if(event.keyCode == Keyboard.ENTER)
					 {
						 event.preventDefault();
						 editQuery();
					 }
				 }
				 
				 private function editQuery():void
				 {
					 query.keywords.value = keyword.text;
				 }
				 
				 private function handleEnterKeyOnSearch(event:KeyboardEvent):void
				 {
					 if(event.keyCode == Keyboard.ENTER)
					 {
						 event.preventDefault();
						 return;
					 }
					 
//					 nodeHandler.searchFilter.value = searchTextInput.text;
				 }
				 
				 private function handleDateFilterComboBoxChange():void
				 {
					 //we set this to empty string so that a query is after the end date is set and before the start date is set
					 startDateStr.value = '';
					 
					 endDateStr.value = 'NOW';
					 if(rangeComboBox.selectedItem == 'Since Last 1 Day')
					 {
						 startDateStr.value = 'NOW-01DAY';
					 }else if(rangeComboBox.selectedItem == 'Since Last 3 Days')
					 {
						 startDateStr.value = 'NOW-03DAYS';
					 }else if(rangeComboBox.selectedItem == 'Since Last Week')
					 {
						 startDateStr.value = 'NOW-07DAYS';
					 }else if(rangeComboBox.selectedItem == 'Since Last Month')
					 {
						 startDateStr.value = 'NOW-01MONTH';
					 }else if(rangeComboBox.selectedItem == 'Since Last Year')
					 {
						 startDateStr.value = 'NOW-12MONTHS';
					 }else if(rangeComboBox.selectedItem == '--Choose--')
					 {
//						handleClearDates();
//						return;
					 }
					 
				 }
				 
				 private function handleStartDateChange():void
				 {
					 startDateStr.value = startRange.selectedDate.toDateString();
					 
					 rangeComboBox.selectedItem = "--Quick Select--";
				 }
				 
				 private function handleEndDateChange():void
				 {
					 endDateStr.value = endRange.selectedDate.toDateString();
					 
					 rangeComboBox.selectedItem = "--Quick Select--";
				 }
				 
				 
				 private function handleClearDates():void
				 {
					 //clearning dates in filterObject
					 query.dateFilter.endDate.value = '';
					 query.dateFilter.startDate.value = '';
					 
					 
					 startRange.selectedDate = null;
					 endRange.selectedDate = null;
					 startRange.invalidateDisplayList();
					 endRange.invalidateDisplayList();
					 
					 rangeComboBox.selectedItem = "--Quick Select--";
				 }
				 
				 private function addRssFeed():void
				 {
					 var url:String = feedURL.text;
					 url = StringUtil.trim(url);
					 if(url == "")
					 {
						 errorMsg.visible = true;
						 return;	
					 }
					 
					 var title:String = feedTitle.text;
					 title = StringUtil.trim(title);
					 if(title == "")
					 {
						 errorMsg.visible = true;	
						 return;
					 }	
					 
					 InfoMapAdminInterface.instance.addRssFeed(feedTitle.text,feedURL.text);
					 
					 errorMsg.visible = false;
					 
					 addSourceString('"' + feedTitle.text + '"');
					 
				 }
				 
				 
				/*  private function handleSourceListClick():void
				 {
					if(sourcesListButton.label == 'Show Available Sources')
					{
						sourcesListButton.label = 'Hide Available Sources';
						hideListEffect.stop();
						showListEffect.play();
					}
					else 
					{
						sourcesListButton.label = 'Show Available Sources';
						showListEffect.stop();
						hideListEffect.play();
					}
				 }*/ 
				 
				
				 
				private var parser:CSVParser = new CSVParser();
				private function addSourceString(source:String):void
				{
					
					var sources:Array = new Array();
					sources.push([]);
					
					var dict:Dictionary = new Dictionary();
					
					if(!query.sources.value == '')
						sources[0] = parser.parseCSV(query.sources.value)[0];
					
					//if the source name already exists then ignore and return
					for each(var src:String in sources[0])
					{
						dict[src] = true;
					}
					
					var newSources:Array = parser.parseCSV(source)[0]; 
					sources[0] = sources[0].concat(newSources);
					
					//sorting so that sources always appear in the same order
					//this is necessary so that the callbacks on sources are not called simply because the same sources are out of order.
					sources[0].sort();
					
					query.sources.value = parser.createCSV(sources);
				}
				
				
				 
				
//				private function removeSourceFromSelecedList():void
//				{
//					var sourcesToRemove:Array = selectedSourcesList.selectedItems;
//					
//					var currentSources:Array = parser.parseCSV(nodeHandler.node.sources.value)[0];
//					
//					var temp:Array = new Array();
//					temp.push([]);
//					
//					for each(var source:String in currentSources)
//					{
//						if(sourcesToRemove.indexOf(source) == -1)
//						{
//							temp[0].push(source);
//						}
//					}
//					
//					nodeHandler.node.sources.value = parser.createCSV(temp) ;
//				}
				 
			 ]]>
		 </mx:Script>
</ControlPanel>