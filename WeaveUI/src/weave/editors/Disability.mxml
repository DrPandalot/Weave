<?xml version="1.0" encoding="utf-8"?>
<!--
/*
Weave (Web-based Analysis and Visualization Environment)
Copyright (C) 2008-2011 University of Massachusetts Lowell

This file is a part of Weave.

Weave is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License, Version 3,
as published by the Free Software Foundation.

Weave is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Weave.  If not, see <http://www.gnu.org/licenses/>.
*/
-->
<!---
@author mervetuccar
@author hgranz
@spurushe
-->
<mx:VBox xmlns:mx="http://www.adobe.com/2006/mxml" width="400" height="300"       
		 xmlns="weave.editors.*"  xmlns:ui="weave.ui.*" label="Disability"
		 implements="weave.api.core.ILinkableObject"
		 enabled="{_panel != null}" xmlns:s="library://ns.adobe.com/flex/spark">	
	<mx:Label text="User generated visualization description text:"
			  textAlign="left"/>	
	<mx:TextArea id="manualToolDescTextBox" width="100%" height="40%" minWidth="5" minHeight="5" borderStyle="solid"
				 editable="true" keyFocusChange="event.preventDefault(); event.target.replaceSelectedText('\t');"
				 toolTip="changeme" creationComplete="handleCreationComplete(event);" wordWrap="true"/>	
	<mx:Label text="System generated visualization description text:" textAlign="left"/>	
	<mx:TextArea id="automaticToolDescTextBox" width="100%" height="40%" minWidth="5" minHeight="5"
				 borderStyle="solid" editable="false"
				 keyFocusChange="event.preventDefault(); event.target.replaceSelectedText('\t');"
				 toolTip="automatically generated text describing the trend of this line chart"
				 wordWrap="true" text="before button clicked"/>	
	<mx:Button label="Refresh Description" id="automaticDescRefreshButton"
			   toolTip="changeme" click="automaticDescRefreshButton_clickHandler(event)"/>
	<mx:Script>
		<![CDATA[
			import disabilityDictionary.DisabilityMessageCategoryDictionary;
			import disabilityDictionary.DisabilityMessageProperties;
			import disabilityDictionary.DisabilityObject;
			import disabilityPack.LineChartDecisionTree;
			import disabilityPack.SegmentValue;
			import mx.accessibility.CheckBoxAccImpl;
			import mx.binding.utils.BindingUtils;
			import mx.controls.Alert;
			import mx.controls.Menu;
			import mx.controls.TextArea;
			import mx.core.IUIComponent;
			import mx.core.UIComponent;
			import mx.events.DragEvent;
			import mx.events.FlexEvent;
			import mx.managers.DragManager;
			import weave.Weave;
			import weave.api.WeaveAPI;
			import weave.api.core.ILinkableObject;
			import weave.api.data.IAttributeColumn;
			import weave.api.linkBindableProperty;
			import weave.api.newLinkableChild;
			import weave.api.registerLinkableChild;
			import weave.api.reportError;
			import weave.api.setSessionState;
			import weave.api.ui.ILinkableObjectEditor;
			import weave.api.unlinkBindableProperty;
			import weave.api.unlinkSessionState;
			import weave.core.LinkableHashMap;
			import weave.core.LinkableString;
			import weave.data.KeySets.KeySet;
			import weave.ui.ControlPanel;
			import weave.ui.DisabilityOptions;
			import weave.ui.DraggablePanel;
			import weave.utils.ColumnUtils;
			import weave.utils.LinkableTextFormat;
			import weave.visualization.plotters.ParallelCoordinatesPlotter;
			import weave.visualization.tools.LineChartTool;
			// creationComplete="automaticToolDescTextBoxInitialize(event);"
			[Bindable] private var _panel:DraggablePanel = null;	
			public var vizEntities:Array = WeaveAPI.globalHashMap.getObjects(LineChartTool);//collect all the visualization tools
			public var _target:LineChartTool = vizEntities[0] as LineChartTool;;// = Weave.root.requestObject(null, LineChartTool, false);	
			public var lineChartPlotter:ParallelCoordinatesPlotter = (vizEntities[0] as LineChartTool).getPlotter();	
			public var variables:LinkableHashMap;	
			
			public const disabilityText:LinkableString = newLinkableChild(this, LinkableString);
			public var joinKeysRArray:Array = new Array();
			public var joinColsRArray:Array = new Array();
			public var columnNames:Array = new Array();
			public var lineDecisionTree:LineChartDecisionTree = new LineChartDecisionTree();
			private var finalRObject:Array;
			private var resultSegmentation:Array = new Array();
			private var decisionCount:int = 0;
			private var fDecisionCount:int = 0;
			public static var firstSegLength:int = 0;
			private var fTestValues:Array = new Array();
			private var initialSegment:SegmentValue = new SegmentValue();
			public var splittedSegments:Array = new Array();
			public var segmentsLeftToSplit:int = 0;
			public var initSegmentIndices:Array = new Array();
			public function set target(panel:DraggablePanel):void
			{
				if (_panel)
					throw new Error("target should not be set more than once");
				_panel = panel;
			}
			override protected function childrenCreated():void
			{
				super.childrenCreated();	
			}
			public function getSystemGeneratedText():void
			{
			}
			private function handleCreationComplete(event:Event) : void
			{
				variables = lineChartPlotter.columns;
				//linkBindableProperty(Weave.properties.disabilitySystemText, automaticToolDescTextBox, "text");
				checkingPlotterObjects();
				variables.childListCallbacks.addImmediateCallback(this,checkingPlotterObjects);
				Weave.properties.disabilityHashMap.requestObject('text', LinkableString, false);
				var HashDisabilityText : LinkableString = (Weave.properties.disabilityHashMap.renameObject('text', _panel.title) as LinkableString);
				if( HashDisabilityText == null)
					reportError("Error Creating request object from Disability Options");
				else
					linkBindableProperty(HashDisabilityText, event.target, "text");	
			}
			protected function automaticDescRefreshButton_clickHandler(event:MouseEvent):void
			{
				automaticToolDescTextBox.text = "after button clicked";
				var dictionaryType:String;
				var vizType:String;
				var rResult:Array;
				vizType = "lineChart";	
			}
			//this function checks if the hashmap of the plotter is filled, if filled pick columns and send them to R
			public function checkingPlotterObjects():void
			{	
				if(WeaveAPI.SessionManager.linkableObjectIsBusy(variables)) return;
				splittedSegments= new Array();
				segmentsLeftToSplit = 0;
				columnPreprocessing();
			}	
			//getting the columns ready for R
			protected function columnPreprocessing():void
			{
				//use this function to gather the appropriate information that will be sent to R
				//we have the columns in columnObjects
				var numericCols:Array = new Array();
				//below whatever cols are plotted it picks them up as individual objects
				var colObjects:Array = variables.getObjects(IAttributeColumn)
				//pick only numeric columns to be sent to R
				for(var i:int =0 ; i < colObjects.length; i++)
				{
					var col:IAttributeColumn = (colObjects[i] as IAttributeColumn);
					var dataType:String = ColumnUtils.getDataType(col);	
					if (dataType == "number")
					{
						numericCols.push(col);
						columnNames.push(ColumnUtils.getTitle(col));
					}
				}	
				//joining columns returns columns only complete records (no incomplete records)
				var joinedColumns:Array = joinColumns(numericCols);	
				joinKeysRArray = joinedColumns[0];
				joinColsRArray = joinedColumns[1];	
				//todo: getting axis, title, color, scale, etc	
				StartSegmentation();
			}
			private function joinColumns(columns:Array):Array
			{
				var selection:KeySet = Weave.defaultSelectionKeySet;
				var keys:Array = selection.keys.length > 0 ? selection.keys : null;
				//make dataype Null, so that columns will be sent as exact dataype to R
				//if mentioned as String or NUmber ,will convert all columns to String or Number .
				var result:Array = ColumnUtils.joinColumns(columns,null, false, keys);
				return [result.shift(), result];
			}
			private function StartSegmentation():void
			{
				var firstSegment:Array = new Array();
				trace("start");
				for (var i:int = 0; i<joinColsRArray.length; i++)
				{
					firstSegment.push(joinColsRArray[i][0].valueOf());
					
					//reportError(joinColsRArray);
				}
				if(firstSegment.length > 0)
				{
					initialSegment = new SegmentValue();
					initialSegment.segmentIndices = new Array(0, firstSegment.length);
					initialSegment.setSegment(firstSegment);
					initialSegment.mDisability = this;
					initSegmentIndices = initialSegment.segmentIndices;
					firstSegLength = firstSegment.length;
					initialSegment.getValues();
				}
			}
			public function runsTest(mSegment:SegmentValue):void
			{
				var yRegValues:Array = new Array();
				var residual:Array = new Array();
				var posRes:int = new int(); //positive residual
				var standardDV:Number = new Number();
				var runsMean:Number =new Number();
				for(var i:int=0; i<mSegment.Segment.length; i++)
				{
					yRegValues[i] = mSegment.intercept + (mSegment.slope * i);
					residual[i] = mSegment.Segment[i] - yRegValues[i];
					if(residual[i] < 0) 
						mSegment.actualRunsNum++;	
					else 
						posRes++	
				}
				runsMean = ((2*mSegment.actualRunsNum*posRes)/(mSegment.actualRunsNum + posRes)) + 1;
				standardDV = ((2*mSegment.actualRunsNum*posRes)*(2*mSegment.actualRunsNum*posRes - mSegment.actualRunsNum - posRes))/((mSegment.actualRunsNum+posRes)*(mSegment.actualRunsNum+posRes)*(mSegment.actualRunsNum+posRes-1));
				mSegment.diffAM = (mSegment.actualRunsNum - runsMean)/runsMean;
				if(mSegment.actualRunsNum > (runsMean-standardDV)) 
					mSegment.runsTestB = false;
				else
					mSegment.runsTestB = true;	
			}
			public function shouldSplit(mSegment:SegmentValue):Boolean
			{
				runsTest(mSegment);
				return LineChartDecisionTree.getInstance().lineChartDT(mSegment.Segment,mSegment.corr, mSegment.fTests, mSegment.Segment.length / firstSegLength, mSegment.diffAM, mSegment.Segment.length, firstSegLength, mSegment.actualRunsNum, false, mSegment.runsTestB);
			}
			private function splitWithR(mSegment:SegmentValue):void
			{
				// get values first
			}
			public function splitComplete():void
			{
				var start:Boolean = false;
				var end:Boolean = false;
				var sum:int = 0;
				for(var i:int=0; i< splittedSegments.length; i++)
				{
					sum += splittedSegments[i][1] - splittedSegments[i][0];
					/*
					if(splittedSegments[i][0] == 0)
					{
					//trace("segment start: " + splittedSegments[i][0] + "   end: "+ (splittedSegments[i][1] - 1));
					start = true;
					trace("segment start: " + splittedSegments[i][0] + "   end: "+ (splittedSegments[i][1]));
					}
					else
					{
					//trace("segment start: " + (splittedSegments[i][0]-1) + "   end: "+ (splittedSegments[i][1] - 1));	
					trace("segment start: " + splittedSegments[i][0] + "   end: "+ (splittedSegments[i][1]));
					}
					*/
				}
				trace("processing.. " + Math.floor((sum / initSegmentIndices[1]) * 100) + "%");
				if(sum == initSegmentIndices[1])
				{
					trace("finished");
					trace("Line chart splitted into " + splittedSegments.length + " segments");
					splittedSegments.sortOn("0", Array.NUMERIC);
					for(var me:int=0; me< splittedSegments.length; me++)
					{	
						if(splittedSegments[me][0] == 0)
						{
							//trace("segment start: " + splittedSegments[i][0] + "   end: "+ (splittedSegments[i][1] - 1));
							start = true;
							splittedSegments[me][1] = splittedSegments[me][1] - 1;
						}
						else
						{
							//trace("segment start: " + (splittedSegments[i][0]-1) + "   end: "+ (splittedSegments[i][1] - 1));	
							//trace("segment start: " + splittedSegments[i][0] + "   end: "+ (splittedSegments[i][1]));
							splittedSegments[me][0] = splittedSegments[me][0] - 1;
							splittedSegments[me][1] = splittedSegments[me][1] - 1;
						}
						trace("segment no: "+ (me+1) +", start: " + splittedSegments[me][0] + "   end: "+ (splittedSegments[me][1]));
					}
					ProduceSentence
				}
			}
			public function split(mSegment:SegmentValue):void
			{
				//trace("aa");
				if(!shouldSplit(mSegment))
				{
					splittedSegments.push(mSegment.segmentIndices);
					//if(segmentsLeftToSplit ==0)
					splitComplete();
					//trace("splitted segments , " + splittedSegments);
				}
				else
				{
					var newSegments:Array = splitSegment(mSegment);
					var Segment1:SegmentValue = new SegmentValue();
					var Segment2:SegmentValue = new SegmentValue();
					segmentsLeftToSplit +=2;
					Segment1.segmentIndices = newSegments[1];
					Segment1.setSegment(newSegments[0]);
					Segment1.mDisability = initialSegment.mDisability;
					Segment2.segmentIndices = newSegments[3];
					Segment2.setSegment(newSegments[2]);
					Segment2.mDisability = initialSegment.mDisability;
					Segment1.split();
					Segment2.split();
					//seg1
					//seg2
				}
			}
			public static function splitSegment(mSegment:SegmentValue):Array
			{
				var startPoint:Array = new Array(mSegment.segmentIndices[0],mSegment.Segment[0]);
				var endPoint:Array = new Array(mSegment.segmentIndices[1],mSegment.Segment[mSegment.Segment.length -1]);
				var resultSegment:Array = new Array();
				var maxVD:Number = -1;
				var maxVDIndex:int = 0;
				var currVD:Number = -1;
				var first:Array = new Array();
				var secondSegment:Array = new Array();
				var firstIndices:Array = new Array();
				var secondIndices:Array = new Array();
				for(var i:int = mSegment.segmentIndices[0]; i < mSegment.segmentIndices[1] ; i++)
				{
					currVD = verticalDistance(startPoint, endPoint, new Array(i, mSegment.Segment[i]));
					if(currVD > maxVD)
					{
						maxVD = currVD;
						maxVDIndex = i;
					}
				}	
				for(i = 0; i < maxVDIndex ; i++)
				{
					first.push(mSegment.Segment[i]);	
				}
				for(i = maxVDIndex; i < mSegment.Segment.length ; i++)
				{
					secondSegment.push(mSegment.Segment[i]);	
				}
				firstIndices.push(mSegment.segmentIndices[0]);
				//trace(maxVDIndex);
				firstIndices.push(maxVDIndex);
				secondIndices.push(maxVDIndex);
				secondIndices.push(mSegment.segmentIndices[1]);
				resultSegment.push(first);
				resultSegment.push(firstIndices);
				resultSegment.push(secondSegment);
				resultSegment.push(secondIndices);
				return resultSegment;
			}
			public static function verticalDistance(startPoint:Array, endPoint:Array, measuredPoint:Array):Number
			{
				return Math.abs((startPoint[1] + ((endPoint[1] - startPoint[1]) * ((measuredPoint[0] - startPoint[0]) / (endPoint[0] - startPoint[0]))) - measuredPoint[1]));
			}
			public function ProduceSentence(initSeg:Array, splitIndices:Array):void
			{
				//for(var kaka:int = 0; kaka < initSegmentIndices[1] ; kaka++)
				//	trace(initialSegment.Segment[kaka]);
				automaticToolDescTextBox.text = "osman";
			}
		]]>
	</mx:Script>
</mx:VBox>