<?xml version="1.0" encoding="utf-8"?>
<!--
/*
Weave (Web-based Analysis and Visualization Environment)
Copyright (C) 2008-2011 University of Massachusetts Lowell

This file is a part of Weave.

Weave is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License, Version 3,
as published by the Free Software Foundation.

Weave is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Weave.  If not, see <http://www.gnu.org/licenses/>.
*/
-->
<!---
@author mervetuccar
@author hgranz
@spurushe
-->
<mx:VBox xmlns:mx="http://www.adobe.com/2006/mxml" width="400" height="300"       
		 xmlns="weave.editors.*"  xmlns:ui="weave.ui.*" label="Disability"
		 implements="weave.api.core.ILinkableObject"
		 enabled="{_panel != null}" xmlns:s="library://ns.adobe.com/flex/spark">	
	<mx:CheckBox id="DisCheckBox" label="Enable Disability" click="DisabilityEnableCheckBoxHndlr(event)" enabled="true"
				 selected="true"/>
	<mx:Label text="User generated visualization description text:"
			  textAlign="left"/>	
	<mx:TextArea id="manualToolDescTextBox" width="100%" height="40%" minWidth="5" minHeight="5" borderStyle="solid"
				 editable="true" keyFocusChange="event.preventDefault(); event.target.replaceSelectedText('\t');"
				 toolTip="changeme" creationComplete="handleCreationComplete(event);" wordWrap="true"/>	
	<mx:Label text="System generated visualization description text:" textAlign="left"/>	
	<mx:TextArea id="automaticToolDescTextBox" width="100%" height="40%" minWidth="5" minHeight="5"
				 borderStyle="solid" editable="false"
				 keyFocusChange="event.preventDefault(); event.target.replaceSelectedText('\t');"
				 toolTip="automatically generated text describing the trend of this line chart"
				 wordWrap="true" text="before button clicked"/>	
	<mx:Button label="Refresh Description" id="automaticDescRefreshButton"
			   toolTip="changeme" click="automaticDescRefreshButton_clickHandler(event)"/>
	<mx:Label id="progressLabel" width="135" enabled="true"/>
	<mx:Script>
		<![CDATA[
			import disabilityPack.LineChartDecisionTree;
			import disabilityPack.SegmentSummaryAnalyzer;
			import disabilityPack.SegmentValue;
			import disabilityPack.SummarySegment;
			import disabilityPack.disabilityMessagesContainer;
			
			import mx.controls.TextArea;
			
			import weave.Weave;
			import weave.api.core.ILinkableObject;
			import weave.api.data.IAttributeColumn;
			import weave.api.linkBindableProperty;
			import weave.api.newLinkableChild;
			import weave.api.reportError;
			import weave.core.LinkableHashMap;
			import weave.core.LinkableString;
			import weave.data.KeySets.KeySet;
			import weave.ui.DraggablePanel;
			import weave.utils.ColumnUtils;
			import weave.visualization.plotters.OldParallelCoordinatesPlotter;
			import weave.visualization.tools.LineChartTool;
			
			
			// creationComplete="automaticToolDescTextBoxInitialize(event);"
			
			[Bindable] private var _panel:DraggablePanel = null;			
			
			public var vizEntities:Array = WeaveAPI.globalHashMap.getObjects(LineChartTool);//collect all the visualization tools
			public var _target:LineChartTool = vizEntities[0] as LineChartTool;;// = Weave.root.requestObject(null, LineChartTool, false);		
			public var lineChartPlotter:OldParallelCoordinatesPlotter = (vizEntities[0] as LineChartTool).getPlotter();			
			public var variables:LinkableHashMap;			
			
			
			public const disabilityText:LinkableString = newLinkableChild(this, LinkableString);
			public var joinKeysRArray:Array = new Array();
			public var joinColsRArray:Array = new Array();
			public var columnNames:Array = new Array();
			public var lineDecisionTree:LineChartDecisionTree = new LineChartDecisionTree();
			private var finalRObject:Array;
			private var resultSegmentation:Array = new Array();
			private var firstTimeDone:Boolean = false;
			private var disabilityMessages:disabilityMessagesContainer = new disabilityMessagesContainer();
			public static var Instance:Disability;
			private var decisionCount:int = 0;
			private var fDecisionCount:int = 0;
			public static var firstSegLength:int = 0;
			private var fTestValues:Array = new Array();
			private var initialSegment:SegmentValue = new SegmentValue();
			public var splittedSegments:Array = new Array();
			public var segmentsLeftToSplit:int = 0;
			public var initSegmentIndices:Array = new Array();
			private static var DisabilityEnabled:Boolean = true;
			private var NoMoreData:Boolean = false;
			public var mSegmentAnalyser:SegmentSummaryAnalyzer;
			
			
			
			/**
			 * In this class, a disability tex manipulation textbos is created under the settings of a visualization.
			 * The part of segmentation and decision tree functions is computed also here.
			 */
			
			public function set target(panel:DraggablePanel):void
			{
				if (_panel)
					throw new Error("target should not be set more than once");
				
				_panel = panel;
			}
			
			override protected function childrenCreated():void
			{
				super.childrenCreated();		
			}
			
			public function getSystemGeneratedText():void
			{
			}
			
			private function handleCreationComplete(event:Event) : void
			{
				
				Instance = this;
				variables = lineChartPlotter.columns;
		
				//linkBindableProperty(Weave.properties.disabilitySystemText, automaticToolDescTextBox, "text");
				checkingPlotterObjects();
				variables.childListCallbacks.addImmediateCallback(this,checkingPlotterObjects);
				
				Weave.properties.disabilityHashMap.requestObject('text', LinkableString, false);
				var HashDisabilityText : LinkableString = (Weave.properties.disabilityHashMap.renameObject('text', _panel.title) as LinkableString);
				
				if( HashDisabilityText == null)
					reportError("Error Creating request object from Disability Options");
				else
					linkBindableProperty(HashDisabilityText, event.target, "text");	
				
				
				
			}
			
			protected function DisabilityEnableCheckBoxHndlr(event:MouseEvent):void
			{
				//event.target
				
				
				
				DisabilityEnabled = event.target.selected;
				
			}
			
			protected function automaticDescRefreshButton_clickHandler(event:MouseEvent):void
			{
				
				
				if(joinColsRArray[0].length < 2)
				{
					if(!firstTimeDone && DisabilityEnabled)
						StartSegmentation();
						
					else if(DisabilityEnabled && progressLabel.text == "Finished.")
					{
						
						StartSegmentation();
						progressLabel.text = "Ready";
					}
						
					else if(joinColsRArray.length == 0)
					{
						NoMoreData = true;
						automaticToolDescTextBox.text = "No data on the Line chart";
					}
				}
					
				else // have more than one graphs, give a brief summary.
				{
					MultipleLineExplention();
					
					
				}
				var dictionaryType:String;
				var vizType:String;
				var rResult:Array;
				vizType = "lineChart";	
			}
			
			//this function checks if the hashmap of the plotter is filled, if filled pick columns and send them to R
			public function checkingPlotterObjects():void
			{	
				
				if(WeaveAPI.SessionManager.linkableObjectIsBusy(variables)) return;
				
				splittedSegments= new Array();
				segmentsLeftToSplit = 0;
				columnPreprocessing();
			}		
			
			
			//getting the columns ready for R
			protected function columnPreprocessing():void
			{
				NoMoreData = false;
				//progressLabel.text = "Ready";
				automaticDescRefreshButton.enabled = true;
				//use this function to gather the appropriate information that will be sent to R
				//we have the columns in columnObjects
				var numericCols:Array = new Array();
				//below whatever cols are plotted it picks them up as individual objects
				var colObjects:Array = variables.getObjects(IAttributeColumn)
				//pick only numeric columns to be sent to R
				for(var i:int =0 ; i < colObjects.length; i++)
				{
					var col:IAttributeColumn = (colObjects[i] as IAttributeColumn);
					var dataType:String = ColumnUtils.getDataType(col);			
					if (dataType == "number")
					{
						numericCols.push(col);
						columnNames.push(ColumnUtils.getTitle(col));
					}
				}				
				//joining columns returns columns only complete records (no incomplete records)
				var joinedColumns:Array = joinColumns(numericCols);				
				joinKeysRArray = joinedColumns[0];
				joinColsRArray = joinedColumns[1];				
				//todo: getting axis, title, color, scale, etc
				
			
				if(joinColsRArray[0].length < 2)
				{
					if(!firstTimeDone && DisabilityEnabled)
						StartSegmentation();
					
					else if(DisabilityEnabled && progressLabel.text == "Finished.")
					{
						
						StartSegmentation();
						progressLabel.text = "Ready";
					}
					
					else if(joinColsRArray.length == 0)
					{
						NoMoreData = true;
						automaticToolDescTextBox.text = "No data on the Line chart";
					}
				}
				
				else
				{
					
					MultipleLineExplention();
					
					
				}
				
			}
			
			
			
			private function MultipleLineExplention():void
			{
				var summarySegmentValues:Array = new Array();
				for(var init:int = 0; init < joinColsRArray[0].length ; init++) // create as many arrays as there are line charts
					summarySegmentValues.push(new Array());
				
			
				for(var i:int =0 ; i < joinColsRArray.length ; i++)
				{
					
					for(var j:int = 0; j < joinColsRArray[i].length ; j++)
					{
						summarySegmentValues[j].push(joinColsRArray[i][j]);
					}
					
				}
				mSegmentAnalyser = new SegmentSummaryAnalyzer();
				
				mSegmentAnalyser.mDisability = this;
				
				for(init = 0; init < summarySegmentValues.length ; init++)
				{
					var tmpSummarySeg:SummarySegment = new SummarySegment();	
					tmpSummarySeg.setValuesIndex(summarySegmentValues[init], init);
					
					mSegmentAnalyser.addSegmentSummary(tmpSummarySeg);
				}
				
				mSegmentAnalyser.Analayse();
				
			}
			
			public function registerMultipleSegmentAnalysis():void
			{
				automaticToolDescTextBox.text = "";
				var counter:Array = new Array();
				var types:Array = new Array();
				var increasing:Array = new Array();
				var Decreasing:Array = new Array();
				var found:Boolean = false;
				counter.push(1);
				types.push(mSegmentAnalyser.getSummarySegments()[0].getAnalysis());// doesnt enter the for loop if there is othing in it
				if( mSegmentAnalyser.getSummarySegments()[0].getDataValues()[0] < mSegmentAnalyser.getSummarySegments()[0].getDataValues()[mSegmentAnalyser.getSummarySegments()[0].getDataValues().length -1])
				{
					increasing.push(1);
					Decreasing.push(0);
				}
				else
				{
					Decreasing.push(1);
					increasing.push(0);
				}
				
				for(var i:int = 1; i < mSegmentAnalyser.getSummarySegments().length ; i++)
				{
					found = false;
					
					for(var j:int= 0 ; j < types.length ; j++)
					{
						if(mSegmentAnalyser.getSummarySegments()[i].getAnalysis() == types[j])
						{
							counter[j]++;
							found = true;
							if( mSegmentAnalyser.getSummarySegments()[i].getDataValues()[0] < mSegmentAnalyser.getSummarySegments()[i].getDataValues()[mSegmentAnalyser.getSummarySegments()[i].getDataValues().length -1])
							{
								increasing[j]++;
							}
							else
								Decreasing[j]++;
							
							break;
						}
						
					}
					if(!found)
					{
					
						counter.push(1);
						types.push(mSegmentAnalyser.getSummarySegments()[i].getAnalysis());
						if( mSegmentAnalyser.getSummarySegments()[i].getDataValues()[0] < mSegmentAnalyser.getSummarySegments()[i].getDataValues()[mSegmentAnalyser.getSummarySegments()[i].getDataValues().length -1])
						{
							increasing.push(1);
							Decreasing.push(0);
						}
						else
						{
							Decreasing.push(1);
							increasing.push(0);
						}
					}
				
					
				}
				automaticToolDescTextBox.text += "There are " + mSegmentAnalyser.getSummarySegments().length + " line graphs, ";
				for(var k:int= 0 ; k < types.length ; k++)
				{
					if(counter[k] > 1)
						automaticToolDescTextBox.text += counter[k] + " of the graphs are " + types[k] +" shaped. ";
					else if(counter[k] == 1)
						automaticToolDescTextBox.text += counter[k] + " of the graph is " + types[k] +" shaped. ";
					if(increasing[k] > 0)
					{
						if(increasing[k] > 1 && increasing[k] != counter[k])
							automaticToolDescTextBox.text += increasing[k] + " of them are increasing. ";
						else if(counter[k] == 1)
							automaticToolDescTextBox.text += "It is increasing. ";
						else if(increasing[k] == counter[k])
							automaticToolDescTextBox.text += "They are all increasing. ";
						
					}
					if(Decreasing[k] > 0)
					{
						if(Decreasing[k] > 1 && Decreasing[k] != counter[k])
						{
							
							automaticToolDescTextBox.text += "and," + Decreasing[k] + " of them are decreasing. ";
							
						}
						else if(counter[k] == 1)
							automaticToolDescTextBox.text += "It is decreasing. ";
						else if(Decreasing[k] == counter[k])
							automaticToolDescTextBox.text += "They are all decreasing. ";
						
						
						
					}
				}
			}
			
			private function joinColumns(columns:Array):Array
			{
				
				var selection:KeySet = Weave.defaultSelectionKeySet;
				var keys:Array = selection.keys.length > 0 ? selection.keys : null;
				//make dataype Null, so that columns will be sent as exact dataype to R
				//if mentioned as String or NUmber ,will convert all columns to String or Number .
				var result:Array = ColumnUtils.joinColumns(columns,null, false, keys);
				return [result.shift(), result];
			}
			
			private function StartSegmentation():void
			{
				var firstSegment:Array = new Array();
				progressLabel.text = "processing.. 0%";
				automaticToolDescTextBox.text = "Please wait while the graph is analyzed..";
				Weave.properties.disabilitySystemText.value = "Processing.";
				firstTimeDone = true;
				trace("\n");
				trace("start");
				
				for (var i:int = 0; i<joinColsRArray.length; i++)
				{
					firstSegment.push(joinColsRArray[i][0].valueOf());
					
					
					//reportError(joinColsRArray);
				}
				
				if(firstSegment.length > 0)
				{
					initialSegment = new SegmentValue();
					initialSegment.segmentIndices = new Array(0, firstSegment.length);
					initialSegment.setSegment(firstSegment);
					initialSegment.mDisability = this;
					initSegmentIndices = initialSegment.segmentIndices;
					firstSegLength = firstSegment.length;
					
					initialSegment.getValues();
				}
				
			}
			
			//runs test for decision tree
			public function runsTest(mSegment:SegmentValue):void
			{
				var yRegValues:Array = new Array();
				var residual:Array = new Array();
				var posRes:int = new int(); //positive residual
				var standardDV:Number = new Number();
				var runsMean:Number =new Number();
				
				for(var i:int=0; i<mSegment.Segment.length; i++)
				{
					yRegValues[i] = mSegment.intercept + (mSegment.slope * i);
					residual[i] = mSegment.Segment[i] - yRegValues[i];
					
					if(residual[i] < 0) 
						mSegment.actualRunsNum++;				
					else 
						posRes++		
				}
				
				runsMean = ((2*mSegment.actualRunsNum*posRes)/(mSegment.actualRunsNum + posRes)) + 1;
				standardDV = ((2*mSegment.actualRunsNum*posRes)*(2*mSegment.actualRunsNum*posRes - mSegment.actualRunsNum - posRes))/((mSegment.actualRunsNum+posRes)*(mSegment.actualRunsNum+posRes)*(mSegment.actualRunsNum+posRes-1));
				
				mSegment.diffAM = (mSegment.actualRunsNum - runsMean)/runsMean;
				
				if(mSegment.actualRunsNum > (runsMean-standardDV)) 
					mSegment.runsTestB = false;
				else
					mSegment.runsTestB = true;			
			}
			
			
			public function shouldSplit(mSegment:SegmentValue):Boolean
			{
				runsTest(mSegment);
				return LineChartDecisionTree.getInstance().lineChartDT(mSegment.Segment,mSegment.corr, mSegment.fTests, mSegment.Segment.length / firstSegLength, mSegment.diffAM, mSegment.Segment.length, firstSegLength, mSegment.actualRunsNum, false, mSegment.runsTestB);
				
			}
			
			
			private function splitWithR(mSegment:SegmentValue):void
			{
				// get values first
				
			}
			
			public function splitComplete():void
			{
				var start:Boolean = false;
				var end:Boolean = false;
				var sum:int = 0;
				for(var i:int=0; i< splittedSegments.length; i++)
				{
					sum += splittedSegments[i][1] - splittedSegments[i][0];
					
					
					/*
					if(splittedSegments[i][0] == 0)
					{
					//trace("segment start: " + splittedSegments[i][0] + "   end: "+ (splittedSegments[i][1] - 1));
					start = true;
					
					trace("segment start: " + splittedSegments[i][0] + "   end: "+ (splittedSegments[i][1]));
					}
					else
					{
					//trace("segment start: " + (splittedSegments[i][0]-1) + "   end: "+ (splittedSegments[i][1] - 1));	
					trace("segment start: " + splittedSegments[i][0] + "   end: "+ (splittedSegments[i][1]));
					}
					*/
				}
				
				
				progressLabel.text = "processing.. " + Math.floor((sum / initSegmentIndices[1]) * 100) + "%";
				if(sum == initSegmentIndices[1])
				{
					trace("finished");
					trace("Line chart splitted into " + splittedSegments.length + " segments");
					splittedSegments.sortOn("0", Array.NUMERIC);
					for(var m:int=0; m< splittedSegments.length; m++)
					{			
						
						if(splittedSegments[m][1] == initialSegment.Segment.length)
						{
							//trace("segment start: " + splittedSegments[i][0] + "   end: "+ (splittedSegments[i][1] - 1));
							start = true;
							
							
							splittedSegments[m][1] = splittedSegments[m][1] - 1;
						}
						else
						{
							//trace("segment start: " + (splittedSegments[i][0]-1) + "   end: "+ (splittedSegments[i][1] - 1));	
							//trace("segment start: " + splittedSegments[i][0] + "   end: "+ (splittedSegments[i][1]));
							//	splittedSegments[me][0] = splittedSegments[me][0] - 1;
							//	splittedSegments[me][1] = splittedSegments[me][1] - 1;
						}
						
						trace("segment no: "+ (m+1) +", start: " + splittedSegments[m][0] + "   end: "+ (splittedSegments[m][1]));
						
					}
					
					
					
					//ProduceSentence
					
					ProduceSentence(initialSegment.Segment, splittedSegments);
					progressLabel.text = "Finished.";
					automaticDescRefreshButton.enabled = false;
				}
				
			}
			
			
			public function split(mSegment:SegmentValue):void
			{
				//trace("aa");
				
				
				if(!shouldSplit(mSegment))
				{
					splittedSegments.push(mSegment.segmentIndices);
					
					
					//if(segmentsLeftToSplit ==0)
					splitComplete();
					
					
					//trace("splitted segments , " + splittedSegments);
				}
				else
				{
					if(mSegment.segmentIndices[0] == 16)
					{
						trace("mee");
					}
					var newSegments:Array = splitSegment(mSegment);
					var Segment1:SegmentValue = new SegmentValue();
					var Segment2:SegmentValue = new SegmentValue();
					
					segmentsLeftToSplit +=2;
					Segment1.segmentIndices = newSegments[1];
					Segment1.setSegment(newSegments[0]);
					Segment1.mDisability = initialSegment.mDisability;
					
					Segment2.segmentIndices = newSegments[3];
					Segment2.setSegment(newSegments[2]);
					Segment2.mDisability = initialSegment.mDisability;
					
					if(Segment1.Segment != null)
						Segment1.split();
					if(Segment2.Segment != null)
						Segment2.split();
					//segment1
					//segment2
					
				}
				
			}
			
			public function splitSegment(mSegment:SegmentValue):Array
			{
				
				var startPoint:Array = new Array(mSegment.segmentIndices[0],mSegment.Segment[0]);
				var endPoint:Array = new Array(mSegment.segmentIndices[1],mSegment.Segment[mSegment.Segment.length -1]);
				var resultSegment:Array = new Array();
				var maxVD:Number = -1;
				var maxVDIndex:int = 0;
				var currVD:Number = -1;
				var first:Array = new Array();
				var secondSegment:Array = new Array();
				var firstIndices:Array = new Array();
				var secondIndices:Array = new Array();
				
				for(var i:int = mSegment.segmentIndices[0]; i < mSegment.segmentIndices[1] ; i++)
				{
					currVD = verticalDistance(startPoint, endPoint, new Array(i, initialSegment.Segment[i])); //mSegment.Segment
					if(currVD > maxVD)
					{
						maxVD = currVD;
						maxVDIndex = i;
					}
				}		
				
				for(i = mSegment.segmentIndices[0]; i < maxVDIndex ; i++)
				{
					first.push(initialSegment.Segment[i]);	
				}
				
				for(i = maxVDIndex; i < mSegment.segmentIndices[1] ; i++)
				{
					secondSegment.push(initialSegment.Segment[i]);	
				}
				firstIndices.push(mSegment.segmentIndices[0]);
				//trace(maxVDIndex);
				firstIndices.push(maxVDIndex);
				secondIndices.push(maxVDIndex);
				secondIndices.push(mSegment.segmentIndices[1]);
				
				
				resultSegment.push(first);
				resultSegment.push(firstIndices);
				
				resultSegment.push(secondSegment);
				resultSegment.push(secondIndices);
				
				
				return resultSegment;
				
			}
			//vertical distance is to find farthest point from the imaginary line between two ends points of the line graph 
			public function verticalDistance(startPoint:Array, endPoint:Array, measuredPoint:Array):Number
			{
				return Math.abs((startPoint[1] + ((endPoint[1] - startPoint[1]) * ((measuredPoint[0] - startPoint[0]) / (endPoint[0] - startPoint[0]))) - measuredPoint[1]));
			}
			
			
			
			
			public function ProduceSentence(initSeg:Array, splitIndices:Array):void
			{
				
				var ExplanationSentence:String = "";
				var SegmentAngles:Array = new Array();//segment angles for calculating how sharp the segment grows
				var lastSpike:Array = new Array();
				var spikeAvgAngle:Array = new Array();
				
				for(var k:int = 0; k < splitIndices.length ; k++)
				{
					var avgAngle:Number = 0;
					var currAngle:Number = 0;
					
					//avgAngle += curAng;
					//trace(curAng);
					avgAngle = 0;
					
					// check if the graph spikes down or up at the end of segment
					for(var j:int = splitIndices[k][0]; j < (splitIndices[k][1] - 1) ; j++)
					{
						currAngle = CalcAngle(initSeg[j], initSeg[j + 1],  1);
						avgAngle += currAngle;
						
						
					}
					avgAngle = avgAngle / (Math.abs(splitIndices[k][1] - splitIndices[k][0]) - 1);
					currAngle = CalcAngle(initSeg[splitIndices[k][0]], initSeg[splitIndices[k][1]], Math.abs(initSeg[splitIndices[k][1]] - initSeg[splitIndices[k][0]]));
					if(currAngle < avgAngle - 65)
					{
						lastSpike.push(-1);
						spikeAvgAngle.push(avgAngle);
					}
					else if(currAngle > avgAngle + 65)
					{
						lastSpike.push(1);
						spikeAvgAngle.push(avgAngle);
					}
					else
					{
						lastSpike.push(0);
						spikeAvgAngle.push(0);
					}
					
					currAngle = CalcAngle(initSeg[splitIndices[k][0]], initSeg[splitIndices[k][1]], (splitIndices[k][1] - splitIndices[k][0]));
					//SegmentAngles.push(avgAngle / Math.abs(initSeg[splitIndices[i][1]] - initSeg[splitIndices[i][0]]));
					SegmentAngles.push(currAngle);
				}
				trace("Segment angles; " + SegmentAngles);
				ExplanationSentence = "This image is a line chart. The line chart displays " +initSeg.length+" data points and shows " + SegmentAngles.length + " major trends. ";
				
				for(var i:int = 0; i < SegmentAngles.length ; i++)
				{
					ExplanationSentence += "The " + OrderArray[i] + " segment ";
					if(spikeAvgAngle[i] != 0)
						SegmentAngles[i] = spikeAvgAngle[i];
					
					
					if(SegmentAngles[i] < 0)
					{
						
						for(var p:int = 0 ; p < disabilityMessages.messageContainer.length ; p++)
						{
							if(SegmentAngles[i] >= disabilityMessages.messageContainer[p].minAngle)
							{
								ExplanationSentence += disabilityMessages.messageContainer[p].messageDec;
								break;
							}
						}
						
					}
					else
					{
						for(p = 0 ; p < disabilityMessages.messageContainer.length ; p++)
						{
							if(SegmentAngles[i] <= disabilityMessages.messageContainer[p].maxAngle)
							{
								ExplanationSentence += disabilityMessages.messageContainer[p].messageInc;
								break;
							}
						}
					}
					
					
					if(lastSpike[i] == 1)
					{
						ExplanationSentence += " "+initSeg[splitIndices[i][0]] +" to "+initSeg[splitIndices[i][1]]+ ". There is a single point sharp increase at the end. This segment begins at " + columnNames[splitIndices[i][0]] + " and ends at " + columnNames[splitIndices[i][1]] + ". " ;
					}
					else if(lastSpike[i] == -1)
					{
						ExplanationSentence += " "+initSeg[splitIndices[i][0]] +" to "+initSeg[splitIndices[i][1]]+". There is a single point sharp fall at the end. This segment starts at " +columnNames[splitIndices[i][0]] + " and ends at " + columnNames[splitIndices[i][1]]  + ". " ;
					}
					else if(lastSpike[i] == 0)
					{
						//ExplanationSentence += ". Starts at "+ initSeg[splitIndices[i][0]] + " and ends at " + initSeg[splitIndices[i][1]] + ". "  ;
						ExplanationSentence += initSeg[splitIndices[i][0]] +" to "+initSeg[splitIndices[i][1]]+". This segment begins at "+ columnNames[splitIndices[i][0]] + " and ends at " + columnNames[splitIndices[i][1]] + ". "  ;

					}
					
				}
				
				if(initSeg[0] > initSeg[initSeg.length -1])
				{
					ExplanationSentence +=  "Overall, from the first point to the last point, the y axis value on this line chart falls ";
				}
				else
				{
					ExplanationSentence +=  "Overall, from the first point to the last point, the y axis value on this line chart rises ";
				}
				ExplanationSentence +=  " from " + initSeg[0] + " to " + initSeg[initSeg.length -1] + ".";
				
				if(!NoMoreData)
				{
				automaticToolDescTextBox.text = ExplanationSentence;
				Weave.properties.disabilitySystemText.value = ExplanationSentence;
				}
				else
				{
					automaticToolDescTextBox.text = "No data on the Line chart";
					Weave.properties.disabilitySystemText.value ="No data on the Line chart";
				}
				
			}
			
			public function CalcAngle(start:Number, end:Number, distance:int):Number
			{
				var VertDis:Number = end - start;
				var HipoVal:Number = Math.sqrt((VertDis * VertDis) + (distance * distance));
				var sinVal:Number = VertDis / HipoVal;
				
				var degree:Number = degFromRad(Math.asin(sinVal));
				return degree;
				
			}
			
			public function degFromRad( p_radInput:Number ):Number
			{
				var degOutput:Number = ( 180 / Math.PI ) * p_radInput;
				return degOutput;
			}
			
			private var OrderArray:Array = new Array("first",
				"second",
				"third",
				"fourth",
				"fifth",
				"sixth",
				"seventh",
				"eighth",
				"ninth",
				"tenth",
				"eleventh",
				"twelfth",
				"thirteenth",
				"fiftfourteenth",
				"fifteenth",
				"sixteenth",
				"seventeenth",
				"eighteenth",
				"nineteenth",
				"twentieth",
				"twenty first",
				"twenty second",
				"twenty third",
				"twenty fourth",
				"twenty fifth",
				"twenty sixth",
				"twenty seventh",
				"twenty eighth",
				"twenty ninth");
			
			
			
		]]>
	</mx:Script>
</mx:VBox>