/*
    Weave (Web-based Analysis and Visualization Environment)
    Copyright (C) 2008-2011 University of Massachusetts Lowell

    This file is a part of Weave.

    Weave is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License, Version 3,
    as published by the Free Software Foundation.

    Weave is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Weave.  If not, see <http://www.gnu.org/licenses/>.
*/

package weave.visualization.layers
{
	import flash.display.Bitmap;
	import flash.geom.Point;
	import flash.geom.Rectangle;
	import flash.utils.Dictionary;
	
	import weave.Weave;
	import weave.api.WeaveAPI;
	import weave.api.core.ILinkableObject;
	import weave.api.data.IKeySet;
	import weave.api.data.IQualifiedKey;
	import weave.api.data.ISimpleGeometry;
	import weave.api.getCallbackCollection;
	import weave.api.newDisposableChild;
	import weave.api.newLinkableChild;
	import weave.api.primitives.IBounds2D;
	import weave.api.registerDisposableChild;
	import weave.api.registerLinkableChild;
	import weave.api.reportError;
	import weave.api.setSessionState;
	import weave.api.ui.IPlotter;
	import weave.compiler.StandardLib;
	import weave.core.LinkableBoolean;
	import weave.core.LinkableHashMap;
	import weave.core.LinkableNumber;
	import weave.core.LinkableString;
	import weave.core.SessionManager;
	import weave.primitives.Bounds2D;
	import weave.primitives.ZoomBounds;
	import weave.utils.NumberUtils;
	import weave.utils.PlotterUtils;
	import weave.utils.SpatialIndex;
	import weave.utils.ZoomUtils;

	/**
	 * This is a container for a list of PlotLayers
	 * 
	 * @author adufilie
	 */
	public class ViewManager implements ILinkableObject
	{
		public function ViewManager()
		{
			// zoom depends on plotters and layerSettings
			plotters.addImmediateCallback(this, updateZoom);
			layerSettings.addImmediateCallback(this, updateZoom);
			
			plotters.childListCallbacks.addImmediateCallback(this, handlePlottersList);
			layerSettings.childListCallbacks.addImmediateCallback(this, handleSettingsList);
			
			(WeaveAPI.SessionManager as SessionManager).excludeLinkableChildFromSessionState(this, marginBottomNumber);
			(WeaveAPI.SessionManager as SessionManager).excludeLinkableChildFromSessionState(this, marginTopNumber);
			(WeaveAPI.SessionManager as SessionManager).excludeLinkableChildFromSessionState(this, marginLeftNumber);
			(WeaveAPI.SessionManager as SessionManager).excludeLinkableChildFromSessionState(this, marginRightNumber);
		}
		
		/**
		 * This bitmap contains the graphics generated by the plotters.
		 */		
		public const bitmap:Bitmap = new Bitmap(null, 'auto', true);
		
		public const plotters:LinkableHashMap = registerLinkableChild(this, new LinkableHashMap(IPlotter));
		public const layerSettings:LinkableHashMap = registerLinkableChild(this, new LinkableHashMap(LayerSettings));
		public const zoomBounds:ZoomBounds = newLinkableChild(this, ZoomBounds, updateZoom, false); // must be immediate callback to avoid displaying a stretched map, for example
		
		//These variables hold the numeric values of the margins. They are removed from the session state after the values are set
		//This was done to support percent values
		public const marginRightNumber:LinkableNumber = registerLinkableChild(this, new LinkableNumber(0), updateZoom, true);
		public const marginLeftNumber:LinkableNumber = registerLinkableChild(this, new LinkableNumber(0), updateZoom, true);
		public const marginTopNumber:LinkableNumber = registerLinkableChild(this, new LinkableNumber(0), updateZoom, true);
		public const marginBottomNumber:LinkableNumber = registerLinkableChild(this, new LinkableNumber(0), updateZoom, true);
		
		//These values take a string which could be a number value or a percentage value. The string is evaluated and 
		//the above set of margin values (marginTopNumber, margingBottomNumber...) are set with the correct numeric value
		public const marginRight:LinkableString = registerLinkableChild(this, new LinkableString('0', NumberUtils.verifyNumberOrPercentage), updateZoom, true);
		public const marginLeft:LinkableString = registerLinkableChild(this, new LinkableString('0', NumberUtils.verifyNumberOrPercentage), updateZoom, true);
		public const marginTop:LinkableString = registerLinkableChild(this, new LinkableString('0', NumberUtils.verifyNumberOrPercentage), updateZoom, true);
		public const marginBottom:LinkableString = registerLinkableChild(this, new LinkableString('0', NumberUtils.verifyNumberOrPercentage), updateZoom, true);
		
		public const minScreenSize:LinkableNumber = registerLinkableChild(this, new LinkableNumber(128), updateZoom, true);
		public const minZoomLevel:LinkableNumber = registerLinkableChild(this, new LinkableNumber(0), updateZoom, true);
		public const maxZoomLevel:LinkableNumber = registerLinkableChild(this, new LinkableNumber(16), updateZoom, true);
		public const enableFixedAspectRatio:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(false), updateZoom, true);
		public const enableAutoZoomToExtent:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(true), updateZoom, true);
		public const enableAutoZoomToSelection:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(false), updateZoom, true);
		public const includeNonSelectableLayersInAutoZoom:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(false), updateZoom, true);

		public const overrideXMin:LinkableNumber = registerLinkableChild(this, new LinkableNumber(NaN), updateZoom, true);
		public const overrideYMin:LinkableNumber = registerLinkableChild(this, new LinkableNumber(NaN), updateZoom, true);
		public const overrideXMax:LinkableNumber = registerLinkableChild(this, new LinkableNumber(NaN), updateZoom, true);
		public const overrideYMax:LinkableNumber = registerLinkableChild(this, new LinkableNumber(NaN), updateZoom, true);
		
		/**
		 * This is the collective data bounds of all the selectable plot layers.
		 */
		public const fullDataBounds:IBounds2D = new Bounds2D();
		
		private var _unscaledWidth:uint = 0;
		private var _unscaledHeight:uint = 0;
		
		// reusable temporary objects
		private const tempPoint:Point = new Point();
		private const tempBounds:IBounds2D = new Bounds2D();
		private const tempScreenBounds:IBounds2D = new Bounds2D();
		private const tempDataBounds:IBounds2D = new Bounds2D();
		
		private var _name_to_PlotTask_Array:Object = {}; // name -> Array of PlotTask
		private var _name_to_SpatialIndex:Object = {}; // name -> SpatialIndex
		
		/**
		 * This function gets called by updateZoom and updates fullDataBounds.
		 */
		protected function updateFullDataBounds():void
		{
			tempBounds.copyFrom(fullDataBounds);
			fullDataBounds.reset();

			for each (var name:String in plotters.getNames(IPlotter))
			{
				var settings:LayerSettings = layerSettings.getObject(name) as LayerSettings;
				
				// skip excluded layers
				if (!includeNonSelectableLayersInAutoZoom.value && !settings.selectable.value)
					continue;
				
				// skip invisible layers
				if (!settings.visible.value)
					continue;
				
				var spatialIndex:SpatialIndex = _name_to_SpatialIndex[name] as SpatialIndex;
				fullDataBounds.includeBounds(spatialIndex.collectiveBounds);
			}
			if (!tempBounds.equals(fullDataBounds))
			{
				//trace('fullDataBounds changed',ObjectUtil.toString(fullDataBounds));
				getCallbackCollection(this).triggerCallbacks();
			}
		}
		
		/**
		 * This function will update the fullDataBounds and zoomBounds based on the current state of the layers.
		 */
		protected function updateZoom():void
		{
			// make sure callbacks only trigger once
			getCallbackCollection(this).delayCallbacks();
			getCallbackCollection(zoomBounds).delayCallbacks();
			//trace('begin updateZoom',ObjectUtil.toString(getSessionState(zoomBounds)));
			
			// make sure numeric margin values are correct
			marginBottomNumber.value = Math.round(NumberUtils.getNumberFromNumberOrPercent(marginBottom.value, _unscaledHeight));
			marginTopNumber.value = Math.round(NumberUtils.getNumberFromNumberOrPercent(marginTop.value, _unscaledHeight));
			marginLeftNumber.value = Math.round(NumberUtils.getNumberFromNumberOrPercent(marginLeft.value, _unscaledWidth));
			marginRightNumber.value = Math.round(NumberUtils.getNumberFromNumberOrPercent(marginRight.value, _unscaledWidth));
			
			updateFullDataBounds();
			
			// calculate new screen bounds in temp variable
			// default behaviour is to set screenBounds beginning from lower-left corner and ending at upper-right corner
			var left:Number = marginLeftNumber.value;
			var top:Number = marginTopNumber.value;
			var right:Number = _unscaledWidth - marginRightNumber.value;
			var bottom:Number = _unscaledHeight - marginBottomNumber.value;
			// set screenBounds beginning from lower-left corner and ending at upper-right corner
			//TODO: is other behavior required?
			tempScreenBounds.setBounds(left, bottom, right, top);
			if (left > right)
				tempScreenBounds.setWidth(0);
			if (top > bottom)
				tempScreenBounds.setHeight(0);
			// copy current dataBounds to temp variable
			zoomBounds.getDataBounds(tempDataBounds);
			
			// determine if dataBounds should be zoomed to fullDataBounds
			if (enableAutoZoomToExtent.value || tempDataBounds.isUndefined())
			{
				if (!fullDataBounds.isEmpty())
				{
					tempDataBounds.copyFrom(fullDataBounds);
					if (isFinite(overrideXMin.value))
						tempDataBounds.setXMin(overrideXMin.value);
					if (isFinite(overrideXMax.value))
						tempDataBounds.setXMax(overrideXMax.value);
					if (isFinite(overrideYMin.value))
						tempDataBounds.setYMin(overrideYMin.value);
					if (isFinite(overrideYMax.value))
						tempDataBounds.setYMax(overrideYMax.value);
					if (enableFixedAspectRatio.value)
					{
						var xScale:Number = tempDataBounds.getWidth() / tempScreenBounds.getXCoverage();
						var yScale:Number = tempDataBounds.getHeight() / tempScreenBounds.getYCoverage();
						// keep greater data-to-pixel ratio because we want to zoom out if necessary
						if (xScale > yScale)
							tempDataBounds.setHeight(tempScreenBounds.getYCoverage() * xScale);
						if (yScale > xScale)
							tempDataBounds.setWidth(tempScreenBounds.getXCoverage() * yScale);
					}
				}
			}
			
			var overrideBounds:Boolean = isFinite(overrideXMin.value) || isFinite(overrideXMax.value)
										|| isFinite(overrideYMin.value) || isFinite(overrideYMax.value);
			if (!tempScreenBounds.isEmpty() && !overrideBounds)
			{
				//var minSize:Number = Math.min(minScreenSize.value, tempScreenBounds.getXCoverage(), tempScreenBounds.getYCoverage());
				
				if (!tempDataBounds.isUndefined() && !fullDataBounds.isUndefined())
				{
					// Enforce pan restrictions on tempDataBounds.
					// Center of visible dataBounds should be a point inside fullDataBounds.
					fullDataBounds.constrainBoundsCenterPoint(tempDataBounds);
				}
			}
			
			// save new bounds
			zoomBounds.setBounds(tempDataBounds, tempScreenBounds, enableFixedAspectRatio.value);
			if (enableAutoZoomToSelection.value)
				zoomToSelection();
			
			getCallbackCollection(zoomBounds).resumeCallbacks();
			getCallbackCollection(this).resumeCallbacks();
		}
		
		/**
		 * This function will zoom the visualization to the bounds corresponding to a list of keys.
		 * @param keys An Array of IQualifiedKey objects, or null to get them from the current selection.
		 * @param zoomMarginPercent The percent of width and height to reserve for space around the zoomed area.
		 */
		public function zoomToSelection(keys:Array = null, zoomMarginPercent:Number = 0.2):void
		{
			if (!keys)
			{
				var selection:IKeySet = Weave.defaultSelectionKeySet;
				var probe:IKeySet = Weave.defaultProbeKeySet;
				var alwaysHighlight:IKeySet = Weave.alwaysHighlightKeySet;
				keys = selection.keys;
				if (keys.length == 0)
					keys = probe.keys;
				if (keys.length == 0)
					keys = alwaysHighlight.keys;
			}
			
			// get the bounds containing all the records on all the layers
			tempBounds.reset();
			var names:Array = plotters.getNames(IPlotter);
			for each (var key:* in keys)
			{
				// support for generic objects coming from JavaScript
				if (!(key is IQualifiedKey))
					key = WeaveAPI.QKeyManager.getQKey(key.keyType, key.localName);
				
				for each (var name:String in names)
				{
					var spatialIndex:SpatialIndex = _name_to_SpatialIndex[name] as SpatialIndex;
					var boundsArray:Array = spatialIndex.getBoundsFromKey(key);
					for each (var bounds:IBounds2D in boundsArray)
						tempBounds.includeBounds(bounds);
				}
			}
			
			// make sure callbacks only trigger once.
			getCallbackCollection(zoomBounds).delayCallbacks();
			
			// zoom to that bounds, expanding the area to keep the fixed aspect ratio
			// if tempBounds is undefined and enableAutoZoomToExtent is enabled, this will zoom to the full extent.
			zoomBounds.setDataBounds(tempBounds, true);
			
			// zoom out to include the specified margin
			zoomBounds.getDataBounds(tempBounds);
			var scale:Number = 1 / (1 - zoomMarginPercent);
			tempBounds.setWidth(tempBounds.getWidth() * scale);
			tempBounds.setHeight(tempBounds.getHeight() * scale);
			zoomBounds.setDataBounds(tempBounds);
			
			getCallbackCollection(zoomBounds).resumeCallbacks();
		}

		/**
		 * This function gets the current zoom level as defined in ZoomUtils.
		 * @return The current zoom level.
		 * @see weave.utils.ZoomUtils#getZoomLevel
		 */
		public function getZoomLevel():Number
		{
			zoomBounds.getDataBounds(tempDataBounds);
			zoomBounds.getScreenBounds(tempScreenBounds);
			var minSize:Number = Math.min(minScreenSize.value, tempScreenBounds.getXCoverage(), tempScreenBounds.getYCoverage());
			var zoomLevel:Number = ZoomUtils.getZoomLevel(tempDataBounds, tempScreenBounds, fullDataBounds, minSize);
			return zoomLevel;
		}
		
		/**
		 * This function sets the zoom level as defined in ZoomUtils.
		 * @param newZoomLevel The new zoom level.
		 * @see weave.utils.ZoomUtils#getZoomLevel
		 */
		public function setZoomLevel(newZoomLevel:Number):void
		{
			var currentZoomLevel:Number = getZoomLevel();
			var newConstrainedZoomLevel:Number = StandardLib.constrain(newZoomLevel, minZoomLevel.value, maxZoomLevel.value);
			if (newConstrainedZoomLevel != currentZoomLevel)
			{
				var scale:Number = 1 / Math.pow(2, newConstrainedZoomLevel - currentZoomLevel);
				if (!isNaN(scale) && scale != 0)
				{
					zoomBounds.getDataBounds(tempDataBounds);
					tempDataBounds.setWidth(tempDataBounds.getWidth() * scale);
					tempDataBounds.setHeight(tempDataBounds.getHeight() * scale);
					zoomBounds.setDataBounds(tempDataBounds);
				}
			}
		}
		
		/**
		 * This function will get all the unique keys that overlap each geometry specified by
		 * simpleGeometries. 
		 * @param simpleGeometries
		 * @return An array of keys.
		 */		
		public function getKeysOverlappingGeometry(simpleGeometries:Array):Array
		{
			var key:IQualifiedKey;
			var keys:Dictionary = new Dictionary();
			var simpleGeometry:ISimpleGeometry;
			var names:Array = plotters.getNames();
			
			// Go through the layers and make a query for each layer
			for each (var name:String in names)
			{
				var spatialIndex:SpatialIndex = _name_to_SpatialIndex[name] as SpatialIndex;
				for each (simpleGeometry in simpleGeometries)
				{
					var queriedKeys:Array = spatialIndex.getKeysGeometryOverlapGeometry(simpleGeometry);
					// use the dictionary to handle duplicates
					for each (key in queriedKeys)
					{
						keys[key] = true;
					}
				}
			}
			
			var result:Array = [];
			for (var keyObj:* in keys)
				result.push(keyObj as IQualifiedKey);
			
			return result;
		}
		
		private function handleSettingsList():void
		{
			// when settings are removed, remove plotter
			var oldName:String = layerSettings.childListCallbacks.lastNameRemoved;
			plotters.removeObject(oldName);
		}
		
		private function handlePlottersList():void
		{
			// when plotter is removed, remove settings
			var oldName:String = plotters.childListCallbacks.lastNameRemoved;
			if (oldName)
			{
				delete _name_to_SpatialIndex[oldName];
				delete _name_to_PlotTask_Array[oldName];
				layerSettings.removeObject(oldName);
			}
			
			var newName:String = plotters.childListCallbacks.lastNameAdded;
			if (newName)
			{
				var newPlotter:IPlotter = plotters.childListCallbacks.lastObjectAdded as IPlotter;
				var settings:LayerSettings = layerSettings.requestObject(newName, LayerSettings, false);
				var spatialIndex:SpatialIndex = _name_to_SpatialIndex[newName] = newDisposableChild(newPlotter, SpatialIndex);
				var tasks:Array = _name_to_PlotTask_Array[newName] = [];
				for each (var taskType:int in [PlotTask.TASK_TYPE_SUBSET, PlotTask.TASK_TYPE_SELECTION, PlotTask.TASK_TYPE_PROBE])
				{
					var plotTask:PlotTask = new PlotTask(taskType, newPlotter, spatialIndex, zoomBounds, settings);
					registerDisposableChild(newPlotter, plotTask);
					tasks.push(plotTask);
					
					// when the plot task triggers callbacks, we need to render the layered visualization
					getCallbackCollection(plotTask).addImmediateCallback(this, renderLayers);
				}
			}
		}
		
		/**
		 * This function must be called to change the size of the bitmap data.
		 */
		public function setBitmapDataSize(unscaledWidth:uint, unscaledHeight:uint):void
		{
			if (_unscaledWidth != unscaledWidth || _unscaledHeight != unscaledHeight)
			{
				_unscaledWidth = unscaledWidth;
				_unscaledHeight = unscaledHeight;
				
				updateZoom();
				
				for each (var name:String in plotters.getNames(IPlotter))
				{
					for each (var plotTask:PlotTask in _name_to_PlotTask_Array[name])
					{
						plotTask.setBitmapDataSize(_unscaledWidth, _unscaledHeight);
					}
				}
			}
		}
		
		/**
		 * This gets called when a PlotTask triggers its callbacks.
		 */
		private function renderLayers():void
		{
			try
			{
				PlotterUtils.setBitmapDataSize(bitmap, _unscaledWidth, _unscaledHeight);
				
				var origin:Point = new Point(0,0);
				var rect:Rectangle = bitmap.bitmapData.rect;
				for each (var name:String in plotters.getNames(IPlotter))
				{
					var settings:LayerSettings = layerSettings.getObject(name) as LayerSettings;
					for each (var task:PlotTask in _name_to_PlotTask_Array[name])
					{
						// don't render if plot task is busy
						if (WeaveAPI.SessionManager.linkableObjectIsBusy(task))
							continue;
						
						if (task.buffer)
							bitmap.bitmapData.copyPixels(task.buffer, rect, origin, null, null, true);
					}
				}
			}
			catch (e:Error)
			{
				reportError(e);
			}
		}
		
		//-------------------------------------------------------------------------------------------------
		
		// backwards compatibility
		[Deprecated(replacement="zoomBounds")] public function set dataBounds(value:Object):void
		{
			setSessionState(zoomBounds, value);
		}
	}
}
