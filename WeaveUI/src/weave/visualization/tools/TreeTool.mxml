
<ui:DraggablePanel xmlns="weave.visualization.tools.*"
                   xmlns:mx="http://www.adobe.com/2006/mxml"
                   xmlns:ui="weave.ui.*" 
                   xmlns:CustomDataGrid="weave.ui.CustomDataGrid.*"
                   layout="absolute" implements="weave.api.ui.IVisToolWithSelectableAttributes"
                   title="{lang('Tree')}" xmlns:editors="weave.editors.*">
<mx:Tree width="100%" height="100%" id="treeView" allowMultipleSelection="true"/>
<mx:Script>
<![CDATA[

import weave.Weave;
import weave.api.WeaveAPI;
import weave.api.ui.IVisTool;
import weave.api.newLinkableChild;
import weave.api.linkBindableProperty;
import weave.data.AttributeColumns.DynamicColumn;
import weave.data.KeySets.KeySet;
import weave.core.LinkableBoolean;
import weave.utils.ColumnUtils;
import weave.utils.DebugUtils;
import weave.api.data.IQualifiedKey;

import mx.events.ListEvent;
import mx.events.TreeEvent;
import mx.controls.listClasses.IListItemRenderer;

public const parentColumn:DynamicColumn = newLinkableChild(this, DynamicColumn, handleColumnChanges, true);
public const labelColumn:DynamicColumn = newLinkableChild(this, DynamicColumn, handleColumnChanges, true);
public const iconColumn:DynamicColumn = newLinkableChild(this, DynamicColumn, handleColumnChanges, true);

public const enableProbing:LinkableBoolean = newLinkableChild(this, LinkableBoolean);
public const probeIncludesChildren:LinkableBoolean = newLinkableChild(this, LinkableBoolean);
public const selectIncludesChildren:LinkableBoolean = newLinkableChild(this, LinkableBoolean);

private const _probe:KeySet = Weave.defaultProbeKeySet;
private const _selection:KeySet = Weave.defaultSelectionKeySet;

WeaveAPI.registerImplementation(IVisTool, TreeTool, "Tree Tool");

override protected function constructor():void
{
    super.constructor();
}
private static function objectToKey(row:Object, index:int, array:Array):IQualifiedKey 
{
    return row.qkey; 
}
private static function keyToObject(key:IQualifiedKey, index:int, array:Array):Object
{
    return {qkey: key};
}
private static function flattenTree(parent:Object):Array
{
    var queue:Array = [];
    var output:Array = [];

    queue.push(parent);

    while (queue.length > 0)
    {
        var node:Object = queue.pop();

        output.push(node);

        if (node.children) for (var idx:int = 0; idx < node.children.length; idx++)
        {
            queue.push(node.children[idx]);
        }
    }
    return output;
}

private function handleSelectionChange(event:ListEvent)
{
    if (treeView.selectedItems == null) 
    {
            _selection.clearKeys();
            return;
    }

    var rows:Array = [];
    var keys:Array;
    var selection_len:int = treeView.selectedItems.length;

    for (var idx:int = 0; idx < selection_len; idx++)
    {
        var row:Object = treeView.selectedItems[idx];
        var local_rows:Array;

        if (selectIncludesChildren.value)
        {
            local_rows = flattenTree(row);
        }
        else
        {
            local_rows = [row];
        }

        rows = rows.concat(local_rows);
    }

    keys = rows.map(objectToKey);

    _selection.replaceKeys(keys);

    return;
}

private function handleRollOver(event:ListEvent):void
{
    if (!enableProbing.value) return;

    var renderer:IListItemRenderer = treeView.indexToItemRenderer(event.rowIndex);
    var keys:Array;
    var rows:Array;

    if (!renderer) return;

    if (probeIncludesChildren.value) 
    {
        rows = flattenTree(renderer.data);
    }
    else
    {
        rows = [renderer.data];
    }

    keys = rows.map(objectToKey);

    _probe.replaceKeys(keys);
    return;
}

private function handleRollOut(event:MouseEvent):void
{
    if (!enableProbing.value) return;

    _probe.clearKeys();
}

private function updateSelection():void 
{
    treeView.selectedItems = _selection.keys.map(keyToObject);
}

private function itemCompare(itemInProvider:Object, itemInSelection:Object):Boolean
{
    return itemInProvider.qkey == itemInSelection.qkey;
}

override protected function childrenCreated():void
{
    super.childrenCreated();

    parentColumnComponent.dynamicObject = parentColumn;
    labelColumnComponent.dynamicObject = labelColumn;
    iconColumnComponent.dynamicObject = iconColumn;

    treeView.addEventListener(ListEvent.ITEM_ROLL_OVER, handleRollOver);
    treeView.addEventListener(MouseEvent.ROLL_OUT, handleRollOut);
    treeView.addEventListener(ListEvent.CHANGE, handleSelectionChange);

    _selection.addGroupedCallback(this, updateSelection);

    linkBindableProperty(enableProbing, enableProbingCheckBox, "selected");
    linkBindableProperty(probeIncludesChildren, probeIncludesChildrenCheckBox, "selected");
    linkBindableProperty(selectIncludesChildren, selectIncludesChildrenCheckBox, "selected");

    treeView.selectedItemsCompareFunction = itemCompare;

}

private function handleColumnChanges():void
{
    /* Build a new data model for the Tree */
    var raw_data = ColumnUtils.joinColumns(getSelectableAttributes(), String, true);

    var keys_len:int = raw_data[0].length;
    var top_level:Array = [];
    var ids_to_obj:Object = {};
    var new_objs:Array = [];

    /* First pass: Build objects corresponding to each row */
    for (var idx:int = 0; idx < keys_len; idx++)
    {
        var new_obj:Object = {};

        var qkey:IQualifiedKey = raw_data[0][idx] as IQualifiedKey;
        var parent_id:String = raw_data[1][idx] as String;
        var label:String = raw_data[2][idx] as String;
        var iconColumn:String = raw_data[3][idx] as String;

        new_obj.label = label;
        new_obj.parent_id = parent_id;
        new_obj.qkey = qkey;
        new_obj.icon_id = iconColumn;
        new_obj.children = null;

        ids_to_obj[qkey.localName] = new_obj;
    }

    /* Second pass: add to appropriate parents */
    for (var id:String in ids_to_obj)
    {
        var row:Object = ids_to_obj[id];
        var parent:Object = ids_to_obj[row.parent_id];

        
        if (parent)
        {
            if (parent.children == null) parent.children = [];
            parent.children.push(row);
        }
        else
        {
            /* If this has an invalid parent, add it to root */
            top_level.push(row);
        }
    }

    treeView.dataProvider = top_level;

    return;
}

public function getSelectableAttributes():Array
{
    return [parentColumn, labelColumn, iconColumn];
}

public function getSelectableAttributeNames():Array
{
    return [parentColumnComponent.label, labelColumnComponent.label, iconColumnComponent.label];
}

]]>
</mx:Script>
<ui:ControlPanel>
        <mx:VBox label="{lang('Attributes')}">
            <ui:DynamicColumnComponent id="parentColumnComponent" label="{lang('Parent')}"/>
            <ui:DynamicColumnComponent id="labelColumnComponent" label="{lang('Label')}"/>
            <ui:DynamicColumnComponent id="iconColumnComponent" label="{lang('Icon')}" visible="false"/> 
        </mx:VBox>
        <mx:VBox label="{lang('Advanced')}">
            <mx:CheckBox id="enableProbingCheckBox" label="{lang('Enable mouseover linking')}"/>
            <ui:Indent>
                <mx:CheckBox id="probeIncludesChildrenCheckBox" enabled="{enableProbingCheckBox.selected}" label="{lang('Linking includes all children.')}"/>
            </ui:Indent>
            <mx:CheckBox id="selectIncludesChildrenCheckBox" label="{lang('Include children in selections.')}"/>
        </mx:VBox>
        <editors:WindowSettingsEditor target="{this}"/>
    </ui:ControlPanel>
</ui:DraggablePanel>