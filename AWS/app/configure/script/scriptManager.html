<!DOCTYPE html>
<html  lang="en" ng-app="ScriptUpload">
	<head>
		<meta charset="UTF-8" />
		<title> Script Upload Interface</title>
		<script src="lib/jquery/jquery.js"></script>
		<script src="aws.js"></script>
		<script src='lib/angular/angular.js'></script>
	</head>
	<body ng-controller = "ScriptUploadController" >
			
		<input type="button" value="Upload" ng-click="showUpload()"/> 
		<input type="button" value="New" ng-click="showTextArea()"/> <br><br>	
		List Of Scripts: <br> 
		
		<select ng-model = "scriptSelected" multiple ng-options="script for script in listOfScripts"></select><br>
		
		<input type="button" value="Delete"/>
		
		<div ng-show="saveButton">
			<div ng-show="uploadScript">
				Script: <input type="file">	<br>
				Metadata: <input type="file" title="Metadata"> <br>
			</div>
	
			<div ng-show=textScript>
				<div>
					Script: <br>
					<textarea rows="20" cols="80"></textarea>
				</div>
				<div>
					Metadata: <br>
					<textarea rows="20" cols="80"></textarea>
				</div> <br>
			</div>

			<input type="button" value="Save"/>
		</div>
		
		<script>
			var ScriptUpload =  angular.module('ScriptUpload', []);
			
			ScriptUpload.service("queryService", ['$q', '$rootScope', function($q, scope) {
				
				this.dataObject = {};
				
				this.getListOfScripts = function() {
				        
					var that = this;
				    if(this.dataObject.listOfScripts) {
				    	return this.dataObject.listOfScripts;
				    }
				    	
				    	
				   	var deferred = $q.defer();

				       aws.RClient.getListOfScripts(function(result) {
				            
				        	that.dataObject.listOfScripts = result;
				        	
				        	// since this function executes async in a future turn of the event loop, we need to wrap
				            // our code into an $apply call so that the model changes are properly observed.
				        	scope.$apply(function() {
				                deferred.resolve(result);
				            });
				        	
				        });
				        
				        // regardless of when the promise was or will be resolved or rejected,
				        // then calls one of the success or error callbacks asynchronously as soon as the result
				        // is available. The callbacks are called with a single argument: the result or rejection reason.
				        return deferred.promise;
				        
				    };
			}]);
			
			ScriptUpload.controller("ScriptUploadController", function($scope, queryService){
				
				var listOfScripts = [];
				$scope.uploadScript = false;
				$scope.textScript  = false;
				$scope.saveButton = false;
				queryService.getListOfScripts();
				
				$scope.$watch(function() {
					return queryService.dataObject.listOfScripts;
				}, function() {
					$scope.listOfScripts = queryService.dataObject.listOfScripts;
				});
				
				$scope.showUpload = function() {
					console.log("clicked");
					$scope.uploadScript = true;
					$scope.textScript = false;
					$scope.saveButton = true;
				}
				$scope.showTextArea = function() {
					$scope.uploadScript = false;
					$scope.textScript = true;
					$scope.saveButton = true;
				}
				
			});
			
			
		</script>	
	</body>
</html>
