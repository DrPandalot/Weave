<?xml version="1.0" encoding="utf-8"?>
<!--
/*
    Weave (Web-based Analysis and Visualization Environment)
    Copyright (C) 2008-2011 University of Massachusetts Lowell

    This file is a part of Weave.

    Weave is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License, Version 3,
    as published by the Free Software Foundation.

    Weave is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Weave.  If not, see <http://www.gnu.org/licenses/>.
*/
-->
<admin:WizardViewStack
			xmlns:mx="http://www.adobe.com/2006/mxml"
			xmlns:ui="weave.ui.*"
			xmlns:admin="weave.ui.admin.*"
			xmlns="weave.ui.admin.wizards.*" 
			label="Import shape data"
			creationComplete="handleCreationComplete()"
			>
	<mx:VBox width="100%" height="100%">
		<ui:Indent width="100%" label="Load Shape files" group="{indentGroup}">
			<mx:TextInput id="shpFileNameInput" enabled="true" width="240"/>
			<mx:Button label="Upload ..." click="browseAndUploadShapeFiles();"/>
			<mx:Button label="Choose File on Server" click="openServerBrowser();" />
			<mx:Label text="{fileUploadCount > 0 ? fileUploadCount + ' of ' + targetFileUploadCount + ' files uploaded' : ''}"/>
		</ui:Indent>
		<ui:Indent width="100%" group="{indentGroup}">
			<mx:CheckBox id="dbfImportCheckBox" label="Import DBF file as a Weave Data Table" selected="true" change="handleKeyColumnsChange()" />
			<ui:HelpComponent>
				The DBF file is used to generate record identifiers for the geometries contained in the SHP file.
				Creating a Data Table containing the rest of the DBF data is optional.
			</ui:HelpComponent>
		</ui:Indent>
		<ui:Indent id="dbfColumnNames" enabled="false" label="DBF Key column names" group="{indentGroup}">
			<ui:CustomComboBox id="dbfKeyColumnsCombo" dataProvider="{dbfColumns}" change="handleKeyColumnsChange()" editable="true" width="240"/>
			<ui:HelpComponent>
				Separate DBF column names by commas.  Values in the given columns will be concatenated to form unique identifiers for the shapes. These keys will also be used as the keys of the DataTable entry created from the DBF file.
			</ui:HelpComponent>
		</ui:Indent>
		<admin:SQLTableSelectorDialog indentGroup="{indentGroup}" id="tableSelector" enabled="false" showTableCombo="false" creationComplete="tableSelector.tableControls.label = 'SQL Table Prefix';" activeTable="{shpFileNameInput.text}" tableOverwriteCheckVisible="{Admin.instance.currentUserIsSuperuser}"/>
	</mx:VBox>
	<mx:VBox width="100%" height="100%">
		<ui:IndentTextInput label="Null flag values" enabled="false" id="nullFlagInput" group="{indentGroup}"
				toolTip="Specify flag values to treat as missing data, separated by commas"/>
		<mx:HBox id="geoCol" enabled="false">
			<mx:TextArea width="{indentGroup.measuredIndent}" borderThickness="0" editable="false" selectable="false" wordWrap="true" text="GeometryCollection &amp; DataTable name" textAlign="right"/>
			<mx:HBox verticalAlign="middle">
				<mx:TextInput id="geometryCollectionNameInput" text="{tableSelector.activeTable}"/>
				<ui:HelpComponent>
					Both a GeometryCollection and DataTable entry will be created in sqlconfig.xml having the name specified here.
				</ui:HelpComponent>
			</mx:HBox>
		</mx:HBox>
		<ui:Indent id="keyType" enabled="false" label="Key type" group="{indentGroup}">
			<ui:CustomComboBox id="shpKeyTypeCombo" minWidth="100" text="{geometryCollectionNameInput.text}" editable="true" dataProvider="{Admin.instance.keyTypes}" toolTip="{lang('Choose a key type that corresponds to the type of the column that was chosen for the DBF key column name(s).  For example US State Fips codes or US State Abbreviations.')}"/>
			<mx:Button label="Refresh" click="Admin.service.getKeyTypes()"/>
			<ui:HelpComponent>
				If two tables have compatible keys, you should give them the same key type. <!--
				-->If two tables have incompatible keys, they should not have the same key type. <!--
				-->Weave only allows two columns to be compared if they have the same key type.
			</ui:HelpComponent>
		</ui:Indent>
		<ui:Indent id="projectionCode" enabled="false" label="Projection SRS" group="{indentGroup}">
			<mx:TextInput id="srsProjectionTxtInput" text="EPSG:4326"/>  <!-- is it a good idea to use the standard lat/long as the default? -->
			<mx:Button id="srsProjectionValidateBtn" label="Validate" click="validateProjectionSRS()"/>
		</ui:Indent>
	</mx:VBox>
	<mx:Script>
		<![CDATA[
			import mx.collections.ArrayCollection;
			import mx.controls.Alert;
			import mx.managers.PopUpManager;
			import mx.rpc.AsyncToken;
			import mx.rpc.events.FaultEvent;
			import mx.rpc.events.ResultEvent;
			import mx.utils.StringUtil;
			
			import weave.api.WeaveAPI;
			import weave.services.Admin;
			import weave.services.WeaveAdminService;
			import weave.services.addAsyncResponder;
			import weave.ui.IndentGroup;
			import weave.ui.admin.ServerFileViewer;
			
			private static const paddingIndent:int = 20;
			public const indentGroup:IndentGroup = new IndentGroup();
			
			private function handleCreationComplete():void
			{
				shapeFileReferenceList.addEventListener(Event.SELECT, shapeFileSelectedHandler);
				
			
				
				backEnabled = false;
				nextEnabled = false;
				finishEnabled = false;
			}
			
			[Bindable] public var dbfColumns:Array = [];
			[Bindable] private var fileUploadCount:int = 0;
			[Bindable] private var targetFileUploadCount:int = 0;
			private var _dbfFilesToRequestColumnNamesFrom:Array = []; // of String
			private function shapeFileSelectedHandler(event:Event):void
			{
				fileUploadCount = 0;
				targetFileUploadCount = shapeFileReferenceList.fileList.length;
				shpFileNameInput.text = '';
				_dbfFilesToRequestColumnNamesFrom.length = 0;
				
				for each (var fileRef:FileReference in shapeFileReferenceList.fileList)
				{
					var name:String = fileRef.name;
					var ext:String = name.substr(name.length - 4).toLowerCase(); // lower case extension
					var nameWithoutExt:String = name.substr(0, name.length - 4);
					if (ext == ".shp")
					{
						if (shpFileNameInput.text != '')
							shpFileNameInput.text += ',';
						shpFileNameInput.text += nameWithoutExt;
					}
					if (ext == ".dbf")
					{
						dbfColumns = [];
						_dbfFilesToRequestColumnNamesFrom.push(fileRef.name);
					}
					
					fileRef.addEventListener(IOErrorEvent.IO_ERROR, fileErrorHandler);
					fileRef.addEventListener(Event.COMPLETE, handleFileLoadComplete);
					fileRef.load();
				}
			}
			
			private var shapeFileReferenceList:FileReferenceList = new FileReferenceList();
			private function browseAndUploadShapeFiles():void
			{
				var fileTypes:Array = [new FileFilter("Shape Files", "*.*")];
				shapeFileReferenceList.browse(fileTypes);
			}

			private function fileErrorHandler(event:IOErrorEvent):void
			{
				var fileRef:FileReference = event.target as FileReference;
				if (shapeFileReferenceList.fileList.indexOf(fileRef) >= 0)
				{
					WeaveAdminService.messageDisplay(
						"File upload failed",
						"File: " + fileRef.name + "\n" + "Size: " + fileRef.size + "\n" + event.text,
						true
					);
				}
			}
			
			private function handleFileLoadComplete(event:Event):void
			{
				var fileRef:FileReference = event.target as FileReference;
				if (shapeFileReferenceList.fileList.indexOf(fileRef) >= 0)
				{
					var query:AsyncToken = Admin.service.uploadFile(fileRef.name, fileRef.data);
					addAsyncResponder(query, handleFileUploadComplete, null, fileRef);
				}
			}
			
			private function handleFileUploadComplete(event:ResultEvent, token:Object = null):void
			{
				if (shapeFileReferenceList.fileList.indexOf(token) >= 0)
				{
					fileUploadCount++;
					
					if( fileUploadCount == targetFileUploadCount )
					{
						addAsyncResponder(
							Admin.service.getDBFColumnNames(_dbfFilesToRequestColumnNamesFrom),
							handleDBFColumnNames
						);
						enableAllWidgets();
					}
				}
			}
			
			private function handleDBFColumnNames(event:ResultEvent, token:Object):void
			{
				dbfColumns = event.result as Array || [];
				handleKeyColumnsChange();
			}
						
			private var _serverFileBrowser:ServerFileViewer = null;
			private function openServerBrowser():void
			{
				_serverFileBrowser = ServerFileViewer.createServerFileViewer(this, ServerFileViewer.INPUT_SHP);
				_serverFileBrowser.selectButton.addEventListener(MouseEvent.CLICK, serverFileBrowserSelectFile);				
			}
			private function serverFileBrowserSelectFile(e:MouseEvent):void
			{
				var tableName:String = _serverFileBrowser.datagrid.selectedItem.name;
				tableName = tableName.substring(0,tableName.lastIndexOf("."));
				
				shpFileNameInput.text = tableName;
				
				_dbfFilesToRequestColumnNamesFrom = [tableName + ".dbf"];
				
				Admin.service.getDBFColumnNames(_dbfFilesToRequestColumnNamesFrom);
				tableSelector.activeTable = tableName;
				
				PopUpManager.removePopUp(_serverFileBrowser);
				enableAllWidgets();
			}
			
			override public function finish():void
			{
				var alertTitle:String = "Missing parameter";
				if (shpFileNameInput.text == '')
					Alert.show("You must upload a DBF file.", alertTitle);
				else if (dbfKeyColumnsCombo.text == '')
					Alert.show("You must specify the name(s) of the key column(s) in the DBF file.", alertTitle);
				else if (tableSelector.activeTable == '')
					Alert.show("You must specify the name of the destination SQL table.", alertTitle);
				else if (geometryCollectionNameInput.text == '')
					Alert.show("You must specify the name of the GeometryCollection to be visible by users.", alertTitle);
				else
				{
					
					var trimmedKeyCols:String = StringUtil.trimArrayElements(dbfKeyColumnsCombo.text,",");
					var keyCols:Array = trimmedKeyCols.split(","); 
					
					disable();
					addAsyncResponder(
						Admin.service.importSHP(
							shpFileNameInput.text,
							keyCols,
							tableSelector.activeSchema,
							tableSelector.activeTable,
							tableSelector.tableOverwriteCheck.selected,
							geometryCollectionNameInput.text,
							shpKeyTypeCombo.text,
							srsProjectionTxtInput.text,
							nullFlagInput.text,
							dbfImportCheckBox.selected
						),
						function(..._):void
						{
							weaveTrace(lang("Data table entry created successfully."));
							close();
						},
						enable
					);
				}
			}
			
			private function enableAllWidgets(enable:Boolean = true):void
			{
				dbfColumnNames.enabled = enable;
				geoCol.enabled = enable;
				nullFlagInput.enabled = enable;
				keyType.enabled = enable;
				tableSelector.enabled = enable;
//				nextEnabled = enable;
				backEnabled = enable;
//				finishEnabled = enable;
				projectionCode.enabled = enable;
				
				handleKeyColumnsChange();
			}
			
			/**
			 * This function is called to check if the selected key column has unique values.
			 * If the column does not have unique values we set the errorString on the key column
			 * combo box and disable the next and finish buttons.
			 * */
			private function handleKeyColumnsChange():void
			{
				if(dbfKeyColumnsCombo.dataProvider == null ||(dbfKeyColumnsCombo.dataProvider as ArrayCollection).length == 0)
				{
					return;
				}
				
				if(!dbfImportCheckBox.selected )
				{
					dbfKeyColumnsCombo.errorString = '';
					finishEnabled = true;
					nextEnabled = true;
					return;
				}
				
				var trimmedKeyCols:String = StringUtil.trimArrayElements(dbfKeyColumnsCombo.text,",");
				var keyCols:Array = trimmedKeyCols.split(","); 
				
				addAsyncResponder(
					Admin.service.checkKeyColumnForDBFImport(_dbfFilesToRequestColumnNamesFrom, keyCols),
					keyColumnsCheckedForUniqueness
				);
			}
			private function keyColumnsCheckedForUniqueness(event:ResultEvent, token:Object = null):void
			{
				if(!event.result)
				{
					dbfKeyColumnsCombo.errorString = 'Key values are not unique';
					finishEnabled = false;
					nextEnabled = false;
				}
				else
				{
					dbfKeyColumnsCombo.errorString = '';
					finishEnabled = true;
					nextEnabled = true;
				}
				
				dbfKeyColumnsCombo.invalidateDisplayList();
			}
			
			private function validateProjectionSRS():void
			{
				var alertTitle:String = 'Projection Validation';
				var message:String;
				
				if (WeaveAPI.ProjectionManager.projectionExists(srsProjectionTxtInput.text))
					message = 'Projection code is valid.';
				else
					message = 'Projection code is invalid or not recognized.';
				
				Alert.show(message, alertTitle);
			}
		]]>
	</mx:Script>
</admin:WizardViewStack>
